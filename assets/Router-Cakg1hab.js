const i=!0,e="1.0.0-beta.3+0000000000000000000000000000000000000000",n="Router",t=JSON.parse('[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"_log_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"_unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/+Wc6XLbNhDHKZu0TcmyZPmK3Svp3bRpKYnU0dNt0/u+lM+KYz8HHyPta7Rf2qer/jFXWsHojDteTPxPMMOhpYV2f1wuARBYuBadl8nsqFV/x9V5vTrj+060XKTucXXOrla6hrqyUIw1AsYVAsZVAsaYgDEhYFwjYFwnYNwgYEwJGOsEjA0Cxk0CxiYB4xYBY4uAsU3AuB2AMQRnh4Rzx5BTj+1D8e5G1z9G9wgY9wkYDwgYbxAwHhIwHhEwPkPA+CwB43MEjM8TML5AwHiTgPEWAeOLBIwvETC+TMD4CgHjqwSMrxEwvk7A+AYB420CxjcJGN8iYLxDwPg2AeM7BIwZAWOXgLFHwNgnYMwJGAsCxgEB45CAcUTAOCZgfJeA8T0CxvcJGD8gYPyQgPEjAsZjAsaPCRg/IWD8lIDxLgHjZwSMnxMwfkHA+CUB41cEjF8TMH5DwPgtAeN3BIzfEzD+QMD4IwHjTwSMPxMw/hKAMQTnryScv5FwTgJxRvcc6JXZgY1b2BiFjUfY2IONM9iYgo0f2FiBjQvYGIDEeyS2I3G8PTuQ+IykYiTsIgkWSaZI4kSSJJIQkeSHJDokqSEJDElWSGJCktDN2XFrdiCJBEkaSIJAkgEW8bFIjkVoLPJiERWLlFgExCIbFrGwSISrwiIHFhEwSY9JcEwyYxIXk6SYhMQkHybRMEmFSSBMsmASQyYJ8JKLl0i8pOElCC8ZGMRjkIxBKAZ5GERhkIJBADpZdGLoJNAIo5FDI4KHFA8AgmsS/XeRIPmnOqfVeUXJDTfRdVPHrqX+UTa+n3quz5C/n1Y6N4LoL4aiPw3Dn8lG27vlQr++FrG7Wp0n5cKXk3KZSeo8VHUeOnXkesLc7zwP669ur+n4KFLXIrbrYWz3a449fV+0TOzXo5Cxeb4pWdsTHtc/0nY0pU654Kk5sri8eB0iS5RM7i/s3Fb13NjacGTCgiLx21S+kXKvksk9jZVOu3gtRmHjNc8eX7zm3ScxXmNHFpcXr+P/xquOLTdek2hRpC0V2ZqS/e7I1pXsj3Jhu1Acg+rvsG3yeR+snz3rPmzHw69toayXC39IDK6q7xLlv0f+0fUdWapkcblsp159jpUdrUs4Eqd+Xn1uVec19Rv5fdtjf82xv8Tt+c71S+qpn3rqI9buVH83qgMx9Jf8Jrr47OI4rj5nVyrDwtdO2ukfdH1toaH+U9HfCKK/l4n+zTD8836qGeb+DkT/Vhj+efy0wvD3RH87DP+Z6N8Owz9/j+kE0V/Mx+U7Yfjn8b8bxv9z/r0w/HP9+2H45/f3IIz+sYw7bkSL4o4zD9X3dv1/b3zZcabYrzusocaZhw6P6x89zoTsyMPa9sjcZ/TIY+fIY8ena9NQ14Ghrm1DXQ1DXfuGutqGuuqGuvYMdbUMdaWGuizvo6W/LGN111CXZaxuGeq6ru2E5fNo6fvrGqsbhrosY8IyVi39tWOoy7KNthwDNA11WfYdls/QdY2vp6H9CtEPhV0PzDLfPFhkp987D2aoPxNfS6zquW9tU64vcer/6fh5M4ife1N5J5M2SPvCN1dlabvm2Isi//us2G96eIS77pFd5R/Mno5OTsf383wwzIuifzKsOfqF1f1OzzvrPkfX970b++bVDH098q3xtJRfUWIl23JkiZIJo17j8c07WvJfxv/aftsjc8del72XnWg51vTz2IgWz3Bc2l/7cHTeljxirPQn0fIabuTYT5z6f1ef3bbuqs/I2XDaPetPz6bF9MGD/GTacfRrH8JP/wJJ9PoyCV0AAA==","debug_symbols":"tZbRCoMgGIXfxWsv0pV/7VXGGFYWglhYDUb07tOILbbrcxMd+fXzwg/OylpTL/3D+m6Y2PW2Mjc0eraDj2ndOKuDdc72j/Myy9JHFGrfMI3apzzNOszsKi5CVpwZ3+7/VMVDOutMTEJt/G+e5DFM9JnMabvzCCA0oEQDKjBAZWiAQAMkGnBBA3I0oEAD0CYrtMkKbbJCm0xokwltMqFNJrTJhDaZ0CYT2mRCm0xQk7eYnjpYXTtzNJxu8c2p8Myv0fx0nzEMjWmXYFIL+hag9BpzyQuZrp3sFWXGRVlESAS9AQ==","brillig_names":["process_log"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":58},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"}},"parameters":[],"return_type":null},"bytecode":"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","debug_symbols":"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0hWVSVdUJl1RmXRFZdIVlZOuqJx0ReWkKyonXVE56YrKSVdUTrqictIVlZOuqJx0ReWsKypnXVE564rKWVdUzrqictYVlbOuqJx1ReWsKypnXVG56IrKRVdULrqictEVlYuuqFx0ReWiKyoXXVG56IrKRVdUrrqictUVlauuqFx1ReWqKypXXVG56orKVVdUrrqictUVlRXtpb3C0RWVFe15vcLRFZUV7U29wtEVlRXtIb3C0RWVFe31vMJRFZVZ0Z7MKxxVUZkV7Z28wlEVldmpisqsaN/iFY6qqMyK9hde4aiKyqxoH+AHHF17+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3tY117+1jX3j7WtbePde3t45fv7WM3frLnOIfz8qhc8gSH3SOc+eDq6Da2PiAPi2MvycBt7MWmT2MvZnr3+k2Db7LTG7EzGLEzGrGTjNiZjNiZjdhZjNhZjdhpJB/yRvIhbyQf8kbyIW8kH3r9lug32WkkH/JG8iHfTT6Ux7EfxeaCod0kRFuGdpMRbRgaukmJtgztJifaMrSbpGjLUD1Z0YCHlOHRk2UMePRkAwMePav2gEfP4jrg0bMGXvFEPUvVgEfPijLg0RP4BzzK4nNUFp9ffYpA8IVvg6lwer5QU6zj2EzTUF/d0gfff22N3m9kAP4CNI60JKr3LMD7dCMmg5hlYgqIWSamgphlYhjELBLz6nMv2iHGg5hlYgKIWSYmgphlYgjELBODzHeFGGS+K8Qg810hBpnvCjHIfJeJSch8V4hB5rtCDDLfFWKQ+a4QQyBmmRhkvivEIPNdIQaZ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","brillig_names":["sync_notes"]},{"name":"_check_timestamp","is_unconstrained":true,"custom_attributes":["public","internal","view"],"abi":{"error_types":{"11405868724477732285":{"error_kind":"string","string":"Function _check_timestamp can only be called internally"},"13418685691864489983":{"error_kind":"string","string":"Function _check_timestamp can only be called statically"},"1433889167918961673":{"error_kind":"fmtstring","item_types":[],"length":17},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"8443716675528357851":{"error_kind":"string","string":"Timestamp mismatch."}},"parameters":[{"name":"operation","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"JwACBAEoAAABBIBLJwAABAMnAgMEAicCBAQAHxgABAADgEkdAIBJgEkCHQCASoBKBS4IgEkAAS4IgEoAAiUAAABZJQAAAIQoAgABBIBLJwICBAA7DQABAAIoAIBDAgAEKACARAIABigAgEUCAAEoAIBGAgACKACARwIABSgAgEgCAAMmJQAAA1IeAgAEAR4CAAUACjgEBQYkAgAGAAAApSUAAAN7HgIABAknAgUAAQo4BAUGJAIABgAAAMElAAADjR4CAAQGHAwEBQAcDAIEAAo4BQQCDDgFBAYLKAABgEUABCcCBQEBJAIABAAAAzsjAAAA9AsoAAGARgAHFgwCCCQCAAcAAAMpIwAAAQ0LKAABgEgACSQCAAkAAAMXIwAAASILKAABgEMACiQCAAoAAAMAIwAAATcLKAABgEcAChYMBgskAgAKAAAC6SMAAAFQCygAAYBEAAgkAgAIAAAC1yMAAAFlJwIBAkknAggCZCcCCgJhJwILAnInAgwCbycCDQJpJwIOAnYnAg8CZScCEAIgJwIRAmwnAhICbicCEwJ0JwIUAnAtCAEVJwIWBBIAEAEWAScDFQQBACgVAhYtDBYXLQ4BFwAoFwIXLQ4SFwAoFwIXLQ4OFwAoFwIXLQ4KFwAoFwIXLQ4RFwAoFwIXLQ4NFwAoFwIXLQ4IFwAoFwIXLQ4QFwAoFwIXLQ4MFwAoFwIXLQ4UFwAoFwIXLQ4PFwAoFwIXLQ4LFwAoFwIXLQ4KFwAoFwIXLQ4TFwAoFwIXLQ4NFwAoFwIXLQ4MFwAoFwIXLQ4SFycCAQEAJwIIBAAKOAEFCiQCAAoAAALOJwILBBMtCAEMJwINBBMAEAENAS0MDA0qAwANBRPmMpnlFxQJACgNAg0AKBUCDicCDwQRLgQADoADLgQADYAELgQAD4AFJQAAA58nAg4EEQA4DQ4NLQ4IDQAoDQINPA0MCy0MAQYjAAAC4C0MCwYjAAAC4C0MBgIjAAAC9wQ4CwgBLQwBAiMAAAL3LQwCCSMAAAMOEjgGAgEtDAEJIwAAAw4tDAkHIwAAAyAtDAYHIwAAAyAtDAcEIwAAAzItDAgEIwAAAzItDAQDIwAAA0QtDAIDIwAAA0QkAgADAAADUSUAAAPlJigAgAQEeAANAAAAgASAAyQAgAMAAAN6KgEAAQX3ofOvpa3UyjwBAQImKgEAAQWeScksjTulvTwBAQImKgEAAQW6OL+KoDMf/zwBAQImAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAPkLgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAAOzJioBAAEFdS4blGTo99s8AQECJi4AGMoYyg==","debug_symbols":"zVrbTuMwEP2XPPdhxp7x2PsrK4QKFFSpalEpK60Q/74Oi9NAQgtNjmQeEKEzORd7Jq7jl+ZudfP8cL3e3u+eml+/X5rN7nZ5WO+2+erlddHc7Nebzfrhuv/vhtpf7O0t4elxuW2vnw7L/aH5xV4lLprV9u7t7xDyTe7Xm1W+Yn1dDOIlcgmX6I7RbeIgOKqG9+Coxv3gq0XD4r5gZO7IKLlzjIJoYRRUzjCSmDpGpANG3/EoyQdGbZ66y/ICXZino3lCxiVPKPkzzlkOeQ83pnTaueSkjGVyIX12zug7jHSgxPSyvHghXoyX5SU/lpfMiie9UWon4SA0OF9ig5N4ZprmnzJNE4XPZqd4mgxTb2pnNjnH0agAJt/pJhkmjbtFoStQJndat09dv6Cjao7+DYD9ZABxZV6Kdx8ARiaxj1IGLA95L3qMuXbUfegNAttYMCcqwY75dHAWZXoUmPq+/Ldluu/StRAxGfguMhlAuQhWbwOALzriTwCMyliZpwFASNMVWAEINARINBkg+NJfQxgAeGasRXlKTgew7gFOfgDgAxhADQwQHBoArcDQCgytIKIVRLSChFaQwAqEHBoArYDRChitwKEVOHC7Fs9oALQCQSsQtAIlNICgAcDLFgkeDRDBAOiHvqAf+nkbCQ2ALrSELrSkaABwoSkJGgBcaMoeDQAuNEWvKhS9qlD0qkI9uNBUCA2ALjRBtwpFF5qiWwV6K0HRWwn5DQ0aAN0qIrrQIrpVRHShJXSrSNMLLUrZN432cVtzhEy5rR03ocVaJoF8NUyq8YSr8cRxNUxCLUw8VcNEa2Ei1XgywyprJiYzvBeZickMq565mFTjiVXjiVXz3InV1E6qpp+kWnqsUS2eGNXjSaqFCddSOyYzfP2R7vbDMxE2w8556PiHODhwFH/8BqlN+vGD/+o1X/1Z7tfLm83q/Wjm/fP2tndS8/D3cfXp0Objfne7unver9rjm8eTm+2KnU0WHCWT4bZUOSNzsPayXUVz1PypZdSM/A8=","brillig_names":["_check_timestamp"]},{"name":"check_timestamp","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"operation","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VXbasMwDP0XP+dBki1f+itjjLRNSyAkJU0Ho/TfZ4c67sXdCGODQV9CZJ8jnRzJzlGsq+Vh+1a3m24vFi9H0XSrcqi71kdHgTyu7XdlG8L9UPaDWJCyrhBVu/avzOpUiE3dVGKByKfiHk2gI5rITmhrcmBrTQQ7DV+DkR2rM9q/65SbDOWSI01KUHFCW5fLLrWMyRXCFfq1EKif1jyyxjyteWSNzVtDMlnD31ijkPmMVuhwQmseK7jfrkCQq2AknCkWaWKEPt97pFFRNEmjSXLYZuBSJzEpMyoYxeDPxViexFyOWlYMOu2mBjtz0WGdHWMJCqPxEgzcekn/W778W/kEUsazS8DSXenxwbKvm6bevl39xSA8lMpJZYyfxwy3s6V4PkXPp5j5FDuT4iMMyPy4sYun0XByFKX1RB++l31dLpsqeBl2D+0qWuvD4WMXd6L5u75bVetDX4U2pA6EWZFYKAy3VLhDGArmSdu4RFxI8FV95U8=","brillig_names":["store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal"],"verification_key":"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"},{"name":"check_block_number","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"operation","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VXbasMwDP0XP+fBkiVf+itjlLRNSyAkJU0Ho/TfZ5c67sXdCGyDQl+CZR9JR0dWfBCrarHfzOt23e3E7O0gmm5ZDnXXeusggE57u23ZBnM3lP0gZkjWFaJqV37JTMdCrOumEjMAPhb3aJQ6ohHtiLYmB7bWRLDT8nswsGM6o/1ap9hoMBcccGQCxAltXS660ioGJ5BX6PdCAL+keSSNfknzSBqTlwZVkoZ/kIaA+YwmcDCiNZ8y2D/P4HIZQNlU+IWoodP3YA2EEa3BJEJsM3ClEx1M3EkGOih/g47lkc7ldcvSAafdGNyZiy7r7FVWkiCKr6SRN3oiPHsB+N8FoFQqzjBKVu6KkTcWfd009WZ+9ZrJ8KHsk8YQC2SWtzeMeLqLnu5iprvYiS7egoDMd4xdnEnDSVHfR+/ozY+yr8tFUwUtw+m+XUZpvTl8buNJFH/bd8tqte+r0IbUAeVzKygIwr8kDC/LgnnkdtpCLpT0WX3mLw==","brillig_names":["store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal"],"verification_key":"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"},{"name":"_check_block_number","is_unconstrained":true,"custom_attributes":["public","internal","view"],"abi":{"error_types":{"10421965853029650238":{"error_kind":"string","string":"Function _check_block_number can only be called statically"},"1433889167918961673":{"error_kind":"fmtstring","item_types":[],"length":17},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2242946026394210301":{"error_kind":"string","string":"Block number mismatch."},"8209322232883590150":{"error_kind":"string","string":"Function _check_block_number can only be called internally"}},"parameters":[{"name":"operation","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JwACBAEoAAABBIBLJwAABAMnAgMEAicCBAQAHxgABAADgEkdAIBJgEkCLgiASQABLgiASgACJQAAAFIlAAAAfSgCAAEEgEsnAgIEADsNAAEAAigAgEMCAAQoAIBEAgAGKACARQIAASgAgEYCAAIoAIBHAgAFKACASAIAAyYlAAADQR4CAAQBHgIABQAKOAQFBiQCAAYAAACeJQAAA2oeAgAECScCBQABCjgEBQYkAgAGAAAAuiUAAAN8HgIABAUKOAQCBQw4BAIGCygAAYBFAAInAgQBASQCAAIAAAMqIwAAAOMLKAABgEYABxYMBQgkAgAHAAADGCMAAAD8CygAAYBIAAkkAgAJAAADBiMAAAERCygAAYBDAAokAgAKAAAC7yMAAAEmCygAAYBHAAoWDAYLJAIACgAAAtgjAAABPwsoAAGARAAIJAIACAAAAsYjAAABVCcCAQJ2JwIIAm8nAgoCaScCCwJlJwIMAiAnAg0CbCcCDgJuJwIPAnQnAhACcCcCEQJkJwISAmEnAhMCSScCFAJyLQgBFScCFgQSABABFgEnAxUEAQAoFQIWLQwWFy0OExcAKBcCFy0ODhcAKBcCFy0OARcAKBcCFy0OEhcAKBcCFy0ODRcAKBcCFy0OChcAKBcCFy0OERcAKBcCFy0ODBcAKBcCFy0OCBcAKBcCFy0OEBcAKBcCFy0OCxcAKBcCFy0OFBcAKBcCFy0OEhcAKBcCFy0ODxcAKBcCFy0OChcAKBcCFy0OCBcAKBcCFy0ODhcnAgEEACcCCAEACjgIBAokAgAKAAACvScCCwQTLQgBDCcCDQQTABABDQEtDAwNKgMADQUT5jKZ5RcUCQAoDQINACgVAg4nAg8EES4EAA6AAy4EAA2ABC4EAA+ABSUAAAOOJwIOBBEAOA0ODS0OAQ0AKA0CDTwNDAstDAgGIwAAAs8tDAsGIwAAAs8tDAYFIwAAAuYEOAsIAS0MAQUjAAAC5i0MBQkjAAAC/RI4BgUBLQwBCSMAAAL9LQwJByMAAAMPLQwGByMAAAMPLQwHAiMAAAMhLQwIAiMAAAMhLQwCAyMAAAMzLQwFAyMAAAMzJAIAAwAAA0AlAAAD1CYoAIAEBHgADQAAAIAEgAMkAIADAAADaSoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFce1fE3G+NAY8AQECJioBAAEFkKJCubMVTz48AQECJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAD0y4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAADoiYqAQABBR8gi4cBmc/9PAEBAiYuABjKGMo=","debug_symbols":"zVrbbuIwEP2XPOfBY8/N/ZVVVdE2rZAQVJSutKr493UoDpcEKJCR/FLhaoZz5sRnbBx/V6/N89f703T+tvisHv58V7PFy2Q1XczT6HtdV8/L6Ww2fX/a/3fl2j8Q3Cbh82Myb8efq8lyVT1AINS6auavm8/M6UveprMmjYDWdS8eFXI4qt9Ft4m9YCXibbCSwH7wY50Y0QlG4neMor/EiJEyIya8wAg1dowcHTPC32gU8YDRJo9uy6NwY54O5qETyHnoYrignKSQbbiAi+eVix7zs4ye47FyHH7DiHqVsN6WJzfiKdyYx4N5HCSnMUmX1U7DXjA7znOPnYYLE1V9NoEqhmO543AZ7GNHR/Q8nRA7I7tdKCRiGwC+GwB9njAY/AHAwOwKinl2pWexFz3EnDrqIYm6C5ahYIguB3uA88EATnIzSZ/jvi6tLN7drzt23kbBY929l7sBCHLBFKQHcKLpXgMgLj8rCa4HQP7+CgQ7o/QBTlj/GgAOufEx9wEi2koU3P0SiXQrqws9AIjGACcWyhEByBiArCsg6wrYugK2rkCsKxDrCtS6ArWuIFpXEI0rQOesAcwrMG7XCGgNYF2Bt67AW1cQgjWAGAOgtwZgYwACawDrVmG96KfTFGsAa6OJtdFEjQHU2mhq3SqitdGicasg610FWe8qyHpXQda7CgJjo5EP1gDGRqPgrQGsjYZgDWBtNOujBCJro5F1q2Bro7F1qxBro4l1q9D7jZbeRGQAOTzWHCCT31/I7hAa5YcJl8IkFqNJLEUTdlgMk1gKEwjFMNFSmPhiNBlhlzUSkxHei4zFhEphQsVoQsVowqWsO8zFeEeK6SdSTI/VYjTRYjSJvhgmpXhH/Ag/f7D7+v6dCBnh5Jw7/mkyHQPo1W+Q2qSrF/7HdRr9nSynk+dZs70z+fY1f9m7Qrn699Ec3ab8WC5emtevZdPeq9xdqWy9CQI1KCQy0C5zQLEGxnbYCgasNYhLqAn5Pw==","brillig_names":["_check_block_number"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"10421965853029650238":{"error_kind":"string","string":"Function _check_block_number can only be called statically"},"11405868724477732285":{"error_kind":"string","string":"Function _check_timestamp can only be called internally"},"13418685691864489983":{"error_kind":"string","string":"Function _check_timestamp can only be called statically"},"1433889167918961673":{"error_kind":"fmtstring","item_types":[],"length":17},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2242946026394210301":{"error_kind":"string","string":"Block number mismatch."},"2830029349304997821":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":27},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8209322232883590150":{"error_kind":"string","string":"Function _check_block_number can only be called internally"},"8443716675528357851":{"error_kind":"string","string":"Timestamp mismatch."}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]}]'),s={globals:{},structs:{functions:[{fields:[{name:"parameters",type:{fields:[{name:"operation",type:{kind:"integer",sign:"unsigned",width:8}},{name:"value",type:{kind:"field"}}],kind:"struct",path:"Router::check_block_number_parameters"}}],kind:"struct",path:"Router::check_block_number_abi"},{fields:[{name:"parameters",type:{fields:[{name:"operation",type:{kind:"integer",sign:"unsigned",width:8}},{name:"value",type:{kind:"integer",sign:"unsigned",width:64}}],kind:"struct",path:"Router::_check_timestamp_parameters"}}],kind:"struct",path:"Router::_check_timestamp_abi"},{fields:[{name:"parameters",type:{fields:[{name:"operation",type:{kind:"integer",sign:"unsigned",width:8}},{name:"value",type:{kind:"integer",sign:"unsigned",width:64}}],kind:"struct",path:"Router::check_timestamp_parameters"}}],kind:"struct",path:"Router::check_timestamp_abi"},{fields:[{name:"parameters",type:{fields:[{name:"operation",type:{kind:"integer",sign:"unsigned",width:8}},{name:"value",type:{kind:"field"}}],kind:"struct",path:"Router::_check_block_number_parameters"}}],kind:"struct",path:"Router::_check_block_number_abi"}]}},a=JSON.parse('{"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    // Safety: borrow is enforced to be boolean due to its type.\\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        // Safety: decomposition is properly checked below\\n        unsafe {\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            // Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unsafe in unconstrained\\n        unsafe {\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        // Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unconstrained context\\n        unsafe {\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        // 259, in base 256, big endian, is [1, 3].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        // 259, in base 256, little endian, is [3, 1].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    //#[test]\\n    //fn test_to_le_radix_brillig_1() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(1);\\n    //        crate::println(out);\\n    //        let expected = [0; 8];\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    //#[test]\\n    //fn test_to_le_radix_brillig_512() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(512);\\n    //        let mut expected = [0; 8];\\n    //        expected[0] = 1;\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"24":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"46":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"47":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"54":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/router_contract/src/main.nr","source":"mod test;\\nmod utils;\\n\\nuse dep::aztec::macros::aztec;\\n\\n/// The purpose of this contract is to perform a check in public without revealing what contract enqueued the public\\n/// call. This is achieved by having a private function on this contract that enqueues the public call and hence\\n/// the `msg_sender` in the public call is the address of this contract.\\n#[aztec]\\npub contract Router {\\n    use aztec::{macros::functions::{internal, private, public, view}, utils::comparison::compare};\\n\\n    // docs:start:check_timestamp\\n    /// Asserts that the current timestamp in the enqueued public call satisfies the `operation` with respect\\n    /// to the `value.\\n    #[private]\\n    fn check_timestamp(operation: u8, value: u64) {\\n        Router::at(context.this_address())._check_timestamp(operation, value).enqueue_view(\\n            &mut context,\\n        );\\n    }\\n\\n    #[public]\\n    #[internal]\\n    #[view]\\n    fn _check_timestamp(operation: u8, value: u64) {\\n        let lhs_field = context.timestamp() as Field;\\n        let rhs_field = value as Field;\\n        assert(compare(lhs_field, operation, rhs_field), \\"Timestamp mismatch.\\");\\n    }\\n    // docs:end:check_timestamp\\n\\n    /// Asserts that the current block number in the enqueued public call satisfies the `operation` with respect\\n    /// to the `value.\\n    #[private]\\n    fn check_block_number(operation: u8, value: Field) {\\n        Router::at(context.this_address())._check_block_number(operation, value).enqueue_view(\\n            &mut context,\\n        );\\n    }\\n\\n    #[public]\\n    #[internal]\\n    #[view]\\n    fn _check_block_number(operation: u8, value: Field) {\\n        assert(compare(context.block_number(), operation, value), \\"Block number mismatch.\\");\\n    }\\n}\\n"},"57":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// A dynamically sized array backed by PXE\'s non-volatile database (called capsules). Values are persisted until\\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\\npub struct CapsuleArray<T> {\\n    contract_address: AztecAddress,\\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\\n    base_slot: Field,\\n}\\n\\nimpl<T, let N: u32> CapsuleArray<T>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{\\n    /// Returns a CapsuleArray connected to a contract\'s capsules at a base slot. Array elements are stored in\\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\\n        Self { contract_address, base_slot }\\n    }\\n\\n    /// Returns the number of elements stored in the array.\\n    pub unconstrained fn len(self) -> u32 {\\n        // An uninitialized array defaults to a length of 0.\\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\\n    }\\n\\n    /// Stores a value at the end of the array.\\n    pub unconstrained fn push(self, value: T) {\\n        let current_length = self.len();\\n\\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\\n        // array, which is where we want to place the new value.\\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\\n\\n        // Then we simply update the length.\\n        let new_length = current_length + 1;\\n        capsules::store(self.contract_address, self.base_slot, new_length);\\n    }\\n\\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn get(self, index: u32) -> T {\\n        assert(index < self.len(), \\"Attempted to read past the length of a CapsuleArray\\");\\n\\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\\n    }\\n\\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn remove(self, index: u32) {\\n        let current_length = self.len();\\n        assert(index < current_length, \\"Attempted to delete past the length of a CapsuleArray\\");\\n\\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\\n        // array past the removed element one slot backward so that we don\'t end up with a gap and preserve the\\n        // contiguous slots. We can skip this when deleting the last element however.\\n        if index != current_length - 1 {\\n            // The source and destination regions overlap, but `copy` supports this.\\n            capsules::copy(\\n                self.contract_address,\\n                self.slot_at(index + 1),\\n                self.slot_at(index),\\n                current_length - index - 1,\\n            );\\n        }\\n\\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\\n        // the element we meant to delete in the first place) and update the length.\\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\\n    }\\n\\n    unconstrained fn slot_at(self, index: u32) -> Field {\\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\\n        // element.\\n        self.base_slot + 1 + index as Field\\n    }\\n}\\n\\nmod test {\\n    use crate::test::helpers::test_environment::TestEnvironment;\\n    use super::CapsuleArray;\\n    use protocol_types::address::AztecAddress;\\n\\n    global SLOT: Field = 1230;\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        TestEnvironment::new().unkonstrained().this_address()\\n    }\\n\\n    #[test]\\n    unconstrained fn empty_array() {\\n        let contract_address = setup();\\n\\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn empty_array_read() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        let _: Field = array.get(0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_push() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        assert_eq(array.len(), 1);\\n        assert_eq(array.get(0), 5);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn read_past_len() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        let _ = array.get(1);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_last() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(5);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_some() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        assert_eq(array.len(), 3);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 8);\\n        assert_eq(array.get(2), 9);\\n\\n        array.remove(1);\\n\\n        assert_eq(array.len(), 2);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 9);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_all() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        array.remove(1);\\n        array.remove(1);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n}\\n"},"58":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::execution_cache;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field];\\n    fn get_selector(self) -> FunctionSelector;\\n    fn get_name(self) -> str<N>;\\n    fn get_contract_address(self) -> AztecAddress;\\n    fn get_is_static(self) -> bool;\\n}\\n\\n// PrivateCallInterface\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let returns: T = returns_hash.get_preimage();\\n        returns\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns_hash.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateVoidCallInterface\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\\n    }\\n\\n    pub fn call(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticCallInterface\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n        }\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticVoidCallInterface\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicCallInterface\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    gas_opts: GasOpts,\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            gas_opts: GasOpts::default(),\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicVoidCallInterface\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n\\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.set_public_teardown_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticCallInterface\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticVoidCallInterface\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n"},"65":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        gas_settings::GasSettings,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Empty, FromField, Hash, ToField},\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn gas_settings(self) -> GasSettings {\\n        self.inputs.tx_context.gas_settings\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            // for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        // the number of side effects that took place), along with the hash of the return values. We validate these\\n        // by requesting a private kernel iteration in which the return values are constrained to hash\\n        // to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"66":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\\nuse crate::hash::{\\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\\n};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\\n\\npub struct PublicContext {\\n    pub args_hash: Option<Field>,\\n    pub compute_args_hash: fn() -> Field,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\\n        PublicContext { args_hash: Option::none(), compute_args_hash }\\n    }\\n\\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\\n    }\\n\\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\\n    }\\n\\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\\n    }\\n\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_l1_to_l2_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/\\n            self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash,\\n            leaf_index,\\n        );\\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()),\\n            \\"L1-to-L2 message is already nullified\\",\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\\n            \\"Tried to consume nonexistent L1-to-L2 message\\",\\n        );\\n\\n        self.push_nullifier(nullifier);\\n    }\\n\\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { send_l2_to_l1_msg(recipient, content) };\\n    }\\n\\n    pub unconstrained fn call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub unconstrained fn static_call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call_static(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_note_hash(note_hash) };\\n    }\\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_nullifier(nullifier) };\\n    }\\n\\n    pub fn this_address(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            address()\\n        }\\n    }\\n    pub fn msg_sender(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            sender()\\n        }\\n    }\\n    pub fn selector(_self: Self) -> FunctionSelector {\\n        // The selector is the first element of the calldata when calling a public function through dispatch.\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\\n        FunctionSelector::from_field(raw_selector[0])\\n    }\\n    pub fn get_args_hash(mut self) -> Field {\\n        if !self.args_hash.is_some() {\\n            self.args_hash = Option::some((self.compute_args_hash)());\\n        }\\n\\n        self.args_hash.unwrap_unchecked()\\n    }\\n    pub fn transaction_fee(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            transaction_fee()\\n        }\\n    }\\n\\n    pub fn chain_id(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            chain_id()\\n        }\\n    }\\n    pub fn version(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            version()\\n        }\\n    }\\n    pub fn block_number(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            block_number()\\n        }\\n    }\\n    pub fn timestamp(_self: Self) -> u64 {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            timestamp()\\n        }\\n    }\\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_l2_gas()\\n        }\\n    }\\n    pub fn fee_per_da_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_da_gas()\\n        }\\n    }\\n\\n    pub fn l2_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            l2_gas_left()\\n        }\\n    }\\n    pub fn da_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            da_gas_left()\\n        }\\n    }\\n    pub fn is_static_call(_self: Self) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { is_static_call() } == 1\\n    }\\n\\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        let mut out = [0; N];\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\\n        }\\n        out\\n    }\\n\\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n\\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\\n        }\\n    }\\n\\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\\n    where\\n        T: Packable<N>,\\n    {\\n        self.raw_storage_write(storage_slot, value.pack());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn is_static_call() -> Field {\\n    is_static_call_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_public_log(message: [Field]) {\\n    emit_public_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_opcode(gas, address, args)\\n}\\n\\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_static_opcode(gas, address, args)\\n}\\n\\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\\n    calldata_copy_opcode(cdoffset, copy_size)\\n}\\n\\n// `success_copy` is placed immediately after the CALL opcode to get the success value\\nunconstrained fn success_copy() -> bool {\\n    success_copy_opcode()\\n}\\n\\nunconstrained fn returndata_size() -> u32 {\\n    returndata_size_opcode()\\n}\\n\\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\\n    returndata_copy_opcode(rdoffset, copy_size)\\n}\\n\\npub unconstrained fn avm_return(returndata: [Field]) {\\n    return_opcode(returndata)\\n}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\nunconstrained fn avm_revert(revertdata: [Field]) {\\n    revert_opcode(revertdata)\\n}\\n\\nunconstrained fn storage_read(storage_slot: Field) -> Field {\\n    storage_read_opcode(storage_slot)\\n}\\n\\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\\n    storage_write_opcode(storage_slot, value);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(|| 0)\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeIsStaticCall)]\\nunconstrained fn is_static_call_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n// TODO(#11124): rename unencrypted to public in avm\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCalldataCopy)]\\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeReturndataSize)]\\nunconstrained fn returndata_size_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeReturndataCopy)]\\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\\n\\n#[oracle(avmOpcodeReturn)]\\nunconstrained fn return_opcode(returndata: [Field]) {}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\n#[oracle(avmOpcodeRevert)]\\nunconstrained fn revert_opcode(revertdata: [Field]) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeSuccessCopy)]\\nunconstrained fn success_copy_opcode() -> bool {}\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\\n"},"68":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"70":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr","source":"// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\\n\\npub mod private_logs;\\npub mod partial_notes;\\npub mod nonce_discovery;\\n\\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\\n/// one for the combined log and note type ID.\\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\\n\\n/// The maximum length of the packed representation of a note\'s contents. This is limited by private log size, encryption\\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\\npub global MAX_NOTE_PACKED_LEN: u32 =\\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\\n\\npub struct NoteHashAndNullifier {\\n    /// The result of NoteHash::compute_note_hash\\n    pub note_hash: Field,\\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\\n    pub inner_nullifier: Field,\\n}\\n\\n/// A function which takes a note\'s packed content, address of the emitting contract, nonce, storage slot and note type\\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\\n/// address).\\n///\\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\\n///\\n/// ```\\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\\n///     if note_type_id == MyNoteType::get_id() {\\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\\n///\\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n///\\n///         let note_hash = note.compute_note_hash(storage_slot);\\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\\n///             storage_slot\\n///         );\\n///\\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\\n///\\n///         Option::some(\\n///             aztec::discovery::NoteHashAndNullifier {\\n///                 note_hash, inner_nullifier\\n///             }\\n///         )\\n///     } else if note_type_id == MyOtherNoteType::get_id() {\\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\\n///     } else {\\n///         Option::none() // Unknown note type ID\\n///     };\\n/// }\\n/// ```\\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\\n\\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\\n///\\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\\n/// along with its `compute_note_hash_and_nullifier` function.\\npub unconstrained fn discover_new_notes<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    debug_log(\\"Performing note discovery\\");\\n\\n    private_logs::fetch_and_process_private_tagged_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n\\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n}\\n"},"71":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr","source":"use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::MAX_NOTE_HASHES_PER_TX,\\n    debug_log::debug_log_format,\\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\\n    traits::ToField,\\n};\\n\\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\\n/// the complete note information, since it does not include content, storage slot, etc.\\npub struct DiscoveredNoteInfo {\\n    pub nonce: Field,\\n    pub note_hash: Field,\\n    pub inner_nullifier: Field,\\n}\\n\\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\\n/// cases it will contain a single element.\\n///\\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\\npub unconstrained fn attempt_note_nonce_discovery<Env>(\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\\n    let discovered_notes = &mut BoundedVec::new();\\n\\n    debug_log_format(\\n        \\"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\\",\\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\\n    );\\n\\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\\n    // is one of the note hashes created by the transaction.\\n    array::for_each_in_bounded_vec(\\n        unique_note_hashes_in_tx,\\n        |expected_unique_note_hash, i| {\\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\\n\\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\\n            // the note hash at the array index we\'re currently processing.\\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\\n            let hashes = compute_note_hash_and_nullifier(\\n                packed_note_content,\\n                storage_slot,\\n                note_type_id,\\n                contract_address,\\n                candidate_nonce,\\n            )\\n                .expect(f\\"Failed to compute a note hash for note type {note_type_id}\\");\\n\\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\\n\\n            if unique_note_hash == expected_unique_note_hash {\\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn\'t, then\\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\\n                // application already has more direct means of making a call to it fail the transaction.\\n                discovered_notes.push(\\n                    DiscoveredNoteInfo {\\n                        nonce: candidate_nonce,\\n                        note_hash: hashes.note_hash,\\n                        inner_nullifier: hashes.inner_nullifier,\\n                    },\\n                );\\n\\n                // We don\'t exit the loop - it is possible (though rare) for the exact same note content to be present\\n                // multiple times in the same transaction with different nonces. This typically doesn\'t happen due to\\n                // notes containing random values in order to hide their contents.\\n            }\\n        },\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered a total of {0} notes\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    *discovered_notes\\n}\\n"},"72":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr","source":"use crate::{\\n    capsules::CapsuleArray,\\n    discovery::{\\n        ComputeNoteHashAndNullifier,\\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\\n    },\\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\\n    debug_log::debug_log_format,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\\n// TODO(#11630): come up with some sort of slot allocation scheme.\\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\\n\\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\\n/// the packed public content.\\n// TODO(#10273): improve how contract log siloing is handled\\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\\n\\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\\n/// size and extra fields in the log (e.g. the tag).\\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\\n\\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\\n/// log that will complete it and lead to a note being discovered and delivered.\\n#[derive(Serialize, Deserialize)]\\npub(crate) struct DeliveredPendingPartialNote {\\n    pub(crate) note_completion_log_tag: Field,\\n    pub(crate) storage_slot: Field,\\n    pub(crate) note_type_id: Field,\\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\\n    pub(crate) recipient: AztecAddress,\\n}\\n\\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\\n/// notes being delivered to PXE if completed.\\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let pending_partial_notes = CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    );\\n\\n    debug_log_format(\\n        \\"{} pending partial notes\\",\\n        [pending_partial_notes.len() as Field],\\n    );\\n\\n    let mut i = &mut 0;\\n    whyle(\\n        || *i < pending_partial_notes.len(),\\n        || {\\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\\n\\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\\n            if maybe_log.is_none() {\\n                debug_log_format(\\n                    \\"Found no completion logs for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                *i += 1 as u32;\\n                // Note that we\'re not removing the pending partial note from the PXE DB, so we will continue searching\\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\\n                // is somehow removed from the PXE DB.\\n            } else {\\n                debug_log_format(\\n                    \\"Completion log found for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                let log = maybe_log.unwrap();\\n\\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\\n                // that we\'re getting the logs from the expected contract.\\n                // TODO(#10273): improve how contract log siloing is handled\\n                assert_eq(\\n                    log.log_content.get(0),\\n                    contract_address.to_field(),\\n                    \\"Got a public log emitted by a different contract\\",\\n                );\\n\\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\\n                // complete packed content.\\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\\n                let complete_packed_note_content = array::append(\\n                    pending_partial_note.packed_private_note_content,\\n                    packed_public_note_content,\\n                );\\n\\n                let discovered_notes = attempt_note_nonce_discovery(\\n                    log.unique_note_hashes_in_tx,\\n                    log.first_nullifier_in_tx,\\n                    compute_note_hash_and_nullifier,\\n                    contract_address,\\n                    pending_partial_note.storage_slot,\\n                    pending_partial_note.note_type_id,\\n                    complete_packed_note_content,\\n                );\\n\\n                debug_log_format(\\n                    \\"Discovered {0} notes for partial note with tag {1}\\",\\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\\n                );\\n\\n                array::for_each_in_bounded_vec(\\n                    discovered_notes,\\n                    |discovered_note: DiscoveredNoteInfo, _| {\\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\\n                        // temporary node connectivity issue - is simply throwing good enough here?\\n                        assert(\\n                            deliver_note(\\n                                contract_address,\\n                                pending_partial_note.storage_slot,\\n                                discovered_note.nonce,\\n                                complete_packed_note_content,\\n                                discovered_note.note_hash,\\n                                discovered_note.inner_nullifier,\\n                                log.tx_hash,\\n                                pending_partial_note.recipient,\\n                            ),\\n                            \\"Failed to deliver note\\",\\n                        );\\n                    },\\n                );\\n\\n                // Because there is only a single log for a given tag, once we\'ve processed the tagged log then we\\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\\n                // being completed.\\n                pending_partial_notes.remove(*i);\\n\\n                // We don\'t increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\\n                // shifts the elements to the left if the removed element is not the last element.\\n            }\\n        },\\n    );\\n}\\n\\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\\n/// supports looping in unconstrained code.\\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\\n    if condition() {\\n        body();\\n        whyle(condition, body);\\n    }\\n}\\n"},"73":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr","source":"use std::static_assert;\\n\\nuse crate::{\\n    capsules::CapsuleArray,\\n    oracle::note_discovery::{deliver_note, sync_notes},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\\n    debug_log::{debug_log, debug_log_format},\\n};\\n\\nuse crate::discovery::{\\n    ComputeNoteHashAndNullifier,\\n    MAX_NOTE_PACKED_LEN,\\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\\n    partial_notes::{\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\\n    },\\n};\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\\n// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\n\\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\\n/// the note completion log tag).\\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\\n\\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\\n/// public logs that will complete them.\\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\\n    _contract_address: AztecAddress,\\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\\n    // decrypted log, letting us continue the work outside of PXE.\\n    sync_notes();\\n}\\n\\n/// Processes a log\'s ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\\n/// which the notes would\'ve been created (typically the same transaction in which the log was emitted), along with the\\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\\npub unconstrained fn do_process_log<Env>(\\n    contract_address: AztecAddress,\\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let log_plaintext = decrypt_log(log, recipient);\\n\\n    // The first thing to do after decrypting the log is to determine what type of private log we\'re processing. We\\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\\n    // improved upon in the future to also handle events, etc.\\n\\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\\n        destructure_log_plaintext(log_plaintext);\\n\\n    if log_type_id == 0 {\\n        debug_log(\\"Processing private note log\\");\\n\\n        attempt_note_discovery(\\n            contract_address,\\n            tx_hash,\\n            unique_note_hashes_in_tx,\\n            first_nullifier_in_tx,\\n            recipient,\\n            compute_note_hash_and_nullifier,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n        );\\n    } else if log_type_id == 1 {\\n        debug_log(\\"Processing partial note private log\\");\\n\\n        process_partial_note_private_log(\\n            contract_address,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n            recipient,\\n        );\\n    } else {\\n        // TODO(#11569): handle events\\n        debug_log_format(\\n            \\"Unknown log type id {0} (probably belonging to an event log)\\",\\n            [log_type_id],\\n        );\\n    }\\n}\\n\\nunconstrained fn destructure_log_plaintext(\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\\n    // `storage_slot` and `note_type_id` must be updated as well.\\n    static_assert(\\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\\n        \\"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\\",\\n    );\\n    let storage_slot = log_plaintext.get(0);\\n\\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\\n    // distinguish private note logs and partial note logs.\\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we\'d be able to\\n    // leverage enums and tagged unions to achieve this goal.\\n    let combined_type_id = log_plaintext.get(1);\\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\\n\\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    (storage_slot, note_type_id, log_type_id, log_payload)\\n}\\n\\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\\n/// suspected the note was created.\\npub unconstrained fn attempt_note_discovery<Env>(\\n    contract_address: AztecAddress,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) {\\n    let discovered_notes = attempt_note_nonce_discovery(\\n        unique_note_hashes_in_tx,\\n        first_nullifier_in_tx,\\n        compute_note_hash_and_nullifier,\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered {0} notes from a private log\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    array::for_each_in_bounded_vec(\\n        discovered_notes,\\n        |discovered_note: DiscoveredNoteInfo, _| {\\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\\n            // issue, and we should perhaps not have marked the tag index as taken.\\n            assert(\\n                deliver_note(\\n                    contract_address,\\n                    storage_slot,\\n                    discovered_note.nonce,\\n                    packed_note_content,\\n                    discovered_note.note_hash,\\n                    discovered_note.inner_nullifier,\\n                    tx_hash,\\n                    recipient,\\n                ),\\n                \\"Failed to deliver note\\",\\n            );\\n        },\\n    );\\n}\\n\\nunconstrained fn process_partial_note_private_log(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    recipient: AztecAddress,\\n) {\\n    // We store the information of the partial note we found so that we can later search for the public log that will\\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\\n    static_assert(\\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\\n        \\"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\\",\\n    );\\n\\n    let pending = DeliveredPendingPartialNote {\\n        note_completion_log_tag: log_payload.get(0),\\n        storage_slot,\\n        note_type_id,\\n        packed_private_note_content: array::subbvec(log_payload, 1),\\n        recipient,\\n    };\\n\\n    CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    )\\n        .push(pending);\\n}\\n"},"87":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::{Hash, ToField},\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"108":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr","source":"use super::utils::compute_fn_selector;\\nuse std::panic;\\n\\n/// Returns an `fn public_dispatch(...)` function for the given module that\'s assumed to be an Aztec contract.\\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\\n    let functions = m.functions();\\n    let functions =\\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\\"public\\"));\\n\\n    let unit = get_type::<()>();\\n\\n    let ifs = functions.map(|function: FunctionDefinition| {\\n        let name = function.name();\\n        let parameters = function.parameters();\\n        let return_type = function.return_type();\\n\\n        let selector: Field = compute_fn_selector(function);\\n\\n        let mut parameters_size = 0;\\n        for param in parameters {\\n            parameters_size += size_in_fields(param.1);\\n        }\\n\\n        let initial_read = if parameters.len() == 0 {\\n            quote {}\\n        } else {\\n            // The initial calldata_copy offset is 1 to skip the Field selector\\n            // The expected calldata is the serialization of\\n            // - FunctionSelector: the selector of the function intended to dispatch\\n            // - Parameters: the parameters of the function intended to dispatch\\n            // That is, exactly what is expected for a call to the target function,\\n            // but with a selector added at the beginning.\\n            quote {\\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\\n            }\\n        };\\n\\n        let parameter_index = &mut 0;\\n        let reads = parameters.map(|param: (Quoted, Type)| {\\n            let parameter_index_value = *parameter_index;\\n            let param_name = f\\"arg{parameter_index_value}\\".quoted_contents();\\n            let param_type = param.1;\\n            let read = quote {\\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\\n            };\\n            *parameter_index += 1;\\n            quote { $read }\\n        });\\n        let read = reads.join(quote { });\\n\\n        let mut args = &[];\\n        for parameter_index in 0..parameters.len() {\\n            let param_name = f\\"arg{parameter_index}\\".quoted_contents();\\n            args = args.push_back(quote { $param_name });\\n        }\\n\\n        let args = args.join(quote { , });\\n        let call = quote { $name($args) };\\n\\n        let return_code = if return_type == unit {\\n            quote {\\n                $call;\\n                // Force early return.\\n                dep::aztec::context::public_context::avm_return([]);\\n            }\\n        } else {\\n            quote {\\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\\n            }\\n        };\\n\\n        let if_ = quote {\\n            if selector == $selector {\\n                $initial_read\\n                $read\\n                $return_code\\n            }\\n        };\\n        if_\\n    });\\n\\n    if ifs.len() == 0 {\\n        // No dispatch function if there are no public functions\\n        quote {}\\n    } else {\\n        let ifs = ifs.push_back(quote { panic(f\\"Unknown selector {selector}\\") });\\n        let dispatch = ifs.join(quote {  });\\n\\n        let body = quote {\\n            // We mark this as public because our whole system depends on public\\n            // functions having this attribute. However, the public MACRO will\\n            // handle the public_dispatch function specially and do nothing.\\n            #[public]\\n            pub unconstrained fn public_dispatch(selector: Field) {\\n                $dispatch\\n            }\\n        };\\n\\n        body\\n    }\\n}\\n\\ncomptime fn size_in_fields(typ: Type) -> u32 {\\n    let size = array_size_in_fields(typ);\\n    let size = size.or_else(|| bool_size_in_fields(typ));\\n    let size = size.or_else(|| constant_size_in_fields(typ));\\n    let size = size.or_else(|| field_size_in_fields(typ));\\n    let size = size.or_else(|| int_size_in_fields(typ));\\n    let size = size.or_else(|| str_size_in_fields(typ));\\n    let size = size.or_else(|| struct_size_in_fields(typ));\\n    let size = size.or_else(|| tuple_size_in_fields(typ));\\n    if size.is_some() {\\n        size.unwrap()\\n    } else {\\n        panic(f\\"Can\'t determine size in fields of {typ}\\")\\n    }\\n}\\n\\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_array().and_then(|typ: (Type, Type)| {\\n        let (typ, element_size) = typ;\\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\\n    })\\n}\\n\\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_bool() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_field() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.as_integer().is_some() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_constant()\\n}\\n\\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_str().map(|typ| size_in_fields(typ))\\n}\\n\\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\\n        let struct_type = typ.0;\\n        let generics = typ.1;\\n        let mut size = 0;\\n        for field in struct_type.fields(generics) {\\n            size += size_in_fields(field.1);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_tuple().map(|types: [Type]| {\\n        let mut size = 0;\\n        for typ in types {\\n            size += size_in_fields(typ);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn get_type<T>() -> Type {\\n    let t: T = std::mem::zeroed();\\n    std::meta::type_of(t)\\n}\\n"},"115":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\\n    notes::NOTES,\\n    utils::{\\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\\n        module_has_storage,\\n    },\\n};\\nuse protocol_types::meta::generate_serialize_to_fields;\\nuse std::meta::type_of;\\n\\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\\n    // Private Kernel Circuit.\\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\\n    // about the execution context (e.g. the caller).\\n    let original_params = f.parameters();\\n    f.set_parameters(&[(\\n        quote { inputs },\\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\\n    )]\\n        .append(original_params));\\n\\n    let mut body = f.body().as_block().unwrap();\\n\\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we\'ve received\\n    // the correct values.\\n    // TODO: Optimize args_hasher for small number of arguments\\n    let args_hasher_name = quote { args_hasher };\\n    let args_hasher = original_params.fold(\\n        quote {\\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n        },\\n        |args_hasher, param: (Quoted, Type)| {\\n            let (name, typ) = param;\\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\\n            quote {\\n                $args_hasher\\n                $appended_arg\\n            }\\n        },\\n    );\\n\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\\n    // and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\\n    // circuit expects.\\n    let return_value_var_name = quote { macro__returned__values };\\n\\n    let return_value_type = f.return_type();\\n    let return_value = if body.len() == 0 {\\n        quote {}\\n    } else if return_value_type != type_of(()) {\\n        // The original return value is passed to a second args hasher which the context receives.\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        let return_value = last_body_expr.quoted();\\n        let return_value_assignment =\\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\\n        let return_hasher_name = quote { return_hasher };\\n        let return_value_into_hasher =\\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\\n\\n        body = body_without_return;\\n\\n        quote {\\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n            $return_value_assignment\\n            $return_value_into_hasher\\n            context.set_return_hash($return_hasher_name);\\n        }\\n    } else {\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        if !last_body_expr.has_semicolon()\\n            & last_body_expr.as_for().is_none()\\n            & last_body_expr.as_assert().is_none()\\n            & last_body_expr.as_for_range().is_none()\\n            & last_body_expr.as_assert_eq().is_none()\\n            & last_body_expr.as_let().is_none() {\\n            let unused_return_value_name = f\\"_{return_value_var_name}\\".quoted_contents();\\n            body = body_without_return.push_back(\\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\\n            );\\n        }\\n        quote {}\\n    };\\n\\n    let context_finish = quote { context.finish() };\\n\\n    let to_prepend = quote {\\n        $args_hasher\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n        $note_discovery_call\\n    };\\n\\n    let to_append = quote {\\n        $return_value\\n        $mark_as_initialized\\n        $context_finish\\n    };\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n    f.set_return_type(\\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\\n            .as_type(),\\n    );\\n    f.set_return_data();\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\\n    let original_params = f.parameters();\\n    let args_len = original_params\\n        .map(|(name, typ): (Quoted, Type)| {\\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\\n        })\\n        .fold(0, |acc: u32, val: u32| acc + val);\\n\\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\\n        // We start from 1 because we skip the selector for the dispatch function.\\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\\n        dep::aztec::hash::hash_args_array(serialized_args)\\n        });\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n        // referenced. We instead ignore \'unused variable\' warnings for it.\\n        quote {\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n    };\\n\\n    let to_append = quote {\\n        $mark_as_initialized\\n    };\\n\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n\\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\\n    // bytecode.\\n    f.set_unconstrained(true);\\n    f.set_return_public(true);\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\\n    // Top-level unconstrained fns are contract entrypoints, but they\'re not explicitly designated in any way. They\'re\\n    // the fallback case for a function that matches no other rules.\\n    // TODO(#12743): improve this\\n\\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\\n    // public, but which *are* contract entrypoints (i.e. they\'re not opting out via the #[test] or\\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\\n        !is_fn_private(f)\\n            & !is_fn_public(f)\\n            & !f.has_named_attribute(\\"contract_library_method\\")\\n            & !f.has_named_attribute(\\"test\\")\\n    });\\n\\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\\n    // https://github.com/noir-lang/noir/issues/7714). We can\'t simply print a message since that\'d otherwise break the\\n    // output of utils such as `nargo test --list-tests`.\\n    // // We don\'t expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr\'s\\n    // // #[private] macro, possibly resulting in a non-standard interface).\\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n    //     !f.is_unconstrained()\\n    // }) {\\n    //     let name = f.name();\\n    //     warn(\\n    //         f\\"found private contract function \'{name}\' which does not have the #[private] attribute - make sure you know what you\'re doing!\\",\\n    //     );\\n    // }\\n\\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n        f.is_unconstrained()\\n    }) {\\n        transform_top_level_unconstrained(f);\\n    }\\n}\\n\\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $storage_init\\n        $note_discovery_call\\n    };\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\\n    f.set_return_public(true);\\n    f.set_body(modified_body);\\n}\\n\\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called internally\\";\\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\\n}\\n\\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called statically\\";\\n    if is_fn_private(f) {\\n        // Here `context` is of type context::PrivateContext\\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\\n    } else {\\n        // Here `context` is of type context::PublicContext\\n        quote { assert(context.is_static_call(), $assertion_message); }\\n    }\\n}\\n\\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\\n/// available for the current execution.\\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\\n    quote {\\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\\n        /// safe to call.\\n        unsafe {\\n            dep::aztec::discovery::discover_new_notes(\\n                context.this_address(),\\n                _compute_note_hash_and_nullifier,\\n            );\\n        };\\n    }\\n}\\n"},"116":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/mod.nr","source":"pub mod dispatch;\\npub mod functions;\\npub mod utils;\\npub mod notes;\\npub mod storage;\\npub mod events;\\n\\nuse functions::{\\n    stub_registry,\\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\\n};\\nuse notes::{generate_note_export, NOTES};\\nuse storage::STORAGE_LAYOUT_NAME;\\n\\nuse dispatch::generate_public_dispatch;\\nuse utils::{get_trait_impl_method, module_has_storage};\\n\\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\\n\\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\\npub comptime fn aztec(m: Module) -> Quoted {\\n    let interface = generate_contract_interface(m);\\n\\n    find_and_transform_top_level_unconstrained_fns(m);\\n\\n    let contract_library_method_compute_note_hash_and_nullifier =\\n        generate_contract_library_method_compute_note_hash_and_nullifier();\\n    let process_log = generate_process_log();\\n    let note_exports = generate_note_exports();\\n    let public_dispatch = generate_public_dispatch(m);\\n    let sync_notes = generate_sync_notes();\\n\\n    quote {\\n        $note_exports\\n        $interface\\n        $contract_library_method_compute_note_hash_and_nullifier\\n        $process_log\\n        $public_dispatch\\n        $sync_notes\\n    }\\n}\\n\\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\\n    let module_name = m.name();\\n    let contract_stubs = stub_registry::get(m);\\n    let fn_stubs_quote = if contract_stubs.is_some() {\\n        contract_stubs.unwrap().join(quote {})\\n    } else {\\n        quote {}\\n    };\\n\\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\\n    let storage_layout_getter = if has_storage_layout {\\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\\n        quote {\\n            pub fn storage_layout() -> StorageLayoutFields {\\n                $storage_layout_name.fields\\n            }\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    let library_storage_layout_getter = if has_storage_layout {\\n        quote {\\n            #[contract_library_method]\\n            $storage_layout_getter\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    quote {\\n        pub struct $module_name {\\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\\n        }\\n\\n        impl $module_name {\\n            $fn_stubs_quote\\n\\n            pub fn at(\\n                addr: aztec::protocol_types::address::AztecAddress\\n            ) -> Self {\\n                Self { target_contract: addr }\\n            }\\n\\n            pub fn interface() -> Self {\\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n            }\\n\\n            $storage_layout_getter\\n        }\\n\\n        #[contract_library_method]\\n        pub fn at(\\n            addr: aztec::protocol_types::address::AztecAddress\\n        ) -> $module_name {\\n            $module_name { target_contract: addr }\\n        }\\n\\n        #[contract_library_method]\\n        pub fn interface() -> $module_name {\\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n        }\\n\\n        $library_storage_layout_getter\\n\\n    }\\n}\\n\\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        let max_note_packed_len = notes.fold(\\n            0,\\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\\n                if len > acc {\\n                    len\\n                } else {\\n                    acc\\n                }\\n            },\\n        );\\n\\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\\n            panic(\\n                f\\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\\",\\n            );\\n        }\\n\\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\\n\\n        let mut if_note_type_id_match_statements_list = &[];\\n        for i in 0..notes.len() {\\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\\n\\n            let get_note_type_id = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteType },\\n                quote { get_id },\\n            );\\n            let unpack = get_trait_impl_method(\\n                typ,\\n                quote { crate::protocol_types::traits::Packable<_> },\\n                quote { unpack },\\n            );\\n\\n            let compute_note_hash = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_note_hash },\\n            );\\n\\n            let compute_nullifier_unconstrained = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_nullifier_unconstrained },\\n            );\\n\\n            let if_or_else_if = if i == 0 {\\n                quote { if }\\n            } else {\\n                quote { else if }\\n            };\\n\\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\\n                quote {\\n                    $if_or_else_if note_type_id == $get_note_type_id() {\\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\\n                        // length, since we\'re about to interpret it\'s raw storage as a fixed-size array by calling the\\n                        // unpack function on it.\\n                        let expected_len = $packed_note_length;\\n                        let actual_len = packed_note.len();\\n                        assert(\\n                            actual_len == expected_len,\\n                            f\\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\\"\\n                        );\\n\\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n\\n                        let note_hash = $compute_note_hash(note, storage_slot);\\n    \\n                        // The note discovery process finds settled notes, that is, notes that were created in prior\\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n                            aztec::note::retrieved_note::RetrievedNote{ \\n                                note, \\n                                contract_address, \\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \\n                            }, \\n                            storage_slot,\\n                        );\\n\\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\\n\\n                        Option::some(\\n                            aztec::discovery::NoteHashAndNullifier {\\n                                note_hash, inner_nullifier\\n                            }\\n                        )\\n                    }\\n                },\\n            );\\n        }\\n\\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\\n\\n        quote {\\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\\n            /// tree with `nonce`.\\n            ///\\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\\n            /// and `attempt_note_discovery`.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                storage_slot: Field,\\n                note_type_id: Field,\\n                contract_address: aztec::protocol_types::address::AztecAddress,\\n                nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                $if_note_type_id_match_statements\\n                else {\\n                    Option::none()\\n                }\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            /// This contract does not use private notes, so this function should never be called as it will\\n            /// unconditionally fail.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                _storage_slot: Field,\\n                _note_type_id: Field,\\n                _contract_address: aztec::protocol_types::address::AztecAddress,\\n                _nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_process_log() -> Quoted {\\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\\n    // and perform note discovery of either private notes or partial notes.\\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\\n    // that function.\\n\\n    // We\'ll produce the entire body of the function in one go and then insert it into the function.\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        quote {\\n            unconstrained fn process_log(\\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                tx_hash: Field,\\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                first_nullifier_in_tx: Field,\\n                recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n                // unconstrained execution context since it will not be available otherwise.\\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n                // TODO(#10727): allow other contracts to process logs and deliver notes\\n                let contract_address = context.this_address();\\n\\n                aztec::discovery::private_logs::do_process_log(\\n                    contract_address,\\n                    log_ciphertext,\\n                    tx_hash,\\n                    unique_note_hashes_in_tx,\\n                    first_nullifier_in_tx,\\n                    recipient,\\n                    _compute_note_hash_and_nullifier,\\n                );\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            unconstrained fn process_log(\\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                _tx_hash: Field,\\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                _first_nullifier_in_tx: Field,\\n                _recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_note_exports() -> Quoted {\\n    let notes = NOTES.values();\\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it\'s only used when\\n    // generating partial note helper functions.\\n    notes\\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\\n            generate_note_export(s, note_type_id, fields)\\n        })\\n        .join(quote {})\\n}\\n\\ncomptime fn generate_sync_notes() -> Quoted {\\n    let note_discovery_call = create_note_discovery_call();\\n    quote {\\n        unconstrained fn sync_notes() {\\n            // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n            // unconstrained execution context since it will not be available otherwise.\\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n            $note_discovery_call\\n        }\\n    }\\n}\\n"},"137":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\\n/// data was already stored at this slot, it is overwritten.\\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\\nwhere\\n    T: Serialize<N>,\\n{\\n    let serialized = value.serialize();\\n    store_oracle(contract_address, slot, serialized);\\n}\\n\\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\\n/// nothing was stored at the given slot.\\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\\nwhere\\n    T: Deserialize<N>,\\n{\\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\\n}\\n\\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\\n    delete_oracle(contract_address, slot);\\n}\\n\\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\\npub unconstrained fn copy(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {\\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\\n}\\n\\n#[oracle(storeCapsule)]\\nunconstrained fn store_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    values: [Field; N],\\n) {}\\n\\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\\n/// have.\\n///\\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\\n#[oracle(loadCapsule)]\\nunconstrained fn load_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    array_len: u32,\\n) -> Option<[Field; N]> {}\\n\\n#[oracle(deleteCapsule)]\\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\\n\\n#[oracle(copyCapsule)]\\nunconstrained fn copy_oracle(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {}\\n\\nmod test {\\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\\n    // oracles are hooked up correctly.\\n\\n    use crate::{\\n        oracle::capsules::{copy, delete, load, store},\\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\\n    };\\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        let env = TestEnvironment::new();\\n        env.contract_address()\\n    }\\n\\n    global SLOT: Field = 1;\\n\\n    #[test]\\n    unconstrained fn stores_and_loads() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\\n    }\\n\\n    #[test]\\n    unconstrained fn store_overwrites() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        let new_value = MockStruct::new(7, 8);\\n        store(contract_address, SLOT, new_value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\\n    }\\n\\n    #[test]\\n    unconstrained fn loads_empty_slot() {\\n        let contract_address = setup();\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_stored_value() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n        delete(contract_address, SLOT);\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_empty_slot() {\\n        let contract_address = setup();\\n\\n        delete(contract_address, SLOT);\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_non_overlapping_values() {\\n        let contract_address = setup();\\n\\n        let src = 5;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 10;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 1;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 2;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 2;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 1;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\\n    }\\n\\n    #[test(should_fail_with = \\"copy empty slot\\")]\\n    unconstrained fn cannot_copy_empty_values() {\\n        let contract_address = setup();\\n\\n        copy(contract_address, SLOT, SLOT, 1);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_store_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let value = MockStruct::new(5, 6);\\n        store(other_contract_address, SLOT, value);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_load_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_delete_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        delete(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_copy_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        copy(other_contract_address, SLOT, SLOT, 0);\\n    }\\n}\\n"},"138":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"139":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"140":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"150":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr","source":"use crate::discovery::MAX_NOTE_PACKED_LEN;\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\\n};\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\\n/// available for later querying via the `get_notes` oracle.\\npub unconstrained fn sync_notes() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n\\n/// Informs PXE of a note\'s existence so that it can later be retrieved by the `getNotes` oracle. The note will be\\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\\n///\\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\\n///\\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\\n/// other accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized.\\n///\\n/// Returns true if the note was successfully delivered and added to PXE\'s database.\\npub unconstrained fn deliver_note(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {\\n    deliver_note_oracle(\\n        contract_address,\\n        storage_slot,\\n        nonce,\\n        packed_note,\\n        note_hash,\\n        nullifier,\\n        tx_hash,\\n        recipient,\\n    )\\n}\\n\\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\\n/// is the data required in order to discover notes that are being delivered in a log.\\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\\n// log.\\npub struct LogWithTxData {\\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\\n    pub tx_hash: Field,\\n    /// The array of new note hashes created by `tx_hash`\\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    /// The first nullifier created by `tx_hash`\\n    pub first_nullifier_in_tx: Field,\\n}\\n\\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\\n/// the tag is the first field in the log\'s content. Returns `Option::none` if no such log exists. Throws if more than\\n/// one log with that tag exists.\\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\\n// TODO(#11627): handle multiple logs with the same tag.\\n// TODO(#10273): improve contract siloing of logs, don\'t introduce an extra field.\\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\\n    get_log_by_tag_oracle(tag)\\n}\\n\\n#[oracle(deliverNote)]\\nunconstrained fn deliver_note_oracle(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {}\\n\\n#[oracle(getLogByTag)]\\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\\n"},"178":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\\n/// large enough to fit all of the elements of both the first and second vectors.\\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\\n    a: BoundedVec<T, A_LEN>,\\n    b: BoundedVec<T, B_LEN>,\\n) -> BoundedVec<T, DST_LEN> {\\n    let mut dst = BoundedVec::new();\\n\\n    dst.extend_from_bounded_vec(a);\\n    dst.extend_from_bounded_vec(b);\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::append;\\n\\n    #[test]\\n    unconstrained fn append_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::new();\\n        let b: BoundedVec<_, 14> = BoundedVec::new();\\n\\n        let result: BoundedVec<Field, 5> = append(a, b);\\n\\n        assert_eq(result.len(), 0);\\n        assert_eq(result.storage(), std::mem::zeroed());\\n    }\\n\\n    #[test]\\n    unconstrained fn append_non_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let result: BoundedVec<Field, 8> = append(a, b);\\n\\n        assert_eq(result.len(), 6);\\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\\n    }\\n\\n    #[test(should_fail_with = \\"out of bounds\\")]\\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let _: BoundedVec<Field, 5> = append(a, b);\\n    }\\n}\\n"},"180":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr","source":"pub mod append;\\npub mod collapse;\\npub mod subarray;\\npub mod subbvec;\\n\\npub use append::append;\\npub use collapse::collapse;\\npub use subarray::subarray;\\npub use subbvec::subbvec;\\n\\n// This will eventually be replaced by `BoundedVec::for_each`, once that\'s implemented.\\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\\n    vec: BoundedVec<T, MaxLen>,\\n    f: fn[Env](T, u32) -> (),\\n) {\\n    for i in 0..vec.len() {\\n        f(vec.get_unchecked(i), i);\\n    }\\n}\\n"},"181":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"182":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\\n\\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\\n/// zeroed elements past `len()`).\\n///\\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n///\\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can\'t return just 1 element since 3 remain\\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can\'t return 10 elements since only 7 remain\\n/// ```\\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\\n    offset: u32,\\n) -> BoundedVec<T, DST_MAX_LEN> {\\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\\n    // because we\'re constructing the new storage array as a subarray of the original one (which should have zeroed\\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\\n    // their original length.\\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\\n}\\n\\nmod test {\\n    use super::subbvec;\\n\\n    #[test]\\n    unconstrained fn subbvec_empty() {\\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_complete() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n\\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_partial() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_into_empty() {\\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_offset_past_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_insufficient_dst_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // We\'re not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\\n        // for the capacity to reduce, but not the length (other than by len - offset).\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // subbvec does not supprt capacity increases\\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // This effectively requests a capacity increase, since there\'d be just one element plus the 5 empty slots,\\n        // which is less than 7.\\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\\n    }\\n}\\n"},"183":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/comparison.nr","source":"struct ComparatorEnum {\\n    pub EQ: u8,\\n    pub NEQ: u8,\\n    pub LT: u8,\\n    pub LTE: u8,\\n    pub GT: u8,\\n    pub GTE: u8,\\n}\\n\\npub global Comparator: ComparatorEnum =\\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\\n\\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\\n    // Values are computed ahead of time because circuits evaluate all branches\\n    let is_equal = lhs == rhs;\\n    let is_lt = lhs.lt(rhs);\\n\\n    if (operation == Comparator.EQ) {\\n        is_equal\\n    } else if (operation == Comparator.NEQ) {\\n        !is_equal\\n    } else if (operation == Comparator.LT) {\\n        is_lt\\n    } else if (operation == Comparator.LTE) {\\n        is_lt | is_equal\\n    } else if (operation == Comparator.GT) {\\n        !is_lt & !is_equal\\n    } else if (operation == Comparator.GTE) {\\n        !is_lt\\n    } else {\\n        panic(f\\"Invalid operation\\")\\n    }\\n}\\n\\nmod test {\\n    use super::Comparator;\\n    use super::compare;\\n\\n    #[test]\\n    unconstrained fn test_compare() {\\n        let lhs = 10;\\n        let rhs = 10;\\n        assert(compare(lhs, Comparator.EQ, rhs), \\"Expected lhs to be equal to rhs\\");\\n\\n        let lhs = 10;\\n        let rhs = 11;\\n        assert(compare(lhs, Comparator.NEQ, rhs), \\"Expected lhs to be not equal to rhs\\");\\n\\n        let lhs = 10;\\n        let rhs = 11;\\n        assert(compare(lhs, Comparator.LT, rhs), \\"Expected lhs to be less than rhs\\");\\n\\n        let lhs = 10;\\n        let rhs = 10;\\n        assert(compare(lhs, Comparator.LTE, rhs), \\"Expected lhs to be less than or equal to rhs\\");\\n\\n        let lhs = 11;\\n        let rhs = 10;\\n        assert(compare(lhs, Comparator.GT, rhs), \\"Expected lhs to be greater than rhs\\");\\n\\n        let lhs = 10;\\n        let rhs = 10;\\n        assert(\\n            compare(lhs, Comparator.GTE, rhs),\\n            \\"Expected lhs to be greater than or equal to rhs\\",\\n        );\\n\\n        let lhs = 11;\\n        let rhs = 10;\\n        assert(\\n            compare(lhs, Comparator.GTE, rhs),\\n            \\"Expected lhs to be greater than or equal to rhs\\",\\n        );\\n\\n        let lhs = 10;\\n        let rhs = 11;\\n        assert(!compare(lhs, Comparator.EQ, rhs), \\"Expected lhs to be not equal to rhs\\");\\n\\n        let lhs = 10;\\n        let rhs = 10;\\n        assert(!compare(lhs, Comparator.NEQ, rhs), \\"Expected lhs to not be not equal to rhs\\");\\n\\n        let lhs = 11;\\n        let rhs = 10;\\n        assert(!compare(lhs, Comparator.LT, rhs), \\"Expected lhs to not be less than rhs\\");\\n\\n        let lhs = 11;\\n        let rhs = 10;\\n        assert(\\n            !compare(lhs, Comparator.LTE, rhs),\\n            \\"Expected lhs to not be less than or equal to rhs\\",\\n        );\\n\\n        let lhs = 10;\\n        let rhs = 10;\\n        assert(!compare(lhs, Comparator.GT, rhs), \\"Expected lhs to not be greater than rhs\\");\\n\\n        let lhs = 10;\\n        let rhs = 11;\\n        assert(\\n            !compare(lhs, Comparator.GTE, rhs),\\n            \\"Expected lhs to not be greater than or equal to rhs\\",\\n        );\\n\\n        let lhs = 10;\\n        let rhs = 11;\\n        assert(\\n            !compare(lhs, Comparator.GTE, rhs),\\n            \\"Expected lhs to not be greater than or equal to rhs\\",\\n        );\\n    }\\n}\\n"},"271":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"272":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        contract_class_log::ContractClassLog,\\n        function_selector::FunctionSelector,\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, ToField},\\n    utils::{\\n        arrays::{array_concat, unsafe_padded_array_length},\\n        field::{field_from_bytes, field_from_bytes_32_trunc},\\n    },\\n};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_field(\\n    contract_address: AztecAddress,\\n    first_field: Field,\\n) -> Field {\\n    poseidon2_hash([contract_address.to_field(), first_field])\\n}\\n\\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\\n    if contract_class_log.contract_address.is_zero() {\\n        contract_class_log\\n    } else {\\n        let mut log = contract_class_log;\\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\\n            contract_class_log.contract_address,\\n            log.log.fields[0],\\n        );\\n        log\\n    }\\n}\\n\\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\\n    let array = contract_class_log.log.fields;\\n    // Safety: The below length is constrained in the base rollup.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    if length == 0 {\\n        0\\n    } else {\\n        poseidon2_hash(array)\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a u128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"286":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use super::traits::{Deserialize, Packable, Serialize};\\n\\n/// Returns the typed expression of a trait method implementation.\\n///\\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\\n/// warnings that the trait implementation is not in scope).\\n///\\n/// # Note\\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\\ncomptime fn get_trait_impl_method(\\n    typ: Type,\\n    target_trait: Quoted,\\n    target_method: Quoted,\\n) -> TypedExpr {\\n    let trait_constraint = target_trait.as_trait_constraint();\\n    typ\\n        .get_trait_impl(trait_constraint)\\n        .expect(f\\"Could not find impl for {target_trait} for type {typ}\\")\\n        .methods()\\n        .filter(|m| m.name() == target_method)[0]\\n        .as_typed_expr()\\n}\\n\\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\\n///\\n/// # Parameters\\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\\"values\\"`).\\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\\n/// and `Serialize` trait for more information about the difference between packing and serialization).\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\\n///\\n/// # Nested Struct Example\\n/// Given the following setup:\\n/// ```\\n/// struct UintNote {\\n///     value: u128,\\n///     owner: AztecAddress,\\n///     randomness: Field,\\n/// }\\n///\\n/// struct AztecAddress {\\n///     inner: Field,\\n/// }\\n/// ```\\n///\\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\\n/// ```\\n/// UintNote {\\n///     value: fields[0] as u128,\\n///     owner: AztecAddress {\\n///         inner: fields[1],\\n///     },\\n///     randomness: fields[2],\\n/// }\\n/// ```\\n/// # Nested Struct Example with Unpacking\\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\\n///   the result we get is:\\n/// ```\\n/// UintNote {\\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\\n/// }\\n/// ```\\n///\\n/// # Panics\\n/// - If the deserialization logic encounters a type it does not support.\\n/// - If an incorrect number of fields are consumed when deserializing a string.\\npub comptime fn generate_deserialize_from_fields(\\n    name: Quoted,\\n    typ: Type,\\n    field_array_name: Quoted,\\n    num_already_consumed: u32,\\n    should_unpack: bool,\\n) -> (Quoted, u32) {\\n    let mut result = quote {};\\n    // Counter for the number of fields consumed\\n    let mut consumed_counter: u32 = 0;\\n\\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n    if (should_unpack & typ.implements(packable_constraint)) {\\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\\n        let mut packed_fields_quotes = &[];\\n        for i in 0..packed_len {\\n            let index_in_field_array = i + num_already_consumed;\\n            packed_fields_quotes =\\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\\n        }\\n        let packed_fields = packed_fields_quotes.join(quote {,});\\n\\n        // Now we call unpack on the type\\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\\n        result = quote { $unpack_method([ $packed_fields ]) };\\n\\n        consumed_counter = packed_len;\\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\\n        // The field is a primitive so we just reference it in the field array\\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\\n        consumed_counter = 1;\\n    } else if typ.as_data_type().is_some() {\\n        // The field is a struct so we iterate over each struct field and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (nested_def, generics) = typ.as_data_type().unwrap();\\n        let nested_name = nested_def.name();\\n        let mut deserialized_fields_list = &[];\\n\\n        // Iterate over each field in the struct\\n        for field in nested_def.fields(generics) {\\n            let (field_name, field_type) = field;\\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                field_name,\\n                field_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\\n            deserialized_fields_list =\\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\\n        }\\n\\n        // We can construct the struct from the deserialized fields\\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\\n        result = quote {\\n                $nested_name {\\n                    $deserialized_fields\\n                }\\n            };\\n    } else if typ.as_array().is_some() {\\n        // The field is an array so we iterate over each element and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (element_type, array_len) = typ.as_array().unwrap();\\n        let array_len = array_len.as_constant().unwrap();\\n        let mut array_fields_list = &[];\\n\\n        // Iterate over each element in the array\\n        for _ in 0..array_len {\\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                element_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            array_fields_list = array_fields_list.push_back(deserialized_field);\\n        }\\n\\n        // We can construct the array from the deserialized fields\\n        let array_fields = array_fields_list.join(quote {,});\\n        result = quote { [ $array_fields ] };\\n    } else if typ.as_str().is_some() {\\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\\n        // to `generate_deserialize_from_fields`.\\n        let length_type = typ.as_str().unwrap();\\n        let str_len = length_type.as_constant().unwrap();\\n        let mut byte_list = &[];\\n\\n        // Iterate over each character in the string\\n        for _ in 0..str_len {\\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                quote {u8}.as_type(),\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n\\n            // We should consume just one field in the recursion so we sanity check that\\n            assert_eq(\\n                num_consumed_in_recursion,\\n                1,\\n                \\"Incorrect number of fields consumed in string deserialization\\",\\n            );\\n\\n            // We increment the consumed counter by 1 as we have consumed one field\\n            consumed_counter += 1;\\n\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `fields[6] as u8`\\n            byte_list = byte_list.push_back(deserialized_field);\\n        }\\n\\n        // We construct the string from the deserialized fields\\n        let bytes = byte_list.join(quote {,});\\n        result = quote { [ $bytes ].as_str_unchecked() };\\n    } else {\\n        panic(\\n            f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n        )\\n    }\\n\\n    (result, consumed_counter)\\n}\\n\\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\\n/// if it does.\\n///\\n/// # Parameters\\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\\n/// - `should_pack`: A boolean indicating whether the type should be packed.\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - A flattened array of `Quoted` field references representing the serialized fields.\\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\\n///\\n/// # Examples\\n///\\n/// ## Struct\\n/// Given the following struct:\\n/// ```rust\\n/// struct MockStruct {\\n///     a: Field,\\n///     b: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing the struct:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\\n/// // Returns:\\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\\n/// ```\\n///\\n/// ## Nested Struct\\n/// For a more complex struct:\\n/// ```rust\\n/// struct NestedStruct {\\n///     m1: MockStruct,\\n///     m2: MockStruct,\\n/// }\\n/// ```\\n///\\n/// Serialization output:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\\n/// // Returns:\\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\\n/// ```\\n///\\n/// ## Array\\n/// For an array type:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\\n/// // Returns:\\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\\n/// ```\\n///\\n/// ## String\\n/// For a string field, where each character is serialized as a `Field`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\\n/// // Returns:\\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\\n/// ```\\n///\\n/// ## Nested Struct with Omitted Field and packing enabled\\n/// - u128 has a `Packable` implementation hence it will be packed.\\n///\\n/// For a more complex struct:\\n/// ```rust\\n/// struct MyStruct {\\n///     value: u128,\\n///     value2: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing while omitting `value2`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\\n/// // Returns:\\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\\n/// ```\\n///\\n/// # Panics\\n/// - If the type is unsupported for serialization.\\n/// - If the provided `typ` contains invalid constants or incompatible structures.\\npub comptime fn generate_serialize_to_fields(\\n    name: Quoted,\\n    typ: Type,\\n    omit: [Quoted],\\n    should_pack: bool,\\n) -> ([Quoted], [Quoted]) {\\n    let mut fields = &[];\\n    let mut aux_vars = &[];\\n\\n    // Proceed if none of the omit rules omits this name\\n    if !omit.any(|to_omit| to_omit == name) {\\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n        let packable_constraint =\\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n        if (should_pack & typ.implements(packable_constraint)) {\\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \\"self.value\\" -> \\"self_value\\").\\n            let name_at_one_token = collapse_to_one_token(name);\\n            let packed_struct_name = f\\"{name_at_one_token}_aux_var\\".quoted_contents();\\n\\n            // We add the individual fields to the fields array\\n            let pack_method = get_trait_impl_method(\\n                typ,\\n                quote { crate::traits::Packable<$packed_len> },\\n                quote { pack },\\n            );\\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\\n            for i in 0..packed_len {\\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\\n            }\\n\\n            // We add the new auxiliary variable to the aux_vars array\\n            aux_vars = aux_vars.push_back(packed_struct);\\n        } else if typ.is_field() {\\n            // For field we just add the value to fields\\n            fields = fields.push_back(name);\\n        } else if typ.as_integer().is_some() | typ.is_bool() {\\n            // For integer and bool we just cast to Field and add the value to fields\\n            fields = fields.push_back(quote { $name as Field });\\n        } else if typ.as_data_type().is_some() {\\n            // For struct we pref\\n            let nested_struct = typ.as_data_type().unwrap();\\n            let params = nested_struct.0.fields(nested_struct.1);\\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\\n                let maybe_prefixed_name = if name == quote {} {\\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\\n                    // argument) --> then we don\'t prefix the name with anything.\\n                    param_name\\n                } else {\\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\\n                    // can typically be `self` when implementing a method on a struct.\\n                    quote { $name.$param_name }\\n                };\\n                generate_serialize_to_fields(\\n                    quote {$maybe_prefixed_name},\\n                    param_type,\\n                    omit,\\n                    should_pack,\\n                )\\n            });\\n            let struct_flattened_fields = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\\n            );\\n            let struct_flattened_aux_vars = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\\n            );\\n            fields = fields.append(struct_flattened_fields);\\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\\n        } else if typ.as_array().is_some() {\\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\\n            let (element_type, array_len) = typ.as_array().unwrap();\\n            let array_len = array_len.as_constant().unwrap();\\n            for i in 0..array_len {\\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\\n                    quote { $name[$i] },\\n                    element_type,\\n                    omit,\\n                    should_pack,\\n                );\\n                fields = fields.append(element_fields);\\n                aux_vars = aux_vars.append(element_aux_vars);\\n            }\\n        } else if typ.as_str().is_some() {\\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\\n            // then we add each byte to fields as a Field\\n            let length_type = typ.as_str().unwrap();\\n            let str_len = length_type.as_constant().unwrap();\\n            let as_member = name.as_expr().unwrap().as_member_access();\\n            let var_name = if as_member.is_some() {\\n                as_member.unwrap().1\\n            } else {\\n                name\\n            };\\n            let as_bytes_name = f\\"{var_name}_as_bytes\\".quoted_contents();\\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\\n            for i in 0..str_len {\\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\\n            }\\n            aux_vars = aux_vars.push_back(as_bytes);\\n        } else {\\n            panic(\\n                f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n            )\\n        }\\n    }\\n    (fields, aux_vars)\\n}\\n\\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\\n/// E.g. \\"self.values[0]\\" -> \\"self_values_0_\\"\\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\\n    let tokens = q.tokens();\\n\\n    let mut single_token = quote {};\\n    for token in tokens {\\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\\n            quote {_}\\n        } else {\\n            token\\n        };\\n        single_token = f\\"{single_token}{new_token}\\".quoted_contents();\\n    }\\n    single_token\\n}\\n\\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let field_serializations = fields.join(quote {,});\\n    let serialized_len = fields.len();\\n    quote {\\n        impl Serialize<$serialized_len> for $typ {\\n            fn serialize(self) -> [Field; $serialized_len] {\\n                $aux_vars_for_serialization\\n                [ $field_serializations ]\\n            }\\n        }\\n    }\\n}\\n\\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let serialized_len = fields.len();\\n    let (deserialized, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\\n    quote {\\n        impl Deserialize<$serialized_len> for $typ {\\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\\n                $deserialized\\n            }\\n        }\\n    }\\n}\\n\\n/// Generates `Packable` implementation for a given struct and returns the packed length.\\n///\\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\\n    let packing_enabled = true;\\n\\n    let typ = s.as_type();\\n    let (fields, aux_vars) =\\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let (unpacked, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\\n\\n    let field_packings = fields.join(quote {,});\\n    let packed_len = fields.len();\\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\\n    (\\n        quote {\\n        impl $packable_trait for $typ {\\n            fn pack(self) -> [Field; $packed_len] {\\n                $aux_vars_for_packing\\n                [ $field_packings ]\\n            }\\n\\n            fn unpack(packed: [Field; $packed_len]) -> Self {\\n                $unpacked\\n            }\\n        }\\n    },\\n        packed_len,\\n    )\\n}\\n\\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\\n    packable_impl\\n}\\n\\n#[derive(Packable, Serialize, Deserialize, Eq)]\\npub struct Smol {\\n    a: Field,\\n    b: Field,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct HasArray {\\n    a: [Field; 2],\\n    b: bool,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct Fancier {\\n    a: Smol,\\n    b: [Field; 2],\\n    c: [u8; 3],\\n    d: str<16>,\\n}\\n\\nfn main() {\\n    assert(false);\\n}\\n\\n#[test]\\nfn smol_test() {\\n    let smol = Smol { a: 1, b: 2 };\\n    let serialized = smol.serialize();\\n    assert(serialized == [1, 2], serialized);\\n    let deserialized = Smol::deserialize(serialized);\\n    assert(deserialized == smol);\\n\\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\\n    let packed = smol.pack();\\n    assert_eq(packed, serialized, \\"Packed does not match serialized\\");\\n}\\n\\n#[test]\\nfn has_array_test() {\\n    let has_array = HasArray { a: [1, 2], b: true };\\n    let serialized = has_array.serialize();\\n    assert(serialized == [1, 2, 1], serialized);\\n    let deserialized = HasArray::deserialize(serialized);\\n    assert(deserialized == has_array);\\n}\\n\\n#[test]\\nfn fancier_test() {\\n    let fancier =\\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \\"metaprogramming!\\" };\\n    let serialized = fancier.serialize();\\n    assert(\\n        serialized\\n            == [\\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\\n            ],\\n        serialized,\\n    );\\n    let deserialized = Fancier::deserialize(serialized);\\n    assert(deserialized == fancier);\\n}\\n"},"289":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"328":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 1;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"344":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\\n// is not found, the function returns N as the index.\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays where validate_array(array) returns true,\\n// which ensures that:\\n// 1. All elements before the first empty element are non-empty\\n// 2. All elements after and including the first empty element are empty\\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // We get the length by checking the index of the first empty element.\\n\\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\\n    // of the element and non-emptiness of the previous element is checked below.\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\\n/// if this is not the case then elements from the end of `array2` will be dropped.\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: we constrain this array below\\n    let result = unsafe { array_merge_helper(array1, array2) };\\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\\n    let array1_len = array_length(array1);\\n    let mut add_from_left = true;\\n    for i in 0..N {\\n        add_from_left &= i != array1_len;\\n        if add_from_left {\\n            assert_eq(result[i], array1[i]);\\n        } else {\\n            assert_eq(result[i], array2[i - array1_len]);\\n        }\\n    }\\n    result\\n}\\n\\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n// Helper function to find the index of the last element in an array, allowing empty elements.\\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut index = N;\\n    for i in 0..N {\\n        let j = N - i - 1;\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & !is_empty(array[j]) {\\n            index = j;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which returns the length of an array right padded by empty elements\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\n// See smoke_validate_array_trailing for examples.\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let index = find_last_value_index(array);\\n    if index == N {\\n        0\\n    } else {\\n        index + 1\\n    }\\n}\\n\\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: this value is constrained in the below loop.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    // Check the elt just before length is non-zero:\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]), \\"invalid right padded array\\");\\n    }\\n    // Check all beyond length are zero:\\n    let mut check_zero = false;\\n    for i in 0..N {\\n        check_zero |= i == length;\\n        if check_zero {\\n            assert(is_empty(array[i]), \\"invalid right padded array\\");\\n        }\\n    }\\n    length\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test]\\nfn smoke_validate_array_trailing() {\\n    let valid_array: [Field; 0] = [];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(padded_array_length(valid_array) == 1);\\n\\n    let valid_array = [1, 0, 3];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 0, 3, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [0, 0, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nunconstrained fn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nunconstrained fn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concatenated = array_concat(array0, array1);\\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"347":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"}}'),r={transpiled:!0,noir_version:e,name:n,functions:t,outputs:s,file_map:a};export{r as default,a as file_map,t as functions,n as name,e as noir_version,s as outputs,i as transpiled};
