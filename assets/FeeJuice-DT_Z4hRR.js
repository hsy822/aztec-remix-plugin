const i=!0,e="1.0.0-beta.3+0000000000000000000000000000000000000000",n="FeeJuice",t=JSON.parse(`[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"_log_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"_unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/+Wc6XLbNhDHKZu0TcmyZPmK3Svp3bRpKYnU0dNt0/u+lM+KYz8HHyPta7Rf2qer/jFXWsHojDteTPxPMMOhpYV2f1wuARBYuBadl8nsqFV/x9V5vTrj+060XKTucXXOrla6hrqyUIw1AsYVAsZVAsaYgDEhYFwjYFwnYNwgYEwJGOsEjA0Cxk0CxiYB4xYBY4uAsU3AuB2AMQRnh4Rzx5BTj+1D8e5G1z9G9wgY9wkYDwgYbxAwHhIwHhEwPkPA+CwB43MEjM8TML5AwHiTgPEWAeOLBIwvETC+TMD4CgHjqwSMrxEwvk7A+AYB420CxjcJGN8iYLxDwPg2AeM7BIwZAWOXgLFHwNgnYMwJGAsCxgEB45CAcUTAOCZgfJeA8T0CxvcJGD8gYPyQgPEjAsZjAsaPCRg/IWD8lIDxLgHjZwSMnxMwfkHA+CUB41cEjF8TMH5DwPgtAeN3BIzfEzD+QMD4IwHjTwSMPxMw/hKAMQTnryScv5FwTgJxRvcc6JXZgY1b2BiFjUfY2IONM9iYgo0f2FiBjQvYGIDEeyS2I3G8PTuQ+IykYiTsIgkWSaZI4kSSJJIQkeSHJDokqSEJDElWSGJCktDN2XFrdiCJBEkaSIJAkgEW8bFIjkVoLPJiERWLlFgExCIbFrGwSISrwiIHFhEwSY9JcEwyYxIXk6SYhMQkHybRMEmFSSBMsmASQyYJ8JKLl0i8pOElCC8ZGMRjkIxBKAZ5GERhkIJBADpZdGLoJNAIo5FDI4KHFA8AgmsS/XeRIPmnOqfVeUXJDTfRdVPHrqX+UTa+n3quz5C/n1Y6N4LoL4aiPw3Dn8lG27vlQr++FrG7Wp0n5cKXk3KZSeo8VHUeOnXkesLc7zwP669ur+n4KFLXIrbrYWz3a449fV+0TOzXo5Cxeb4pWdsTHtc/0nY0pU654Kk5sri8eB0iS5RM7i/s3Fb13NjacGTCgiLx21S+kXKvksk9jZVOu3gtRmHjNc8eX7zm3ScxXmNHFpcXr+P/xquOLTdek2hRpC0V2ZqS/e7I1pXsj3Jhu1Acg+rvsG3yeR+snz3rPmzHw69toayXC39IDK6q7xLlv0f+0fUdWapkcblsp159jpUdrUs4Eqd+Xn1uVec19Rv5fdtjf82xv8Tt+c71S+qpn3rqI9buVH83qgMx9Jf8Jrr47OI4rj5nVyrDwtdO2ukfdH1toaH+U9HfCKK/l4n+zTD8836qGeb+DkT/Vhj+efy0wvD3RH87DP+Z6N8Owz9/j+kE0V/Mx+U7Yfjn8b8bxv9z/r0w/HP9+2H45/f3IIz+sYw7bkSL4o4zD9X3dv1/b3zZcabYrzusocaZhw6P6x89zoTsyMPa9sjcZ/TIY+fIY8ena9NQ14Ghrm1DXQ1DXfuGutqGuuqGuvYMdbUMdaWGuizvo6W/LGN111CXZaxuGeq6ru2E5fNo6fvrGqsbhrosY8IyVi39tWOoy7KNthwDNA11WfYdls/QdY2vp6H9CtEPhV0PzDLfPFhkp987D2aoPxNfS6zquW9tU64vcer/6fh5M4ife1N5J5M2SPvCN1dlabvm2Isi//us2G96eIS77pFd5R/Mno5OTsf383wwzIuifzKsOfqF1f1OzzvrPkfX970b++bVDH098q3xtJRfUWIl23JkiZIJo17j8c07WvJfxv/aftsjc8del72XnWg51vTz2IgWz3Bc2l/7cHTeljxirPQn0fIabuTYT5z6f1ef3bbuqs/I2XDaPetPz6bF9MGD/GTacfRrH8JP/wJJ9PoyCV0AAA==","debug_symbols":"tZbRCoMgGIXfxWsv0pV/7VXGGFYWglhYDUb07tOILbbrcxMd+fXzwg/OylpTL/3D+m6Y2PW2Mjc0eraDj2ndOKuDdc72j/Myy9JHFGrfMI3apzzNOszsKi5CVpwZ3+7/VMVDOutMTDLf+N88yWOY6DOZ03bnEUBoQIkGVGCAytAAgQZINOCCBuRoQIEGoE1WaJMV2mSFNpnQJhPaZEKbTGiTCW0yoU0mtMmENpmgJm8xPXWwunbmaDjd4ptT4Zlfo/npPmMYGtMuwaQW9C1A6TXmkhcyXTvZK8qMi7KIkAh6Aw==","brillig_names":["process_log"]},{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{"10502589790419500451":{"error_kind":"string","string":"Function _increase_public_balance can only be called internally"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["_increase_public_balance"]},{"name":"set_portal","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JwACBAEoAAABBIBHJwAABAMnAgIEAScCAwQAHxgAAwACgEYuCIBGAAElAAAARSUAAABbKAIAAQSARycCAgQAOw0AAQACKACAQwQAAygAgEQEAAAoAIBFBAABJiUAAANZJwICAAIvDAACAAMcDAMEACwCAAUAAAAAAAAAAAAAAAAA//////////////////////////8OOAQFBiQCAAYAAACnJQAAA4InAgQAAAo4AwQFJAIABQAAAMInAgYEADwJAQYpAgADADuaygIvDAADAAUKOAUEBiQCAAYAAADjJQAAA5QoAgAFAN6tMAwABQADLQgBAycCBQQEABABBQEnAwMEAQAoAwIFLQwFBi0OBAYAKAYCBi0OBAYAKAYCBi0OBAYtDQMFACgFAgUtDgUDKwIABQAAAAAAAAAAAQAAAAAAAAAALQgBBicCBwQFABABBwEnAwYEAQAoBgIHLQwHCC0OBAgAKAgCCC0OBAgAKAgCCC0OBAgAKAgCCC0OBQgtDQMEACgEAgQtDgQDLQgBBAAAAQIBLQ4DBC0NBgMAKAMCAy0OAwYtCAEDAAABAgEtDgYDLQgBBQAAAQIBLgqARAAFLQgBBgAAAQIBJwIHAQAtDgcGLQ0FCC0NBgkKOAkHCiQCAAoAAAHyJwILBAA8CQELCygACIBDAAkkAgAJAAACgyMAAAIHLQ0ECC0NAwktDQUKLQ0GCycCDQQDDDgKDQ4kAgAOAAACLiUAAAOmLgQACIADKACABAQABCUAAAO4LgiABQAMACgMAg0AOA0KDi0OAQ4BKAAKgEUACA44CggNJAIADQAAAm4lAAAERi0ODAQtDgkDLQ4IBS0OCwYjAAAC9icCCAQJLQgACS0MBAotDAMLLQwFDC0MBg0AEAAIACUAAARYLQQAAC0NBAgtDQMJLQ0GCi4EAAiAAygAgAQEAAQlAAADuC4IgAUACwAoCwIMASgADIBEAA0tDgENLQ4LBC0OCQMuCoBFAAUtDgoGIwAAAvYtDQYICjgIBwkkAgAJAAADECcCCgQAPAkBCicCBwQILQgACC0MBAktDAMKLQwFCy0MBgwAEAAHACUAAARYLQQAAC0NAwQBKAAEgEUABS0NBQMwDAABAAInAgEAAzAMAAMAASYoAIAEBHgADQAAAIAEgAMkAIADAAADgSoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFWgLkG7UeqZ88AQECJioBAAEFHwotJ9yCh6I8AQECJioBAAEF6J0J/qERLQ48AQECJi4BgAOABgsAgAYAAoAHJACABwAAA9MjAAAD3i4AgAOABSMAAARFLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABDEuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAABAAoAYAFBAABAwCABgACgAYjAAAERSYqAQABBUWnynEZQeQVPAEBAiYlAAADWS4IgEQABSMAAARoDSgABYBDAAYkAgAGAAAE2CMAAAR9LQ0BBS0NAgYtDQMHLQ0ECCcCCQQELQgBCicCCwQFABABCwEnAwoEAQAoBgILJwIMBAQAKAoCDT8PAAsADS0NCgYAKAYCBi0OBgotDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWARQAGJAIABwAABPYjAAAFpy0NAQctDQIILQ0DCS0NBAonAgwEBAw4BQwNJAIADQAABR0lAAADpgAoCAIMADgMBQ0tDQ0LJwINBAMMOAUNDiQCAA4AAAVCJQAAA6YAKAcCDQA4DQUOLQ0ODAA4CwwNJwIMBAQMOAUMDiQCAA4AAAVsJQAAA6YuBAAIgAMoAIAEBAAFJQAAA7guCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAFpy0MBgUjAAAEaC4AGMoYyg==","debug_symbols":"7Z3bbuM4DIbfJde9EKnzvMpgUfSQKQIESZG2CyyKefd1gtrJOGwci5ruDvTfFHFDmvZnSqSpQ94Xj8v7t6fb1ebH9mXx7fv7Yr19uHtdbTfd0fvPm8X9brVer55uT/+9MPs/ORzkX57vNvvDl9e73eviG8WcbhbLzWP3MbHvzvBjtV4uvvnu45mw9Y4/hG0wR2GKJEgTJ9+f2p5Is5Gkow/9hUSf8iAdnSRsQ+yFnQmXhYm6i+0vhGy2p+J/3SzIEMh8Qib+z8n4gUww7vLN5jic2RhzPHOw0pk5DyfmCVkiZweIIU1I+9gL+3x8lpQOvInB+yt5uwzeX8nbO/D+St4B/cnX8p6Olzae8t4rRS5RKrGUfIFSNiVKckNP7qiU6LLjceY+k+HsecLx/rskiY1t6F5zhXvNvQlrRh3K3gS5326C+febiGoTlobHbLsGNeEUyXB/Qck4nnCKxH0vFlN0U07hQh6cwpMZO4V17dyrM/p75dibsHwaQ+SIatzQIs1pLJMjanZ9lIz5pPlyMmJsDx/Cjk8iqgSGu6fS91BMfFnYc39ez/FU9EDQgaCSYAZBHUEPH9QShA8qCQb4oJZgAkEdwcggqCQYQVBHMBEIKgkGENQRzHiru4LgUBrygc4IOhBUEkRGrSNoKxRiGyA4yIZfRfcEGa1YSxDvJEqCFq1YSxA+qCTo4INagvBBJUGP2oyWIN6LlQQDajNagh4EdQQjajNagg4ElQRRm1ESTMioxwQPWDB8JGHJyH1FLEhoBSzOIEMQsSD1FLEglktYCAFaxII6loSFEaBFLAjQEhaLMpKIBQFaxIIALWHBugkRi0fyL2KBt4hY0LdIWLAWQcbSavLPuV/zz7+s4heXTBrKx2tOY4bNLjGoybDV14pZDMket3Hw48mhrtllBjUZtho9KzJsdqJ8TYaIy9cwDMOGOR2PEUNPaMtXMOzGlvprdmbsh55brZnXZNjqCHhFhs3WV2sybLUYO4uhH/bSIe/NmGGzm+PUZAg/VDP0iMt6hsix1QybLatWZBiR2+gZon6oZphQx9YzxLuemmGzU6NrMkR/eA3DyAPDPB4bDcaBoZoharBqhoSYombY7GzemgwRU9QMLeqHeoaIy2qGzW7/MouhpYGhtXTGEPVDNcNmt4CpyRBxWc0wIC7rGSIu6xkipqgZRuQ2eobwQzVDjKdUYIjcRs2w2a3fazJ0YHgFQxcHhmE8JhWb3cSmJkOMBagZEuKyniHyQzVDrK3QM8S6gAoMMR9bu7YiNrujS0WGGJOqwBB+qGbY7LqAOGzRwNHaYuE9w9Bqjj2HIYUwzOEM6cwPQ6vvehUZxlZzm4oMU6t1m5oMHRhOM4yxPzHF7M8YtprbVGSYW82xazJEXNYyTKbVuk1Nhsht9AwRU9QMyYGhmiH8UM2w2fGUmgyR21zBMB/nimQ+Y9jseEpNhjX6w2GHRct+imEy3DNMxh0ZRuniYxoWX8e0l7gkTOTCsPUteTKn4vt7rbIf0h9yr1X2sv8z7pWIxYGEbqywt+HGdfPunKLjZ9c3luz9mY68GdSETpyvI/9W7oSO7NwXd4Mm+uQXUae0XJFWLtFKRbZSka1cZCuX2GJTYovJFGmV2Sq6r0+SwymtWKL1yaSUKa2SlsLyhoQX+xiWf2clm/6HAjILOvP7JZZb8WU7seDa5MUKl3XkyfkTOmE+g0wFOvPtWLndTujMf6aWCuxQgR25vWbf+3WOfK6T5uvYAjuOCnTCfB1fYMcX2JEXP548H0nHz3+m0RToFNhJtkAnzdfJ89uCM1SgM78/cPIk5wmd+TnhJz+TOKFTcD/WFOgUPB870w9+dkd/3+1Wd/fr5Uunsf/ybfPwutpuPg5f/3nuv7nfrdbr1dPt8277sHx82y1v19uH/XcL8/HnO3XlGcpxfy2Hw0A33dDyIaE7HMbuMHdWO8v/Ag==","brillig_names":["set_portal"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":58},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"}},"parameters":[],"return_type":null},"bytecode":"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","debug_symbols":"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lUlXVCZdUZl0RWXSFZWTrqicdEXlpCsqJ11ROemKyklXVE66onLSFZWTrqicdEXlrCsqZ11ROeuKyllXVM66onLWFZWzrqicdUXlrCsqZ11RueiKykVXVC66onLRFZWLrqhcdEXloisqF11RueiKykVXVK66onLVFZWrrqhcdUXlqisqV11RueqKylVXVK66onLVFZUV7aW9wtEVlRXteb3C0RWVFe1NvcLRFZUV7SG9wtEVlRXt9bzCURWVWdGezCscVVGZFe2dvMJRFZXZqYrKrGjf4hWOqqjMivYXXuGoisqsaB/gFzi69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28e69vaxrr19rGtvH+va28cv39vHbvxkz3EO5+VRueQJDrtHOPPB1dFtbH1AHhbHXpKB29iLTR/GXsz07vWbBt9kpzdiZzBiZzRiJxmxMxmxMxuxsxixsxqx00g+5I3kQ95IPuSN5EPeSD70+i3Rb7LTSD7kjeRDvpt8KI9jvxSbC4Z2kxBtGdpNRrRhaOgmJdoytJucaMvQbpKiLUP1ZEUDHlKGR0+WMeDRkw0MePSs2gMePYvrgEfPGnjFE/UsVQMePSvKgEdP4B/wKIvPUVl8fvUpAsEXvg2mwun5Qk2xjmMzTUN9rUsffP+1NXq/kQH4C9A40pKo3rMAH+KNmAxilokpIGaZmApilolhELNIzKvPvWiHGA9ilokJIGaZmAhilokhELNMDDLfFWKQ+a4Qg8x3hRhkvivEIPNdJiYh810hBpnvCjHIfFeIQea7QgyBmGVikPmuEIPMd4UYZL4r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","brillig_names":["sync_notes"]},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6067862452620309358":{"error_kind":"string","string":"Function balance_of_public can only be called statically"}},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3bbuM4DIbfJde9EKnzvMpgUfQ0RYAgKdJ2gUUx775OpnbSSIhXolAkq/+mqBMypD7LJi1R8sfi8en+/fl2uf61eV38+PmxWG0e7t6Wm/Vw9PH7ZnG/Xa5Wy+fb448XaveHFO8VXl/u1rvj17e77dviBxnl6WbxtH7c/x/18CO/lqun4YiH/xN5P4h8intScZL2JiMc2bhP4cjui/BfN4NH/r94ZL94tNMjrtSrtMe2Tk+rnJ4mbz/VNEUzaVmbIUjKjbiJ6OjkuBxvCiNuimGSHQz+ccdcljvxotwxl0XHXBYde1l0bLgodxxfljv+otzx9N3u2NEdVvzFnUw8i2Z0w8ej6MdBZaT19MuG1UE25wQPjRq9YOLzwpbH37Xsj0X3/Bz4SfgFBX4ifhb8JPwi+p+MH/qfhB8r9D8ZPwN+In4B/CT8SIOfiJ8HPwk/ZvAT8cPz2yw/p0Z+jk75aeQvMn7In2X8IvjN8Ztk3VfRHT+H61fGz4CfiB+uXxE/j/4n44f+J+IX0P9k/DD+IuIX8fwr44fxFwk/rTB/LuOH8RcRP8Lzm4wfxl9k/JA/p1AYk0IZKMh0Uyga6WsGCnKCFIpBopmBguidgYKQnEL5/hr5a4CCkJxCcQjJGSgYJkqhYO1EDgpCcgoFqxxyUJDmp1CwHiEHBfeUBIrByoEMFO4TCusDFGNPoeg+03xPcfTCa10tvCNo+nwmKCFI7tA+Fygh2OcDREOCts8g2JBgp7WuLQkaEJwj6P2034KPSSzutN61IUHf5+RqS4KIxUKCoc+Rv5YEkc1ICSKSCAlGA4JCguiDMoJWIZuREkQ2IyRIyGakBJHNSAkikggJdlp03JIgIomQYKflzC0J9lkUUUQwEo/ti5wQ/P69ov93BBvMF1MIo4XjGek8QWv9KD1MOhwYErscQ+dHhOHgBnneO2/1NTt/zeSdu2Ln52s5Wbk553Wc7hruq4mMO9aNznsbZt7V4PXBeXPkR1Z48GPaMWnnkz4W37fVf3tb7dRWp8yM+47GtpLTB2Gt7d77wFft/TWzd52u1tZq8kKTOQmXrtPhkxko6CkpFDaAkkLpc+TnPBSNnpKBgp6SQjF9Dvtx5AmKsjOPu2p6Nh6aGhKCfQ77NSRo+8yAigiSPrTPUkKwz3SpIcFOS1NbEuwzvDYk2GlpahlBZ6f2hSSSdFqSVUTQqGl0z6ikD8Y+F3u1I+hVn5OYLQkimxES7HRbxyKClqf2WasSgn2WZDUk2Ota6oYEEYuFBDUyailBPNUJCRpkM0KCGB8UE8QYtZBgp9v6tSSIPigk2OmGgWUE/VSaaiMnBJHNCAl2+sKmhgQ7feVQS4KIJDKCodPXDrUkiPFBKUHEYiFBwvjgLEF9WKqk9ek8Seh00WtLgojFQoIasVhKELFYShCxWEgQddRigshmhAQt+qCUILIZIUGHbEZKENmMlCCymXmCZlqprd3pTFPo9C1MDQkGjPJLCSIWCwlG5INSgngmkRGMqOWXEkQtv3A1RCQDgkKCuA8KCXa6d0tDgqjlPyE4QCHF2Sc1P23x5Y1OdPIV6dGMhqJN7VhVoWMqdEK5Tr429/ymE8NHvkYrX4M5q+VqtEKVrVBlK1bZijW2SFGVVs35IqqyRVXtyq94m9UyVVqhRktzlZYvvseQyXKPanzRaOSMTvl9ifJX8Xk7vsK3/IjYjE4s1wm6nEEov2dSLLfD+et2Rqf8nDJV2KEKO/nrNdqxX0fPqY4t19EVdvIv3T2vk5+DntGpsGMr7ORn1o7OT0YnH9fPn1Pny3V8hZ2gKnRsuU6suBZi+f1AK12hE8t1yFToVNjhivZwed/Rmip0CvvB7+Ho77vt8u5+9fQ6aOy+fF8/vC0368/Dt39exm/ut8vVavl8+7LdPDw9vm+fblebh913C/X55+fQ4W846n0GNxzuNs2mP4e7xnA0w7dusDpY/hc=","brillig_names":["balance_of_public"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"initial_mint","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VjbiuMwDP2XPOfBkixb6q8sy9DbDIHSll4WltJ/XyeMnV7cDC7dWcr2pUSJjn18jm3ZPVSz+WT/8dYs31fbavTjUC1W0/GuWS1DdKjAdu+26/GyDbe78WZXjdCK1tV8OQuPzPZYV+/NYl6NAOlYX2ejcTEbUVK2ci5ZxMdkdWY4GVjZfmaHZ9e3jWJyjQMmJmC5z1afa50cxcYtmLPsn3UF/JLmljTuJc0taXxeGqReGv5CGgvMn9kWFFK2p64H+es9aK4HQIgeQPAjYTjrAXCyNzyjS+nOPbW/aB6hDZ1o43RYG3K9Vdj7aqWjA4+g4zXRcYjDdECdJoHUnyjks8ucjIWoPhlvLuYa4rMPgL57AGiI4vxHw6SXjLI1HQgw9kHkhhkp2CiRntLPKiQmspETLui1I8N5MlYSGcdfkHEYDVBv/DAZcC7tDZ7oZL24jk62coHFRMcK/K9bm39pc1MbeWlzUxt9hDYPK4lkHkHnH1YUgmcfAH73AIZLYggmm2axaD7ezi6/pv2x2WrJEAfIbC5nmOVyiCuH+HKIFEJCBG1m/hTGGk8MnvW8koYI20yfBarExax6dSLwVA6x5RAuh7hyiC+HSDlEiyFiyiFQDil3X8rdl3L3pdx9KXdfyt2Xcvel3H3Nu9+fjI3BKwzcgcE7MHQHxt6B4TswrhQTIur+R81fc8SmO5cautpC7asAhfDXeNOMJ4t5W5Pbr/vlNJboEO5+r+OXWMTXm9V0Pttv5m057yt5O7EIaguBCLQrgE3NnGpc9wq5JpOqV4tgrZ1GhEoNhnpX23fhIo+Y3LrVyTGM5Q8=","brillig_names":["store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","store_in_execution_cache_oracle_wrapper"],"verification_key":"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"},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"15238796416211288225":{"error_kind":"string","string":"Balance too low"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3219842053230618354":{"error_kind":"string","string":"Function check_balance can only be called statically"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"fee_limit","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["check_balance"]},{"name":"claim","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"1186437190978851533":{"error_kind":"string","string":"Non-zero hint for zero hash"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"1589673740894288059":{"error_kind":"string","string":"Hint values do not match hash"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17288131482828810359":{"error_kind":"string","string":"Message not in state"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7Z3driTLbaXf5Vyfi4wIxp9fxRAMWdYYBziQDEkeYGD43Sd3d1ft3aqoZO/sqCgW15oL4/Qoo3aSzGItMpJf/M8v//Hnf//v//y33/7yf/7691/+5V//55ff//qnP/7jt7/+Zf/X//wS5Mv/39//649/efvn3//xx7/945d/idL6r7/8+S//sf9nzvK/v/7yf377/c+//EuI6X9/vb06buVydYztenXPo4tbq5eLe9mOLw65h8vV+3+n98tj20bXl9wul5da36/udXR1KulytYTtu6v/8OsvIdM191xT6Jp7rqnGXZPl3TWlKa6JIV7vJEj+Sdc0uuaeazpdc8c1cRu7JqZ312TFNRJy/na1hB6uV9f05S+Eh/+FOPwLW7rGYKvxuiaPYiDp4lIp70/C20Nxc2npW/h2bdkz4fudt8HFLcoltC2W+PHitxtPr3rj8qo3nl/1xsur3nh91Rtvr3rj/UVvPG2veuPhVW/8VX8506v+cqZX/eVMr/rLmV71lzO96i9netVfzvSqv5zyqr+c8qq/nPKqv5zyqr+c8qq/nPKqv5zyqr+c8qq/nPKqv5zyqr+c+VV/OfOr/nLmV/3lzK/6y5lf9Zczv+ovZ176y1n3naxv19b44eJv91IN3UszdC997b30y2ZjTeGf76Vshu4lGLqXaOhekqF7ETvfo5IN3YuhvFuqoeelGboXQ3m3Gsq71VDerYbybjWUd6uhvFsN5d1qKO9WQ3q3GtK71VDebYbybjOUd5uhvNsM5d0mhu4lG7qXYuheDOndZijvtm7nXvpm6F6CoXuJhu7FUN7thvJuN5R3u6G82w3l3W6oz9AN6d2wGRK8YTOkeMNmKPWGLVm6GbF0M4a6DWEz1G4Im6H8GzZDCThsljJwsJSBg6UMHAw1HUIwpH5DMCR/QzCkf0OwlIGDoY5vCIZaDyEY6j2EaKj5EKKlDBwtZeBoKQNHSxk4WsrA0VALIkRLGjha0sDRkgZOljJwMtT/DclSFyJZ6kIksXQzljJwspSBk6UMnCxl4GQpA4ulLoRY0sBiSQOLJQ0sljKwWOoDi6UuhFjqQoilLoRYysDZUgbOljJwtpSBs6UMnMXSzVjSwNmSBs6WNLClUbeQLfWBi6UuRLHUhSiWuhCW5t1CsZSBi6UMXCxlYEszb8HS0FuwNPUWLI29BUtzb6FaysDVUh/Y0uhbsDT7FiwNv4VqKQNXSxnY0vxbsDQAFyxNwAVLI3DB0gxcsDQEFyxNwYVmKQM3S31gS4NwwdIkXLA0Che6pQzcLWVgS9NwwdI4XLA0DxcsDcQFSxNxwdJIXLA0Exc3Qxk4bob6wNHSTFy0NBMXN7F0M4YycNwMZeBoaSYuWpqJi5Zm4qKlmbhoaSYuWpqJi5Zm4mKwlIGDoT5wtDQTFy3NxEVLM3ExWMrA0VIGtjQTFy3NxEVLM3HR0kxctDQTFy3NxEVLM3ExWsrA0VAfOFqaiYuWZuKipZm4mCxl4GQpA1uaiYuWZuKipZm4aGkmLlqaiYuWZuKipZm4KJYysFjqA1uaiYuWZuKipZm4KJYysFjKwJZm4qKlmbhoaSYuWpqJi5Zm4qKlmbhoaSYuWjr8LVo6/S1amomLlmbioqWZuGjpBLho6Qi4aGkmLlqaiYuWZuKipZm4aGkmLlqaiYuWZuJitZSBq6U+sKWZuGhpJi5amomL1VIGrpYysKWZuGhpJi5amomLlmbioqWZuGhpJi5amomLzVIGbpb6wJZm4qKlmbhoaSYuNksZuFvKwJZm4qKlmbhoaSYuWpqJi5Zm4qKlmbhoaSYudksZuBvqAydLM3HJ0kxcsjQTlzZDGThthjJwsjQTlyzNxCVLM3HJ0kxcsjQTlyzNxCVLM3EpWMrAwVAfOFmaiUuWZuKSpZm4FCxl4GApA1uaiUuWZuKSpZm4ZGkmLlmaiUuWZuKSpZm4FC1l4GioD5wszcQlSzNxydJMXEqWMnCylIEtzcQlSzNxydJMXLI0E5cszcQlSzNxydJMXBJLGVgs9YEtzcQlSzNxydJMXBJLGVgsZWBLM3HJ0kxcsjQTlyzNxCVLM3HJ0kxcsjQTl7KlDJwt9YEtzcQlSzNxydJMXMqWMnCxlIEtzcQlSzNxydJMXLI0E5cszcQlSzNxydJMXCqWMnCx1Ae2NBOXLM3EJUszcalaysDVUga2NBOXLM3EJUszccnSTFyyNBOXLM3EJUszcalZysDNUh/Y0kxcsjQTlyzNxKVmKQM3SxnY0kxcsjQTlyzNxCVLM3HJ0kxcsjQTlyzNxKVuKQN3S31gSzNxydJMnFiaiZPNUAaWzVAGFkszcbIZysBiaSZOLM3EiaWZOLE0EyeWZuIkWMrAwVAfWCzNxImlmTixNBMnwVIGDpYysKWZOLE0EyeWZuLE0kycWJqJE0szcWJpJk6ipQwcDfWBxdJMnFiaiRNLM3ESLWXgZCkDW5qJE0szcWJpJk4szcSJpZk4sTQTJ5Zm4iRZysDJUh/Y0kycWJqJE0szcSKWMrBYysCWZuLE0kycWJqJE0szcWJpJk4szcSJpZk4yZYycLbUB7Y0EyeWZuLE0kycZEsZ2NJMnFg6J04snRMnxZIGLpYysKWZOCmWMnCxlIGLpQxcLPWBLc3EiaVz4qRa0sDVkgaulvrAi2fi9v2ty83sGzo3N/PzGThv4du1OW3HN1P69drSw3c3c3txiyLfLm6xxJs7zy975+Vl77y+7J23l73z/qp3PmFC8Fl3Hl72zuPL3nl62Tt/2d/Q9rK/oe1lf0Pby/6Gtpf9DW0v+xvaX/Y3tL/sb2h/2d/Q/rK/oRPmUp915y/7G9pf9je0v+xvaH/Z39D+qr+heXvV39C8vepvaN5e9Tc0b6/6G5q3V/0Nzdur/obm7VV/Q/P2qr+heVv6G3q8A5i3buhmwmbpZsLamznadMshWrqZZOlmxNLNZEs3Uyx9m6qlm7GUgUM39MzEzdLNWMrA0VIGjpYycLSUgaOlDBwtZeBoKQNHSxk4WtLAyZIGTpYycLKUgZOlDJwsZeBkKQOnYulmqqWbaZZuxpIGFksZWIKlm4mWbiZZuhmxdDOWMrBYysBiKQOLpQwsljJwttSFyJY0cLakgbMlDZwtZeCcLd2MpS5EttSFyJa6ENlSBi6WMnCxlIGLpQxcLGXgIpZuxpIGLpY0cLGkgYulDFws9YGrpS5EtdSFqJa6ENVSBq6WMnC1lIGrpQxcLWXgaqkLUS1p4GZJAzdLGrhZysDNUh+4iaWbsdSFaJa6EM1SBm6WMnCzlIG7pQzcLWXgbqkL0S1p4C6WbsaSBu6WMnC31AfulroQ3VAXomyGuhBlM5SBy2YoA5fNUAYum6EMXDZDGbhshroQZTOkgctmSAOXzZAGLpZm4kow1AcuwVAXogRDXYiyeibu+GYsZeBgKQMHSxk4WMrAlmbiiqWZuGJpJq5YmokrlmbiSrSUgaOhPnCxNBNXLM3EFUszcSVaysDJUga2NBNXLM3EFUszccXSTFyxNBNXLM3EFUszcSVZysDJUh/Y0kxcsTQTVyzNxBWxlIHFUga2NBNXLM3EFUszccXSTFyxNBNXLM3EFUszcSVbysDZUh/Y0kxcsTQTVyzNxJVsKQNnSxnY0kxcsTQTVyzNxBVLM3HF0kxcsTQTVyzNxJViKQMXS31gSzNxxdJMXLE0E1eqpQxcLWVgSzNxxdJMXLE0E1cszcQVSzNxxdJMXLE0E1eapQzcLPWBLc3EFUszccXSTFxpljJws5SBLc3EFUszccXSTFyxNBNXLM3EFUszccXSTFzpljJwt9QHtjQTVyzNxBVLM3GlG8rAdTOUgaulmbhqaSauWpqJq5tYuhlDGrhamomrlmbiqqVz4qqlc+KqpZm4amkmrlqaiauWzomrls6Jq5Zm4qqlmbhqaSauWpqJq5Zm4qqlmbhqaSauRksZOBrqA1dLM3HV0kxctTQTV6OlDBwtZWBLM3HV0kxctTQTVy3NxFVLM3HV0kxctTQTV5OlDJwM9YGrpZm4amkmrlqaiatiKQOLpQxsaSauWpqJq5Zm4qqlmbhqaSauWpqJq5Zm4mq2lIGzpT6wpZm4amkmrlqaiavZUgbOljKwpZm4amkmrlqaiauWZuKqpZm4amkmrlqaiavFUgYulvrAlmbiqqWZuGppJq4WSxm4WsrAlmbiqqWZuGppJq5amomrlmbiqqWZuGppJq5WSxm4WuoDW5qJq5Zm4qqlmbjaLGXgZikDW5qJq5Zm4qqlmbhqaSauWpqJq5Zm4qqlmbjaLWXgbqkPbGkmrlqaiauWZuJqt5SBu6UMbGkmrlmaiWuWZuKapZm4Zmkmrm2GNHCzNBPXNkMZuG2G+sDN0kxcszQT1yzNxLVgKQMHSxnY0kxcszQT1yzNxDVLM3HN0kxcszQT1yzNxLVoKQNHQ33gZmkmrlmaiWuWZuJatJSBo6UMbGkmrlmaiWuWZuKapZm4ZmkmrlmaiWuWZuJaspSBk6E+cLM0E9cszcQ1SzNxLVnKwGIpA1uaiWuWZuKapZm4ZmkmrlmaiWuWZuKapZm4JpYysFjqA1uaiWuWZuKapZm4li1l4GwpA1uaiWuWZuKapZm4ZmkmrlmaiWuWZuKapZm4Vixl4GKpD2xpJq5ZmolrlmbiWrGUgYulDGxpJq5ZmolrlmbimqWZuGZpJq5ZmolrlmbiWrWUgaulPrClmbhmaSauWZqJa81SBm6WMrClmbhmaSauWZqJa5Zm4pqlmbhmaSauWZqJa91SBu6W+sCWZuKapZm4ZmkmrnVLGbhbysCWZuKapZm4ZmkmrluaieuWZuK6pZm4bmkmrm+GMnDfDPWBu6WZuG5pJq5bmonrm6UMbGkmrls6J65bOieuB0MauAdLGdjSTFwPljJwsJSBg6UMHAz1gbulmbhu6Zy4Hi1p4GhJA6+eiTu+mbUZWGK+3IzEenMzP5+BwxbSt4vDJsrthK28X9zfPzm2bXB1kfjt4lLebz29/fftJ8vV6yGLfHf1F0srjKUNxtKOYumEOcRXsTTAWBphLE0wlgqMpRnGUhiNlGA0UoLRSAlGIwmMRhIYjSQwGkn8aKRaLi2H0GJUrt47Rdu3q/fWSL/1i4D6JedL57HnFm/94kd/zfWLH7X2Ob+kfrl6/33I2mfnLW/XdLSVcutHP1rwuX70ozTnfk/96NKpfsl+VOxTv3fZj0Z+rh/9KPC531NUva75RVjHjOqYTL0+fl5Q9brmF+rvOb9fqPp7th+p14ff04Kq1zW/UH9P+d4VVP0924/U6+PvqdAvQ7+g6nWljinU6+PnBVWva36h/p7z+4Wqvyf7sVKvD7+nFVWva36h/p7zvUPV37P9KPyeDr+n7K+P/YKq15U6plKvj58Xvq8y9gv195Tfr8b3W+b4kXp9+D1tfF9l7Bfq7znfO6Efp/iRen38PWV/fewXVL2u1DGNen38vPB9laFfOvX3lN+vzvdb5viRen38PeX7KmO/CL93U753qPp7th+p18ffU/bXx35B1etKHdOp10fPS9g2vrByxzFU4DN+wXZH8hWXSY6kZr/zVRU6ZuwYqvBJXz1iXyY5krr9zleVjfY7jkFV7scVzW4Tlfv4iQl8d+WOY6jE5/yKBb7tMsmRwq/q+KvK91fuOIZKfNJXjwSYSY6kcr/zVWXPfeyYiKrctZImUrnfeWL4Gssdx1CJz/kVm3CIHR35xZFU7ne+qnyV5Y5jqMQnffUIg5nkSCr38VfV0UGJkx2Dqty1ksbRMYyTnxi+zXLHMcJfsSm/Yo7OkHyyI6nc73xV+TbLHcdQiU/66pELM8eRjo7vnPtVdXTa52THoCp3raSBPUtUfWKEjhk7hkp80q8Y336Z5Egq9ztfVb7NcscxVOJzvno8gnSWI6ncx19VHip6zzGoyl0raWCPFVWfGL7NcscxVOKTfsX49sskR1K53/mq8m2WsWNgDxed/dXjaaSzHEnlfueryp77HccIS5phSQN7wqj6xPBtljuOoRKf9CvGt18mOZLKffxV5TGj9xxDJT7nq8eDSWc5ksr9zldV6JixY1CVu1bSwB42qj4xfJvljmOoxCf9ivHtlzmOhD2gVPuq8sTRe46hEp/01SMrZpIjhV/V8VeVPfc7jkFV7lpJA3vuqPrE8G2WO46hEp/zK8ajSmc5ksp9/FXl4aP3HEMlPumrJ3TkHEdSud/5qrLnfscxqMpdK2lgjyBVnxi+zTJ0TIA9g3Tyr1jgmaWzHEnlfueryrdZ7jhG+NWb89UjK2aSI6nc73xV2XO/4xhU5a6UNMHPGaQxpH6551DDral+ThXVTXWjlnVT3ehZ3VQ3ClU3VXBMdaMKdVPd6DbdVDdKTDfVjbbSTfWjlnK9fHIsod2a6uckR91UP2pJNdWPWqrXki82tamgFoh+Tluc7RgBdczsppWf0xOf7Ug/KnLyV9WP5pzsGD8K9clfPT/697mO9HPa4uSvqp/TFmc7BlW5azsYfk5bjD3K5Z57TZpjepXrfezWaklpzznXpLR/zQbFoZ/jGZ/uST9a/9me9CP2n+1JP9XBsz3pp5x4tif91BNP9qSfQyCf7kk/FcizPemnZHm2J1njzPKk0JOTPMkaZ5YnWePM8iRrnFmedFPjyFbCt4tl3+YfmOqmCFFN9XNApW6qGxmvm+pGZ8ve77uYGregpbHayuV9vVB72tS0t7Xr9W8v8w1c6UZoP9+VQlfOcqUbqb3UlTEPXOlGaz/alapE9HO85fNd6UdtP92VftT8s13p5xDN57vSTzXydFey2pnmSlY701wpdOUsV7LameZKVjvTXMlqZ5orYaud3i9vPoe235R2fZSrS/b/rtvAlbDVzmddmd9vPOY+cKWfg0c/6coW3zcPW9pk4BrU6uUHXINajTRJ766RPJhx8nM8qMQQr66RqLqmhndEV80DjoSfA0Lnu8aP+p/uGj9q/pOuafKea3bfKNeXvl02zEsP7/fypkVvLm7x+tktlvjx4q9O96P7X8jpfiqEF3K6n1ridZzu59DUV3K6n3rmhZzup1J6IafD1mDPdLrQ6eudDls3PtPprEif4HRWpE9wOivSJzidFel6p/s5PPiVnM6K9AlOZ0X6BKezIn2C04VOX+90VqRPcDor0ic4nRXpE5zOivQJTmdFutzp0c8h2q/kdFakT3A6K9InOJ0V6ROcLnT6eqezIn2C01mRPsHprEif4HRWpE9wOivS9U73c5T8KzmdFekTnM6K9AlOZ0X6BKcLnb7e6axIn+B0VqRPcDor0ic4nRXpE5zOinS90yMr0ic4nRXpE5zOivQJTmdF+gSny9DpYbu4Zm8UbMdOl63kq7XpnZIWahhZW693H6q8067ecFBf7yibu6Ni7o6quTtq5u6oW7ujtJm7o2DujqK5O0qL7yimfvn1iFL64I5W5+z9V6Jc76h/76PR76pc4azbh5+c8dW1y+VOau9J+RVO+QM/8P3a0c97rOHClI31g4nDi0Ot5foU9KxcvF0/eTewfbz4a3wy42M6Pqt/z2MO1/jknBSP75puFJ6w1aG+uxL9WsyaiPUYzMpg+glmYzD9BLMzmG6CKZvpYIbYri2UvfvyXTS/3n948fuPtu+/v58i0D+Q8sffpv1LcfkyhQ/fpVqH2vba0tvbsvW7q796JtEzdzwj9Mwdz2RYz6RrbyHKyDO2a6NnesZ2ofFMz9hW7Y/0TH73TA0Dz9iWwE/0TDauJ5/oGeNK9ZG/2h88EweewdXA10pu39YqA8/gamDNM0LP3PEMrgb+kGf6QM9kTxq4lffNnpQV1zyucRXf9zTTpvWi0jVAIaXwc42r7Em2wwfTU6VhJJhPaylnT8URejCLp3puWjC/usZ6QReuWw/9w2NwR2jJxY/141PQRw9ubNe7jq192NT49u5psV7PPc0x1su5pzlG6JixY6wXc09zjPVa7mmOsV4XPc0x1muMpznGul5/lmOqde37NMdQ+d5xDJXvHcdQ+d5xjNAxY8dQ+d5xDJXvHcdQ+d5xDJXvHcdQ+Y4d06h87ziGyveOY6h87ziGyveOY4SOGTuGyveOY6h87ziGyveOY6h87ziGynfsmE7le8cxVL53HEPle8cxVL53HCN0zNgxVL53HEPle8cxVL53HEPle8cxVL5Dx6SNyveOY6h87ziGyveOYzwp33dbW9u+c8xXWwXIVk/6tJd3TtYWlCc+p3gZE8kpf/h+gHCy0uZJgTP0nwq9pxqDof9U6D1VUQz9p0LvqU5k6D8T+uCpEmboPxV6T7U+Q/+p0HvqZjD0nwq9p34NQ/+p0AtDjxp6dvNgQ89uHmzo2c2DDT27ebChZzcPNfSR3TzY0LObBxt6dvNgQ89uHmzohaFHDT27ebChZzcPNvTs5sGGnt082NCzm4ca+sRuHmzo2c2DDT27ebChZzcPNvTC0KOGnt082NCzmwcbenbzYEPPbh5s6NnNQw29sJsHG3p282BDz24ebOjZzYMNvTD0qKFnNw829OzmwYae3TzY0LObBxt6dvNQQ5/ZzYMNPbt5sKFnNw829OzmwYZeGHrU0LObBxt6dvNgQ89uHmzo2c2DDT27eaihL+zmwYae3TzY0LObBxt6dvNgQy8MPWro2c2DDT27ebChZzcPNvTs5sGGnt081NBXdvNgQ89uHmzo2c2DDT27ebChF4YeNfTs5sGGnt082NCzmwcbenbzYEPPbh5q6Bu7ebChZzcPNvTs5sGGnt082NALQ48aenbzYEPPbh5s6NnNgw09u3mwoWc3DzX0nd082NCzmwcbenbzYEPPbh5s6IWhRw09u3mwoWc3Dzb07ObBhp7dPNjQs5sHGnrZ2M2DDT27ebChZzcPNvTs5sGGXhh61NCzmwcbenbzYEPPbh5s6NnNgw09u3mooQ/s5sGGnt082NCzmwcbenbzYEMvDD1q6NnNgw09u3mwoWc3Dzb07ObBhp7dPNTQR3bzYEPPbh5s6NnNgw09u3mwoReGHjX07ObBhp7dPNjQs5sHG3p282BDz24eaugTu3mwoWc3Dzb07ObBhp7dPNjQC0OPGnp282BDz24ebOjZzYMNPbt5sKFnNw819MJuHmzo2c2DDT27ebChZzcPNvTC0KOGnt082NCzmwcbenbzYEPPbh5s6NnNQw19ZjcPNvTs5sGGnt082NCzmwcbemHoUUPPbh5s6NnNgw09u3mwoWc3Dzb07Oahhr6wmwcbenbzYEPPbh5s6NnNgw29MPSooWc3Dzb07ObBhp7dPNjQs5sHG3p281BDX9nNgw09u3mwoWc3Dzb07ObBhl4YetTQs5sHG3p282BDz24ebOjZzYMNPbt5qKFv7ObBhp7dPNjQs5sHG3p282BDLww9aujZzYMNPbt5sKFnNw829OzmwYae3TzU0Hd282BDz24ebOjZzYMNPbt5sKEXhh419OzmwYae3TzY0LObBxt6dvNgQ89uHmjo88ZuHmzo2c2DDT27ebChZzcPNvRiO/StbPdC//X+bbekYu6Xz44li/LohhivD3r8cNvp7e/cPuipXa7u8vZ5l89uw4ext28Xp7KVD0aOLo7pYmOKEj9e/NXptptBTp1uuw3j1Om2GyBOnW679fCiTk9XXZRSazdOD7aLfqdOt11uv6jT94+7XCwxHl8cW7oIzNhEuzjI9eKQ6204bZfQDOc/XRy3a9UVk3Jxrpcg5t4/mvc18rYraEb+cZEXRh408mw9vFbk89Ufsbafijz7H6iRZxPmpSL/Xn/F1NOtYGd7x1U42TjyFM7IltRLhVOutxFzqscXh9zixR1l225jz84YbuzZRvMb+xovF4eaw89o8cieGx+TH3hMhI8JHxP9MWE3z/FjUq9vkdXvC41PPyZs/fEx+YHHhH3Cpz8m5eqQpjV9tY39yD7hS4Vz3iZfZEsRNPKJ3cfXivy0Tb7E3iNq5Nl5fKnIKxtIiR1CV+EUhtNTONlxe6lwztziS2yj4caevTG/sZ+3IZPYc+Nj8gOPCRt0fEz0x0TYzXP8mEzbtxO2/viY/MBjwj7hsx+TLpfbiL3+ZEUi7BO6CqcwnK8Uzokqjy1F1MizoYgaebYTXyvy81Q4O4SokWfT7xGRb+ka+a5V3jO5WZnNuZcK57yXLDP7baiRZwsNNfLstr1W5Ke9XpuFkQeNPBtzLxV55dXNzG6bq3CyheYqnOyLvVQ4Z75cm9kZg419YRvNb+znbZgV9tz4mPzAY8IGHR+TH3hM2M1z/JhM27EtwseEj4n+mLBP+PTHZCI3q7BP+FLhnLfJV9hSRI08u4+vFflpm3yFvUfQyFd2Hl8q8soGUmWH0FU42clzFU523F4qnDO3+Kow9rCxZ2/Mb+znbchU9tz4mPzAY8IGHR+TH3hM2M1z/JhM27erbP3xMdEfk8Y+4bMfk5mgpcY+oatwsk/4UuGcp/IaW4qokRdGHjTybCe+VuTnqXB2CFEjb7zpV3q4XF3f/vprRH7fsL1cHL9/sfqr04230Hw63XhDyqXTu/H2jk+nG2/CvKbT39/BSam1W6cbb5X4dLrxLsVrOv1zh3NMpH52YThfKZzzRkS68dYDI/+wyBtvPTDyD4s8Ww+vFflpw0Gd/Q/UyLMJ81KRPx48KRvbO67CycaRq3CyJfVS4Zw4GlQ2dsZwYy+MvdvYT3vdp2zsufEx+YHHhA06PiY/8Jiwm+f4MZn1vlnZ2PrjY/IDjwn7hE9/TOZRP0tgn/Clwjltk68EthRRI8/u42tFftYmXwnsPaJGXhj5V4q8soEU2CF0FU528lyFkx23lwrnzC2+wDYabuzZG/Mb+3kbMpE9Nz4mP/CYsEHHx+QHHhN28xw/JtP27SJbf3xMfuAxET4mT35MJmIiS2Sf0FU42Sd8qXBOVHlsKaJGng1F1MiznfhakZ+mwhM7hKiRZ9PvEZH/1OEc87hZJbE591LhnPeSZWK/DTXywsiDRp7dtteK/LTXaxMbc6iRZ2PupSKvvLqZ2G1zFU620DyFU9gXe6lwzny5VtgZw40922h+Yz9vw0zYc+Nj8gOPifAx4WOiPybs5jl+TKbt2Apbf3xMfuAxYZ/w6Y/JRG6WsE/4UuGct8knbCmCRj6z+/hakZ+2yZfZe0SNPDuPLxV5ZQMps0PoKpzCcHoKJztuLxXOmVt8mW003NizN+Y39vM2ZDJ7bnxMfuAxYYOOj4n+mBR28xw/JtP27Qpbf3xMfuAxYZ/w2Y/JTNBSYZ/QVTiF4XylcE5UeWwpokaeDUXUyLOd+FqRn6fC2SFEjbzxpl+7+jD2EL+L/Jf7r8a7Ua3E9/tPg/u33SZJW7w+w1stg/u3Xb/r97+8YC3vH10+PNFv9//1jsTcHWVzd1TM3dFy7VTS9Z2QfYdvcEfN3B11a3fUlv969HRVMr3L4I7u/B7I9WXsUOXjHX1dFU+tGue+mK4/WbHIsfW7e7ZLOg4ptndtVkdiK7eLfCrhg4yLI61V8kXj1PCuW/roLloMlxi0mD98O9s2uLp2uVxd+wf1NL465XIN7/ujEGUU3P1GrzL1w6MwvHjXcOVdw2Xl4u36yWEr7ePFXyMpjKSTSObVkSzXga0WmxLJsG3vd5/acSxL3y65bq/flMqqxWv902KJN3VKK/TL0C+Vfhn6pdEvQ790+mXkl77RL0O/BPpl6JdIvwz9kuiXoV+Efhn6hXp37Bfq3bFfqHfHfqHeHfuFenfkl7pR7479Qr079gv17tgv1Ltjvwj9MvQL9e7YL9S7Y79Q7479Qr079gv17tAvgXp37Bfq3bFfqHfHfqHeHftF6JehX6h3x36h3h37hXp37Bfq3bFf/OjdGuXyTl39eNMXU6MfCaua6keVqqb6EZo19svFNYWBqX60o2qq4JjqR+GppvoRbaqpfnSYmoH9SCvVVBy1lDyppePvavKklhRTcdRSwlFLSXBMxVFLCUctJRy1lHDUUsJRS4LTWxKc3pLgqCXBUUuCo5YERy0JjloST2pJMdWTWlJM9aSWjk3NOL2ljKOWsie1pJjqSS0ppgqOqZ7UkmIqjlrKOGop46iljKOWCo5aKjg7cQWnt1RweksFp7dUcNRS8aSWFFNxduIKzk5cwdmJqzhqqeKopYqjliqOWqo4aqni7MRVnN5SxektVZzeUsVRSw3nvaWGsxPXcHbiGs5O3PpDKp6WgR2d4qCaiqOWHJ21oJqKo5YcnYigmerokAPVVJzekqOjCFRTcdSSowMDVFNxduIcYf1VU3F24hzB99UMDKOWmiNEvmoqjFpqjkD2qqkwO3FtExxTYXpLzREUXjUVRi01R+h21VSYnbjmCLCumgqzE9ccYdC1DOyIbK6aKjim4qglR0hx1VSYnbjmCPytmorTW3LF8lZMxVFLrljeiqkwO3HNFctbMRVmJ67hsLybK5a3YiqOWnLF8j42FYfl3XBY3g2H5d1wWN4Nh+XdXLG8j9WSK5a3YirOThwOy7vhsLybK5b3cQZ2xfJWTMVRSzgs74bD8m44LO+Gw/JuOCzvhsPybq5Y3sdqyRXLWzEVZycOh+XdcFjezRXL+zgDu2J5K6biqCUclnfDYXk3HJZ3w2F5NxyWd8NheTdXLO9jteSK5a2YirMTh8Pybjgs7+aK5a1kYBy1hMPybjgs74bD8m44LO+Gw/JuOCzvhsPybq5Y3sdqyRXLWzEVZycOh+XdcFjezRXL+zgDu2J5K6YKjqk4agmH5d1wWN4Nh+XdcFjeDYfl3VyxvI/VkiuWt2Iqzk4cDsu74bC8myuWt5KBcdQSDsu74bC8Ow7Lu+OwvDsOy7vjsLz7Jjimwqil7orlrZgKsxPXcVjeHYfl3V2xvI8zsCuWt2IqjlrCYXl3HJZ3x2F5dxyWd8dheXcclnd3xfI+VkuuWN6KqTA7cR2H5d1xWN7dFcv7OAO7YnkrpuKoJRyWd8dheXcclnfHYXl3HJZ3x2F5d1cs72O15IrlrZiKsxOHw/LuOCzv7orlrWRgHLWEw/LuOCzvjsPy7jgs747D8u44LO+Ow/Lurljex2rJFctbMRVnJw6H5d1xWN7dFcv7OAO7YnkrpgqOqThqCYfl3XFY3h2H5d1xWN4dh+XdXbG8j9WSK5a3YirOThwOy7vjsLy7K5a3koFx1BIOy7vjsLw7Dsu747C8Ow7Lu+OwvDsOy7u7YnkfqyVXLG/FVJydOByWd8dheXdXLO/jDOyK5a2YiqOWcFjeHYfl3XFY3h2H5d1xWN4dh+XdXbG8j9WSK5a3YirOThwOy7vjsLy7K5b3cQZ2xfJWTMVRSzgs747D8u4wLO+4wbC8d1NReku7qSi9pd1UFLW0myo4pqLsxO2mouzE7aai7MTtpqKopd1UHLUEw/LeTcVRSzAs791UlJ243VTBMRWlt7SbitJb2k3FUUuuWN6KqSg7cXGDYXnvpqLsxO2m4qglVyxvxVTBMRVHLcGwvHdTUXbidlNxekswLO+4wbC8d1Nx1JIrlrdiKs5OHAzLezcVZyfOFctbycA4agmG5b2biqOWYFjeu6k4O3EwLO/dVJzeEgzLezcVRy25YnkrpuLsxMGwvHdTcXbiXLG8jzOwK5a3YiqOWoJhee+mCo6pODtxMCzv3VSc3hIMy3s3FUctuWJ5K6bi7MTBsLx3U3F24lyxvI8zsCuWt2IqjlqCYXnvpuKoJRiWd9xgWN67qTi9JRiW924qjlpyxfJWTMXZiYNhee+m4uzEuWJ5KxkYRy3BsLx3U3HUEgzLezcVZycOhuW9m4rTW4Jhee+m4qglVyxvxVScnTgYlvduKs5OnCuW93EGdsXyVkwVHFNx1BIMy3s3FWcnDoblvZsK01sKOCzv4IrlfaiWgiuWt2IqzE5c2ATHVJiduOCK5a1kYBi1FHBY3gGH5R1wWN4Bh+UdcFjeAYflHXBY3sEVy/tYLblieSumwuzEBRyWd8BheQdXLO/jDIzD8g6uWN6KqTi9JVcsb8VUHLWEw/IOrljeSlRx1JIrlvexqa5Y3oqpOGrJFcv7OAO7YnkrpgqOqTDvLQVPLG+J+WKqxHprqnG1VOvV1F6PTS19C98uLj18Z+rtxS2KXG+jxFu/GJdWT/OLcR32LL9YR4o/zS/GFd7T/GJcDj7NL8a149P8IvTL0C/GVenT/GJcwj7NL9S7Y79Q7479Qr079It1KPzT/EK9O/YL9e7YL9S7Y78I/TL0C/Xu2C/Uu2O/UO+O/UK9O/YL9e7QL9ax/k/zC/Xu2C/Uu2O/UO+O/SL0y9Av1Ltjv1Dvjv1CvTv2C/Xu2C/Uu0O/WD+Y4Wl+8aN3tTdWrZ/iMNNUP6pUNVUcmXr8Gqf1UxxmmupHDqqm+lF4qql+RJtqqh8dpmVg66c4zDQVRy1ZP8Vh4nfV+ikOM00VHFNx1JL1Uxxmmoqjlqyf4jDTVBy1ZP0Uh5mm4qgl66c4zDQVp7dk/RSHiRnY+ikOM03FUUvWT3GYaSqOWrJ+isM8U6P1UxxmmupJLSmmwvSWovVTHOappbgJjqme1JJiqie1pJjqSS0ppsKopWj9FIeJplo/xWGmqThqyfopDjNNhdmJi9ZPcZhpKkxvKVo/xWGmqThqyfopDjNNhdmJi9ZPcZhpKsxOXLR+isPEDGz9FIeZpgqOqThqyfopDjNNhdmJi9ZPcZhpKk5vyfopDjNNxVFL1k9xmGkqzk6c9VMcZpqKsxNn/RSHmRkYRy05OphBNRVHLTk6PkE1FWcnztEhB6qpOL0lR0cRqKbiqCVHBwaopuLsxDnC+qum4uzEOYLvaxnYEU9fNRVHLTmi3qumCo6pODtxjnDzqqk4vSVHUHjVVBy15AjdrpqKsxPnCLCumoqzE+cIg65lYEdkc9VUHLXkiD+umoqjlhxRwjVTHYG/VVNxekuuWN6KqThqyRXLWzEVZyfOFctbMRVnJw6H5R1dsbyPTXXF8lZMxVFLOCzviMPyjjgs74jD8o44LO/oiuV9rJZcsbwVU3F24nBY3hGH5R1dsbyPM7ArlrdiquCYiqOWcFjeEYflHXFY3hGH5Z1wWN7JFcv7UC0lVyxvxVSYnbi0CY6pMDtxyRXLW8nAMGop4bC8Ew7LO+GwvBMOyzvhsLwTDss74bC8kyuW97FacsXyVkyF2YlLOCzvhMPyTq5Y3scZ2BXLWzEVRy3hsLwTDss74bC8Ew7LO+GwvBMOyzu5YnkfqyVXLG/FVJydOByWd8JheSdXLO/jDOyK5a2YiqOWcFjeCYflnXBY3gmH5Z1wWN4Jh+WdXLG8j9WSK5a3YirOThwOyzvhsLyTK5a3koFx1BIOyzvhsLwTDss74bC8Ew7LO+GwvBMOyzu5YnkfqyVXLG/FVJydOByWd8JheSdXLO/jDOyK5a2YKjim4qglHJZ3wmF5JxyWd8JheScclndyxfI+VkuuWN6KqTg7cTgs74TD8k6uWN5KBsZRSzgs74TD8k44LO+Ew/JOOCzvhMPyTjgs7+SK5X2sllyxvBVTcXbicFjeCYflnVyxvI8zsCuWt2IqjlrCYXknHJZ3wmF5JxyWd8JheScclndyxfI+VEviiuWtmAqzEyc4LG/BYXnLJigZWFyxvBVTYdSS4LC8BYflLTgsb8FheQsOy1twWN7iiuV9rJZcsbwVU2F24gSH5S04LG9xxfJWMjCOWsJheQsOy1twWN6Cw/IWHJa34LC8BYflLa5Y3sdqyRXLWzEVZycOh+UtOCxvccXyPs7ArljeiqmCYyqOWsJheQsOy1twWN6Cw/IWHJa3uGJ5H6slVyxvxVScnTgclrfgsLzFFctbycA4agmH5S04LG/BYXkLDstbcFjegsPyFhyWt7hieR+rJVcsb8VUnJ04HJa34LC8xRXL+zgDu2J5K6biqCUclrfgsLwFh+UtOCxvwWF5Cw7LW1yxvI/VkiuWt2Iqzk4cDstbcFje4orlfZyBXbG8FVNx1BIOy1twWN6Cw/IWHJa34LC8BYflLa5Y3sdqyRXLWzEVZycOh+UtOCxvccXyVjIwjlrCYXkLDstbcFjegsPyFhyWt+CwvAWH5S2uWN7HaskVy1sxFWYnLuOwvDMOyzu7YnkfZuDsiuWtmCo4psKopYzD8s44LO+Mw/LOOCzvjMPyzq5Y3sdqyRXLWzEVZicu47C8Mw7LO7tieSsZGEct4bC8Mw7LO+OwvDMOyzvjsLwzDss747C8syuW97FacsXyVkyF2YnLOCzvjMPyzq5Y3scZ2BXLWzEVRy3hsLwzDss747C8Mw7LO+OwvDMOyzu7YnkfqyVXLG/FVJydOByWd8ZheWdXLO/jDOyK5a2YiqOWcFjeGYflnXFY3hmH5Z1xWN4Zh+WdXbG8j9WSK5a3YirOThwOyzvjsLyzK5a3koFx1BIOyzvjsLwzDss747C8Mw7LO+OwvDMOyzu7YnkfqyVXLG/FVJydOByWd8ZheWdXLO/jDIzD8s6uWN6KqTi9JVcsb8VUHLWEw/LOrljex1F1xfJWTMVRS65Y3oqpOGrJFcv7OAO7YnkrpuL0llyxvBVTHaklifliqsR6a6pttRTS1dRQ+rGppW/h28Wlh+9Mvb24RZHrbZR44xfj4O/n+cW2DnueX2yLtuf5xbbCe55fhH4Z+sW2dnyeX2wLzef5xbYqfZ5fbEvY5/mFenfkl2Ic3f48v1Dvjv1CvTv2C/Xu2C9Cvwz9Qr079gv17tgv1Ltjv1Dvjv1CvTv0i3H4/vP8Qr079gv17tgv1Ltjvwj9MvQL9e7YL9S7Y79Q7479Qr079gv17tAvxo9PeJ5fqHfHfqHeHfvFj95V3lgtxk9xmGqqH1WqmupHaCqvcRbjpzhMNdWPHFRN9aPwNFONn+Iw1VQ/OkzLwMZPcZhqKo5aMn6Kw9Tvqie1pJiKo5aMn+Iw1VQctWT8FIeZpho/xWGqqThqyfgpDlNNxVFLxk9xmGoqTm/J+CkOUzMwjloyforDVFNx1JLxUxymmupJLSmmelJLiqme1JJiquCYiqOWjJ/iMNVUT2pJMdWTWlJM9aSWjk01forDzAxs/BSHqabiqCXjpzhMNVVwTMXZiTN+isNUU3F6S8ZPcZhqKo5aMn6Kw1RTcXbijJ/iMNVUnJ0446c4zMzAxk9xmGoqjloyforDVFNx1JLxUxxmmmr8FIeppuL0loyf4jDVVBy1ZPwUh6mm4uzEGT/FYaqpODtxxk9xmJqBcdSSo4MZVFNx1JKj4xNUU3F24hwdcqCaitNbcnQUgWoqjlpydGCAairMTlx1hPVXTYXZiauO4PtKBq6OePqqqYJjKoxaqo5A9qqpMDtx1RFuXjUVprdUHUHhVVNx1JIjdLtqKsxOXHUEWFdNhdmJq44w6GoGxlFLjmDlqqk4askRUlw1FWYnrjoCf6um4vSWXLG8FVNx1JIrlrdiKsxOXHXF8lZMxdmJw2F5V1csb8VUHLXkiuWtmCo4puLsxOGwvCsOy7visLyrK5b3sVpyxfJWTMXZicNheVcclnd1xfI+zsCuWN6KqThqCYflXXFY3hWH5V1xWN4Vh+VdcVje1RXL+1gtuWJ5K6bi7MThsLwrDsu7umJ5KxkYRy3hsLwrDsu74rC8Kw7Lu+KwvCsOy7visLyrK5b3sVpyxfJWTMXZicNheVcclnd1xfI+zsCuWN6KqYJjKo5awmF5VxyWd8VheVcclnfFYXlXVyzvY7XkiuWtmIqzE4fD8q44LO/qiuWtZGActYTD8q44LO+Kw/KuOCzvisPyrjgs74rD8q6uWN7HaskVy1sxFWcnDoflXXFY3s0Vy/swAzdXLG/FVBi11HBY3m0THFNhduIaDsu74bC8Gw7Lu7lieR+rJVcsb8VUmJ24hsPybjgs7+aK5X2cgV2xvBVTcdQSDsu74bC8Gw7Lu+GwvBsOy7vhsLybK5b3sVpyxfJWTIXZiWs4LO+Gw/JurljeSgbGUUs4LO+Gw/JuOCzvhsPybjgs74bD8m44LO/miuV9rJZcsbwVU3F24nBY3g2H5d1csbyPM7ArlrdiquCYiqOWcFjeDYfl3XBY3g2H5d1wWN7NFcv7WC25YnkrpuLsxOGwvBsOy7u5YnkrGRhHLeGwvBsOy7vhsLwbDsu74bC8Gw7Lu+GwvJsrlvexWnLF8lZMxdmJw2F5NxyWd3PF8j7OwK5Y3oqpOGoJh+XdcFjeDYfl3XBY3g2H5d1wWN7NFcv7WC25YnkrpuLsxOGwvBsOy7u5YnkfZ2BXLG/FVBy1hMPybjgs74bD8m44LO+Gw/JuOCzv5orlfayWXLG8FVNxduJwWN4Nh+XdXLG8lQwMo5Y6Dsu747C8Ow7Lu+OwvPsmOKbC9JY6Dsu7u2J5H6ql7orlrZgKsxPXcVjeHYfl3V2xvI8zsCuWt2Kq4JiKo5ZwWN4dh+XdcVjeHYfl3XFY3t0Vy/tYLblieSumwuzEdRyWd8dheXdXLG8lA+OoJRyWd8dheXcclnfHYXl3HJZ3x2F5dxyWd3fF8j5WS65Y3oqpODtxOCzvjsPy7q5Y3scZ2BXLWzEVRy3hsLw7Dsu747C8Ow7Lu+OwvDsOy7u7YnkfqyVXLG/FVJydOByWd8dheXdXLO/jDOyK5a2YiqOWcFjeHYfl3XFY3h2H5d1xWN4dh+XdXbG8j9WSK5a3YirOThwOy7vjsLy7K5a3koFx1BIOy7vjsLw7Dsu747C8Ow7Lu+OwvDsOy7u7YnkfqyVXLG/FVJydOByWd8dheXdXLO/jDOyK5a2YKjim4qglHJZ3x2F5dxyWd8dheXcclnd3xfI+VkuuWN6KqTg7cTgs747D8u6uWN5KBsZRSzgs7w7D8t5vEkUt7TeJshO33yRKb2m/SZTe0n6TgmMqilp6u0kcU1F24vabRNmJ228SZScuba5Y3scZ2BXLWzEVRy3BsLx3UwXHVJSduN1UlN7SbipKb2k3FaW3tJuKo5ZcsbwVU1F24nZTUXbidlNRduJ2UwUmA8OwvHdTcXpLrljeiqk4vSVXLO9jU2FY3rupOGrJFctbMRVHLblieSum4qglVyxvJQPj9JZcsbwVU3HeW/LE8paYL6ZKrLem2lZLcbuaut/Isamlb+HbxaWH70y9vbhFkettlHjrF9vS6nl+sa3DnucXoV+GfrGt8J7nF9ty8Hl+sa0dn+cX20LzeX6xrUqf5hfjgPXn+YV6d+wX6t2xX6h3x34R+mXoF+rdsV+od8d+od4d+4V6d+wX6t2hX4wj8p/nF+rdsV+od8d+od4d+0Xol6FfqHfHfqHeHfuFenfsF+rdsV+od4d+MX7IwfP8Qr079gv17tgv1Ltjvwj9MvSLH72rvbFq/BSHqab6UaWqqX6EpvYap/FTHGaaavwUh6mm+lF4qql+RJtqqh8dpmVg46c4TDUVRy0ZP8Vh6nfVk1pSTMVRS8ZPcZhpqvFTHKaaiqOWjJ/iMNVUHLVk/BSHqabiqCXjpzhMNRWnt2T8FIepGRhGLQXjpzhMNRVGLQXjpzhMNdWTWlJMFRxTPaklxVSY3lIwforDRLUUjJ/iMNVUT2rp2FTjpzhMNdWTWlJMxVFLxk9xmGqq4JiKo5aMn+Iw1VSYnbhg/BSHqabi9JaMn+Iw1VQctWT8FIeppsLsxAXjpzhMNRVmJy4YP8VhagbGUUvGT3GYaiqOWjJ+isNUU3F24oyf4jDVVJzekvFTHKaaiqOWjJ/iMNVUnJ0446c4TDUVZyfO+CkOMzOwo1McVFNx1JKjsxZUUwXHVJydOEeHHKim4vSWHB1FoJqKo5YcHRigmoqzE+cI66+airMT5wi+r2VgRzx91VQcteSIeq+aiqOWHLHpNVMd4eZVU3F6S46g8KqpOGrJEbpdNRVnJ84RYF01FWcnzhEGXc3AOGrJEaxcNRVHLTlCiqum4uzEOQJ/q6bi9JZcsbwVU3HUkiuWt2Iqzk6cK5a3YirOThwOyzu4YnkrpgqOqThqCYflHXBY3gGH5R1wWN4Bh+UdXLG8j9WSK5a3YirOThwOyzvgsLyDK5a3koFx1BIOyzvgsLwjDss74rC8Iw7LO+KwvOMmOKbCqKXoiuWtmAqzExdxWN4Rh+UdXbG8jzOwK5a3YiqOWsJheUcclnfEYXlHHJZ3xGF5RxyWd3TF8j5WS65Y3oqpMDtxEYflHXFY3tEVy/s4A7tieSum4qglHJZ3xGF5RxyWd8RheUcclnfEYXlHVyzvY7XkiuWtmIqzE4fD8o44LO/oiuWtZGActYTD8o44LO+Iw/KOOCzviMPyjjgs74jD8o6uWN7HaskVy1sxFWcnDoflHXFY3tEVy/s4A7tieSumCo6pOGoJh+UdcVjeEYflHXFY3hGH5R1dsbyP1ZIrlrdiKs5OHA7LO+KwvKMrlreSgXHUEg7LO+KwvCMOyzvisLwjDss74rC8Iw7LO7pieR+rJVcsb8VUnJ04HJZ3xGF5R1cs7+MM7IrlrZiKo5ZwWN4Rh+UdcVjeEYflHXFY3hGH5R1dsbyP1ZIrlrdiKs5OHA7LO+KwvKMrlvdxBnbF8lZMxVFLOCzviMPyjjgs74TD8k44LO+Ew/JOrljeh2opbYJjKsxOXMJheScclndyxfJWMjCOWsJheScclnfCYXknHJZ3wmF5JxyWd8JheSdXLO9jteSK5a2YCrMTl3BY3gmH5Z1csbyPM7ArlrdiquCYiqOWcFjeCYflnXBY3gmH5Z1wWN7JFcv7WC25YnkrpuLsxOGwvBMOyzu5YnkrGRhHLeGwvBMOyzvhsLwTDss74bC8Ew7LO+GwvJMrlvexWnLF8lZMxdmJw2F5JxyWd3LF8j7OwK5Y3oqpOGoJh+WdcFjeCYflnXBY3gmH5Z1wWN7JFcv7WC25YnkrpuLsxOGwvBMOyzu5YnkfZ2BXLG/FVBy1hMPyTjgs74TD8k44LO+Ew/JOOCzv5IrlfayWXLG8FVNxduJwWN4Jh+WdXLG8lQyMo5ZwWN4Jh+WdcFjeCYflnXBY3gmH5Z1wWN7JFcv7WC25YnkrpuLsxOGwvBMOyzu5YnkfZ2BXLG/FVMExFUct4bC8Ew7LO+GwvBMOy1twWN7iiuV9qJbEFctbMRVmJ042wTEVZidOXLG8lQwMo5YEh+UtOCxvwWF5Cw7LW3BY3oLD8hYclre4YnkfqyVXLG/FVJidOMFheQsOy1tcsbyPM7ArlrdiKo5awmF5Cw7LW3BY3oLD8hYclrfgsLzFFcv7WC25YnkrpuLsxOGwvAWH5S2uWN7HGdgVy1sxFUct4bC8BYflLTgsb8FheQsOy1twWN7iiuV9rJZcsbwVU3F24nBY3oLD8hZXLG8lA+OoJRyWt+CwvAWH5S04LG/BYXkLDstbcFje4orlfayWXLG8FVNxduJwWN6Cw/IWVyzv4wzsiuWtmCo4puKoJRyWt+CwvAWH5S04LG/BYXmLK5b3sVpyxfJWTMXZicNheQsOy1tcsbyVDIzTW3LF8lZMxektuWJ5K6biqCUclre4YnkrURUcU3HUkiuWt2IqjlpyxfJWMjBOb8kVy1sxFee9JU8sb4n5YqrEemuqcbVU5GpqS8emlr6FbxeXHr4z9fbiFkWut1HirV+Efhn6xbgOe5pfjIu2p/nFuMJ7ml+My8Gn+cW4dnySX7J1DPrT/GJclT7NL8Yl7NP8Qr079ovQL0O/UO+O/UK9O/YL9e7YL9S7Y79Q7w79Yh1k/zS/UO+O/UK9O/YL9e7YL0K/DP1CvTv2C/Xu2C/Uu2O/UO+O/UK9O/SL9aMInuYX6t2xX6h3x36h3h37ReiXoV+od8d+od4d+8WP3lXeWM3WT3GYaaofVaqZav0Uh0+ZevgaZ7Z+isNMU/3IQdVUPwpPNVVwTPWjw9QM7EdaqabiqCXrpzjM/K56UkvHplo/xWGmqThqyfopDjNNxVFL1k9xmGkqjlqyforDTFNx1JL1UxxmmorTW7J+isPEDGz9FIeZpuKoJeunOMw0VXBM9aSWFFM9qSXFVE9qSTEVp7dk/RSHiWrJ+ikOM031pJYUUz2pJcVUT2pJMVVgMrD1Uxxmmoqjlqyf4jDTVBy1ZP0Uh4mmWj/FYaapOL0l66c4zDQVRy1ZP8Vhpqk4O3HWT3GYaSrOTpz1UxxmZmActWT9FIeZpuKoJeunOMw0FWcnzvopDjNNxektWT/FYaapOGrJ+ikOM03F2YmzforDTFNxduKsn+IwMQM7OsVBNVVwTMVRS46OT1BNxdmJc3TIgWoqTG+pODqKQDUVRi0VRwcGqKbC7MSVTXBMhdmJK47g+2oGhlFLxREiXzUVRy05AtmrpsLsxBVHuHnVVJjeUnEEhVdNxVFLjtDtqqkwO3HFEWBdNRVmJ644wqBrGdgR2Vw1FUctOeKPq6YKjqkwO3HFEfhbNRWnt+SK5a2YiqOWXLG8FVNxduJcsbwVU3F24nBY3sUVy1sxFUctuWJ5K6biqCUclnfBYXkXHJZ3wWF5F1cs72O15IrlrZiKsxOHw/IuOCzv4orlrWRgHLWEw/IuOCzvgsPyLjgs74LD8i44LO+Cw/Iurljex2rJFctbMRVnJw6H5V1wWN7FFcv7OAO7YnkrpgqOqThqCYflXXBY3gWH5V1wWN4Fh+VdXLG8j9WSK5a3YirOThwOy7vgsLyLK5a3koFx1BIOy7vgsLwLDsu74LC8Cw7Lu+CwvAsOy7u4YnkfqyVXLG/FVJydOByWd8FheRdXLO/jDOyK5a2YiqOWcFjeBYflXXBY3gWH5V1wWN4Fh+VdXLG8D9VSdcXyVkyF2YmrOCzvisPyrpugZODqiuWtmAqjlioOy7visLwrDsu74rC8Kw7Lu+KwvKsrlvexWnLF8lZMhdmJqzgs74rD8q6uWN5KBsZRSzgs74rD8q44LO+Kw/KuOCzvisPyrjgs7+qK5X2sllyxvBVTcXbicFjeFYflXV2xvI8zsCuWt2Kq4JiKo5ZwWN4Vh+VdcVjeFYflXXFY3tUVy/tYLblieSum4uzE4bC8Kw7Lu7pieSsZGEct4bC8Kw7Lu+KwvCsOy7visLwrDsu74rC8qyuW97FacsXyVkzF2YnDYXlXHJZ3dcXyPs7Arljeiqk4agmH5V1xWN4Vh+VdcVjeFYflXXFY3tUVy/tYLblieSum4uzE4bC8Kw7Lu7pieR9nYFcsb8VUHLWEw/KuOCzvisPyrjgs74rD8q44LO/qiuV9rJZcsbwVU3F24nBY3hWH5V1dsbyVDIyjlnBY3hWH5V1xWN4Vh+VdcVjeFYflXXFY3tUVy/tYLblieSumwuzENRyWd8NheTdXLO/DDNxcsbwVUwXHVBi11HBY3g2H5d1wWN4Nh+XdcFjezRXL+1gtuWJ5K6bC7MQ1HJZ3w2F5N1csbyUD46glHJZ3w2F5NxyWd8NheTcclnfDYXk3HJZ3c8XyPlZLrljeiqkwO3ENh+XdcFjezRXL+zgDu2J5K6biqCUclnfDYXk3HJZ3w2F5NxyWd8NheTdXLO9jteSK5a2YirMTh8Pybjgs7+aK5X2cgV2xvBVTcdQSDsu74bC8Gw7Lu+GwvBsOy7vhsLybK5b3sVpyxfJWTMXZicNheTcclndzxfJWMjCOWsJheTcclnfDYXk3HJZ3w2F5NxyWd8NheTdXLO9jteSK5a2YirMTh8Pybjgs7+aK5X2cgV2xvBVTBcdUHLWEw/JuOCzvhsPybjgs74bD8m6uWN7HaskVy1sxFWcnDofl3XBY3s0Vy1vJwDhqCYfl3XBY3g2H5d1wWN4Nh+XdcFjeDYfl3VyxvI/VkiuWt2Iqzk4cDsu74bC8uyuW92EG7q5Y3oqpMGqp47C8+yY4psLsxHUclnfHYXl3HJZ3d8XyPlZLrljeiqkwO3Edh+XdcVje3RXL+zgDu2J5K6biqCUclnfHYXl3HJZ3x2F5dxyWd8dheXdXLO9jteSK5a2YCrMT13FY3h2H5d1dsbyVDIzTW3LF8lZMxektuWJ5K6biqCUclnd3xfJWooqjllyxvBVTYd5b6jgs7+6K5X2cgV2xvBVTcXpLrljeiqnix1SJ+WKqxHprqm21lK53H5K0Y1NL38K3i8u+F/XR1NuLWxS53kaJt36xLa2e5xfbOux5frEt2p7nF9sK72l+MQ4rf55fbGvH5/nFttB8nl9sq9Ln+UXol6FfqHfHfqHeHfuFenfsF+rdsV+od4d+MY6bf55fqHfHfqHeHfuFenfsF6Ffhn6h3h37hXp37Bfq3bFfqHfHfqHeHfrF+IEBz/ML9e7YL9S7Y79Q7479IvTL0C/Uu2O/UO+O/UK9O/YL9e7YL370rvbGqvFTHKaa6keVqqb6EZraa5zGT3GYaqrgmOpH4amm+hFtqql+dJiagf1IK9VUHLVk/BSHmd9V46c4TDUVRy0ZP8VhqqmCYyqOWjJ+isNUU3HUkvFTHKaaiqKWZDN+isNUU1F6S7upKGppNxVFLe2mCo6pKGppNxVFLe2melJLiqme1JJiqie1dGyq8VMcppqKo5aMn+Iw1VRPakkxVXBM9aSWFFNx1JLxUxymmoqjloyf4jDTVOOnOEw1FWUnbjcVp7dk/BSHqaYKjqk4asn4KQ5TTUXZidtNRdmJ203F2YkzforDzAxs/BSHqabiqCXjpzhMNVVwTMXZiTN+isNUU3F6S8ZPcZhqKo5aMn6Kw1RTcXbijJ/iMNVUnJ0446c4zMzAjk5xUE3FUUuOzlpQTcVRS45ORNBMdXTIgWoqTm/J0VEEqqk4asnRgQGqqTg7cY6w/qqpODtxjuD7agbGUUuOEPmqqThqyRHIXjUVZyfOEW5eNRWnt+QICq+aiqOWHKHbVVNxduIcAdZVU3F24hxh0LUM7IhsrpoqOKbiqCVHSHHVVJydOEfgb9VUnN6SK5a3YiqOWnLF8lZMxdmJc8XyVkzF2YmDYXnvpuKoJVcsb8VUHLUEw/LeTcXZiYNhee+m4vSWYFjeu6k4askVy1sxFWcnDoblvZsKsxMXXLG8DzNwcMXyVkyFUUsBh+UdNsExFWYnLuCwvAMOyzvgsLyDK5b3sVpyxfJWTIXZiQs4LO+Aw/IOrljexxnYFctbMRVHLeGwvAMOyzvgsLwDDss74LC8Aw7LO7hieR+rJVcsb8VUmJ24gMPyDjgs7+CK5a1kYBy1hMPyDjgs74DD8g44LO+Aw/IOOCzvgMPyDq5Y3sdqyRXLWzEVZycOh+UdcFjewRXL+zgDu2J5K6YKjqk4agmH5R1wWN4Bh+UdcFjeAYflHVyxvI/VkiuWt2Iqzk4cDss74LC8gyuWt5KBcdQSDss74LC8Aw7LO+CwvAMOyzvgsLwDDss7uGJ5H6slVyxvxVScnTgclnfAYXkHVyzv4wzsiuWtmIqjlnBY3gGH5R1wWN4Bh+UdcFjeAYflHVyxvI/VkiuWt2Iqzk4cDss74LC8gyuW93EGdsXyVkzFUUs4LO+Aw/IOOCzvgMPyDjgs74DD8g6uWN7HaskVy1sxFWcnDoflHXBY3sEVy1vJwDBqKeKwvCMOyzvisLwjDss7boJjKkxvKeKwvKMrlvehWoquWN6KqTA7cRGH5R1xWN7RFcv7OAO7YnkrpgqOqThqCYflHXFY3hGH5R1xWN4Rh+UdXbG8j9WSK5a3YirMTlzEYXlHHJZ3dMXyVjIwjlrCYXlHHJZ3xGF5RxyWd8RheUcclnfEYXlHVyzvY7XkiuWtmIqzE4fD8o44LO/oiuV9nIFdsbwVU3HUEg7LO+KwvCMOyzvisLwjDss74rC8oyuW97FacsXyVkzF2YnDYXlHHJZ3dMXyPs7Arljeiqk4agmH5R1xWN4Rh+UdcVjeEYflHXFY3tEVy/tYLblieSum4uzE4bC8Iw7LO7pieSsZGEct4bC8Iw7LO+KwvCMOyzvisLwjDss74rC8oyuW97FacsXyVkzF2YnDYXlHHJZ3dMXyPs7ArljeiqmCYyqOWsJheUcclnfEYXlHHJZ3xGF5R1cs72O15IrlrZiKsxOHw/KOOCzv6IrlrWRgHLWEw/KOOCzvhMPyTjgs74TD8k44LO+0CY6pMGopuWJ5K6bC7MQlHJZ3wmF5J1cs7+MM7IrlrZiKo5ZwWN4Jh+WdcFjeCYflnXBY3gmH5Z1csbyP1ZIrlrdiKsxOXMJheScclndyxfI+zsCuWN6KqThqCYflnXBY3gmH5Z1wWN4Jh+WdcFjeyRXL+1gtuWJ5K6bi7MThsLwTDss7uWJ5KxkYRy3hsLwTDss74bC8Ew7LO+GwvBMOyzvhsLyTK5b3sVpyxfJWTMXZicNheScclndyxfI+zsCuWN6KqYJjKo5awmF5JxyWd8JheScclnfCYXknVyzvY7XkiuWtmIqzE4fD8k44LO/kiuWtZGActYTD8k44LO+Ew/JOOCzvhMPyTjgs74TD8k6uWN7HaskVy1sxFWcnDoflnXBY3skVy/s4A+OwvJMrlrdiKk5vyRXLWzEVRy3hsLyTK5a3ElUcteSK5X1sqiuWt2IqjlpyxfI+zsCuWN6KqYJjKs57S55Y3nK9eP/PemuqcbXULoEKEsKxqaVv4dvFpYfvTL29uEWR622UeOsX49LqaX4xrsOe5BexjhR/ml+MK7yn+cW4HHyaX4xrx6f5ReiXoV+Mq9Kn+cW4hH2aX6h3x36h3h37hXp36BfrUPin+YV6d+wX6t2xX6h3x34R+mXoF+rdsV+od8d+od4d+4V6d+wX6t2hX6xj/Z/mF+rdsV+od8d+od4d+0Xol6FfqHfHfqHeHfuFenfsF+rdsV+od4d+sX4ww9P84kfvKm+sivVTHGaa6keVqqaKI1MPX+MU66c4zDTVjxxUTfWj8FRT/Yg21VQ/OkzLwNZPcZhpKo5asn6Kw8TvqvVTHGaaKjim4qgl66c4zDQVRy1ZP8Vhpqk4asn6KQ4zTcVRS9ZPcZhpKk5vyfopDhMzsPVTHGaaiqOWrJ/iMNNUHLVk/RSHiaZaP8Vhpqme1JJiKk5vyfopDhPVkvVTHGaa6kktKaZ6UkuKqZ7UkmIqjlqyforDRFOtn+Iw01QctWT9FIeZpuLsxFk/xWGmqTi9JeunOMw0FUctWT/FYaapODtx1k9xmGkqzk6c9VMcJmZg66c4zDRVcEzFUUvWT3GYaSrOTpz1UxxmmorTW7J+isNMU3HUkvVTHGaairMTZ/0Uh5mm4uzEWT/FYWYGxlFLjg5mUE2FUUvZ0fEJqqkwO3HZ0SEHqqkwvaW8CY6pMGopOzowQDUVZicuO8L6q6bC7MRlR/B9LQM74umrpuKoJUfUe9VUwTEVZicuO8LNq6bC9JayIyi8aiqOWnKEbldNhdmJy44A66qpMDtx2REGXcvAjsjmqqk4askRf1w1FUctOaKEa6Y6An+rpuL0llyxvBVTcdSSK5a3YirOTpwrlrdiKs5OHA7LO7tieR+b6orlrZiKo5ZwWN4Zh+WdcVjeGYflnXFY3tkVy/tYLblieSum4uzE4bC8Mw7LO7tieR9nYFcsb8VUwTEVRy3hsLwzDss747C8Mw7LO+OwvLMrlvexWnLF8lZMxdmJw2F5ZxyWd3bF8lYyMI5awmF5ZxyWd8ZheWcclnfGYXlnHJZ3xmF5Z1cs72O15IrlrZiKsxOHw/LOOCzv7IrlfZyBXbG8FVNx1BIOyzvjsLwzDss747C8Mw7LO+OwvLMrlvexWnLF8lZMxdmJw2F5ZxyWd3bF8j7OwK5Y3oqpOGoJh+WdcVjeGYflXXBY3gWH5V1wWN7FFcv7UC2VTXBMhdmJKzgs74LD8i6uWN5KBsZRSzgs74LD8i44LO+Cw/IuOCzvgsPyLjgs7+KK5X2sllyxvBVTYXbiCg7Lu+CwvIsrlvdxBnbF8lZMFRxTcdQSDsu74LC8Cw7Lu+CwvAsOy7u4YnkfqyVXLG/FVJydOByWd8FheRdXLG8lA+OoJRyWd8FheRcclnfBYXkXHJZ3wWF5FxyWd3HF8j5WS65Y3oqpODtxOCzvgsPyLq5Y3scZ2BXLWzEVRy3hsLwLDsu74LC8Cw7Lu+CwvAsOy7u4YnkfqyVXLG/FVJydOByWd8FheRdXLO/jDOyK5a2YiqOWcFjeBYflXXBY3gWH5V1wWN4Fh+VdXLG8j9WSK5a3YirOThwOy7vgsLyLK5a3koFx1BIOy7vgsLwLDsu74LC8Cw7Lu+CwvAsOy7u4YnkfqyVXLG/FVJydOByWd8FheRdXLO/jDOyK5a2YKjim4qglHJZ3wWF5FxyWd8FheVcclnd1xfI+VEvVFctbMRVmJ65ugmMqzE5cdcXyVjIwjFqqOCzvisPyrjgs74rD8q44LO+Kw/KuOCzv6orlfayWXLG8FVNhduIqDsu74rC8qyuW93EGdsXyVkzFUUs4LO+Kw/KuOCzvisPyrjgs74rD8q6uWN7HaskVy1sxFWcnDoflXXFY3tUVy/s4A7tieSum4qglHJZ3xWF5VxyWd8VheVcclnfFYXlXVyzvY7XkiuWtmIqzE4fD8q44LO/qiuWtZGActYTD8q44LO+Kw/KuOCzvisPyrjgs74rD8q6uWN7HaskVy1sxFWcnDoflXXFY3tUVy/s4A7tieSumCo6pOGoJh+VdcVjeFYflXXFY3hWH5V1dsbyP1ZIrlrdiKs5OHA7Lu+KwvKsrlreSgXHUEg7Lu+KwvCsOy7visLwrDsu74rC8Kw7Lu7pieR+rJVcsb8VUnJ04HJZ3xWF5V1cs7+MM7IrlrZiKo5ZwWN4Vh+VdcVjeFYflXXFY3hWH5V1dsbwP1VJzxfJWTIXZiWs4LO+Gw/Jum6Bk4OaK5a2YCqOWGg7Lu+GwvBsOy7vhsLwbDsu74bC8myuW97FacsXyVkyF2YlrOCzvhsPybq5Y3koGxlFLOCzvhsPybjgs74bD8m44LO+Gw/JuOCzv5orlfayWXLG8FVNxduJwWN4Nh+XdXLG8jzMwDsu7uWJ5K6bi9JZcsbwVU3HUEg7Lu7lieR9H1RXLWzEVRy25YnkrpuKoJVcs7+MM7IrlrZiK01tyxfJWTHWkliTmi6kS662pttVSbXL55KaZGraSLhdvPV4vjm0b3sbFwlLe3ZLe/vv2k+X6vIQs8t3VX7xoHBP+Kl60rfFexYu25eOreNG2Mn0VLwq9OMGLtvX0q3jRtlR/FS/argJexYu2C4xX8SJrlwleNA7tfxUvsnaZ4UXWLjO8yNplhheFXpzgRdYuM7zI2mWGF1m7/IAXa8nX24hRubrnfNn17LnFgc9Z6az3Oeui6T5P/XJ1l5C1z85b3q6paCvlNkbGD/9gjN5ixJpuee4yfnyKT5+zXrSfi4QxMh8j1rrrcxcr4/U+Zx093ecxXSzsMfeBz1lHr3/OWUcv97nxY56oc95ixLrYfoxYR6/PXayj1/tc6HPzuYh1sf0YsY5en7tYR6/3Oevo5b0L4+fuuXzOjR8A6NPnrIvN6xzjRygyRm8xYh29PncJfb7c56yL7eci1sX2Y8Q6en3uYh293ueso1f3Lrrxo2E9Pufd+Bm1Pn3Outi6zunGT/lljN5iJIzR8tzFOnq9z1kX289FrIvtx4h19PrcxTp6uc+NHxrusndh/PRyn8856+j1PmddbF7nGD+InjF6ixHr6PW5i3X0ep+zLrafi1gX248R6+jluSuyjl7vc9bRy3sXkXX0+uecdfR6nwt9bl3nRNbF9mPEOnp97mIdvd7nrIvt5yLWxeZjlFhHL89diXX0ep+zjl7eu0iso9c/50KfL/c562L7Ood1sf0YsY5en7tYR6/3Oeti87lIWBfbjxHr6OW5S1hHr/c56+jlvQsR+nz5c846er3PWRfb1zmsi+3HiHX0+tzFOnq5zzPrYvO5KLMuth8j1tHrcxfr6PU+F/p8de8is45e/5yzjl7vc9bF9nUO62L7MWIdvTx3FdbR633Outh8Liqsi+3HiHX0+twl9Plyn7OOXt67KKyj1z/nrKPX+5x1sX2dw7rYfIwq6+jluauyjl7vc9bF9nMR62L7MRLGaHnuYh293ueso5f3Lirr6PXPOevo9T5nXWxe5zTWxfZjxDp6ee5qrKPX+5x1sf1cJIyR+Rixjl6fu1hHr/c56+jlvYvGOnr9c846ernPO+ti8zqnsy62HyPW0etzF+vo9T4X+tx8LmJdbD9GrKPX5y7W0et9zjp6ee+is45e/JznbWMdvd7nrIuN65w9RqyL7ceIdfT63CX0+XKfsy62n4tYF9uPEevo9bmLdfR6n7OOXty7yFtgHb38OQ+so9f7nHWxeZ0TWBfbj5EwRstzF+vo9T5nXWw/F7Euth8j1tHrcxfr6OU+j6yjl/cuIuvo9c856+j1PmddbF7nRGGMzMeIdfT63MU6er3PWRfbz0Wsi+3HiHX08tyVWEev9znr6OW9i8Q6ev1zzjp6vc+FPreucxLrYvsxYh29Pnexjl7vc9bF9nMR62LzMRLW0ctzl7COXu9z1tHLexfCOlr3eQypX9wRahh4UehF/cmV3q8/dCIDL7J2neFFVpczvMh6cYYXWQHO8CJrtAlezKyiZniRddEML7LSmeFF1i4zvCj04gQvsnaZ4UXWLjO8yNplhhdZu8zwImuXCV4srF1meJG1ywwvsnZZvjNWWOms97nQ59bfjCisuuzHiDXd+tzFCnC9z1kv2s9FrEbNx6iy1l2euyor4/U+Zx29/G3Hyjp6/XMu9Plyn7Mutq9zWBfbjxHr6PW5i3X0ep+zLjafixrrYvsxYh29PHc11tHrfc46ennvogl9vvw5Zx293uesi+3rHNbF9mPEOnp97mIdvdznnXWx+VzUWRfbjxHr6PW5i3X0ep8Lfb66d9FZR69/zllHr/c562L7Ood1sf0YsY5enbvCxjp6vc9ZF1vPRWFjXWw/Rqyj1+cuoc+X+5x19OrexX6f9Pny55x19Hqfsy62r3NYF5uPUWAdvTx3BdbR633Outh+LmJdbD9Gwhgtz12so9f7nHX08t5FYB29/jlnHb3e56yLzeucyLrYfoxYRy/PXZF19Hqfsy62n4uEMTIfI9bR63MX6+j1Pmcdvbx3EVlHr3/OWUcv93liXWxe5yTWxfZjxDp6fe5iHb3e50Kfm89FrIvtx4h19PrcxTp6vc9ZRy/vXSTW0cufc2Edvd7nrIvN6xxhXWw/Rqyj1+cuoc+X+5x1sf1cxLrYfoxYR6/PXayj1/ucdfTy3kVmHb38Oc+so9f7nHWxeZ2TWRfbj5EwRstzF+vo9T5nXWw/F7Euth8j1tHrcxfr6OU+L6yjl/cuCuvo9c856+j1PmddbF7nFGGMzMeIdfT63MU6er3PWRfbz0Wsi+3HiHX08txVWUev9znr6OW9i8o6ev1zzjp6vc+FPreucyrrYvsxYh29Pnexjl7vc9bF9nMR62LzMWqso5fnrsY6er3PWUcv71001tHrn3Ohz5f7nHWxfZ3Duth+jFhHr89drKPX+5x1sflc1FkX248R6+jluauzjl7vc9bRy3sXXejz5c856+j1PmddbF/nsC62HyPW0etzF+vo1T6PG+ti67kobqyL7ceIdfT63MU6er3PhT5f3LuIG+vo9c856+j1PmddbF/nsC62HyPW0ctzV2Advd7nrIvN56LAuth+jFhHr89dQp8v9znr6OW9i8A6ev1zzjp6vc9ZF9vXOayLzccoso5enrsi6+j1PmddbD8XsS62HyNhjJbnLtbR633OOnp57yKyjl7/nLOOXu9z1sXmdU5iXWw/Rqyjl+euxDp6vc9ZF9vPRcIYmY8R6+j1uYt19Hqfs45e3rtIrKN1n8eQ+sUdoYaBF1kZ/8CTK71ff+hEbr0orF1neJHV5Qwvsl6c4UVWgDO8KPTiBC+yiprhRdZFM7zISmeGF1m7zPAia5cJXsysXWZ4kbXLDC+ydpnhRdYuM7wo9OIEL7J2meFF1i4zvMjaZfnOWGals97nrIvMvxlRWHXZjxFruuW5q7ACXO9z1ov2c5EwRuZjxFp3fe5iZbze56yjl7/tWFhHr3/OWUcv93llXWxe51TWxfZjxDp6fe5iHb3e50Kfm89FrIvtx4h19PrcxTp6vc9ZRy/vXVTW0cuf88Y6er3PWReb1zmNdbH9GLGOXp+7hD5f7nPWxfZzEeti+zFiHb0+d7GOXu9z1tHLexeddfTy57yzjl7vc9bF5nVOZ11sP0bCGC3PXayj1/ucdbH9XMS62H6MWEevz12so1f7fHcXfb64d5E21tHrn3PW0et9zrrYus5JmzBG5mPEOnp97mIdvd7nrIvt5yLWxfZjxDp6ee4KrKPX+5x19PLeRWAdvf45Zx293udCn1vXOYF1sf0YsY5en7tYR6/3Oeti+7mIdbH5GEXW0ctzV2Qdvd7nrKOX9y4i6+j1z7nQ58t9zrrYvs5hXWw/Rqyj1+cu1tHrfc662HwuSqyL7ceIdfTy3JVYR6/3Oevo5b2LJPT58uecdfR6n7Mutq9zWBfbjxHr6PW5i3X0cp8L62LzuUhYF9uPEevo9bmLdfR6nwt9vrp3Iayj1z/nrKPX+5x1sX2dw7rYfoxYRy/PXZl19Hqfsy42n4sy62L7MWIdvT53CX2+3Oeso5f3LjLr6PXPOevo9T5nXWxf57AuNh+jwjp6ee4qrKPX+5x1sf1cxLrYfoyEMVqeu1hHr/c56+jlvYvCOnr9c846er3PWReb1zmVdbH9GLGOXp67Kuvo9T5nXWw/FwljZD5GrKPX5y7W0et9zjp6ee+iso5e/5yzjl7u88a62LzOaayL7ceIdfT63MU6er3PhT43n4tYF9uPEevo9bmLdfR6n7OOXt67aKyjlz/nnXX0ep+zLjavczrrYvsxYh29PncJfb7c56yL7eci1sX2Y8Q6en3uYh293ueso1f3LmRjHb36OZeNdfR6n7Mutq5zZGNdbD9Gwhgtz12so9f7nHWx/VzEuth+jFhHr89drKOX+zywjl7euwiso9c/56yj1/ucdbF5nROEMTIfI9bR63MX6+j1PmddbD8XsS62HyPW0ctzV2Qdvd7nrKOX9y4i6+j1zznr6PU+F/rcus6JrIvtx4h19PrcxTp6vc9ZF9vPRayLzccosY5enrsS6+j1Pmcdvbx3kVhH6z6PIfWLO0INAy8Kvah7MdfLJ8cS2sCLrF1neJHV5Qwvsl6c4UVWgDO8yBptgheFVdQML7IumuFFVjozvMjaZYYXhV7UvVivvYvY1J6e2ukQVjrrfc66aLrPZ3e6hVWX/Rixplufu1gBLvd5Zr1oPhdlVqP2Y8Rad33uYmW83udCn8/2ubZ7nVlHr3/OWUev9znrYvs6h3Wx/Rixjl6euwrr6PU+Z11sPhcV1sX2Y8Q6en3uEvp8uc9ZRy/vXRTW0eufc9bR633Outi+zmFdbD5GlXX08txVWUev9znrYvu5iHWx/RgJY7Q8d7GOXu9z1tHLexeVdfT655x19Hqfsy42r3Ma62L7MWIdvTx3NdbR633Outh+LhLGyHyMWEevz12so9f7nHX08t5FYx29/jlnHb3c5511sXmd01kX248R6+j1uYt19HqfC31uPhexLrYfI9bR63MX6+j1Pmcdvbx30VlHr37O88Y6er3PWRdb1zl5Y11sP0aso9fnLqHPl/ucdbH9XMS62H6MWEevz12so9f7nHX06t5FDqyjlz/ngXX0ep+zLjavcwLrYvsxEsZoee5iHb3e56yL7eci1sX2Y8Q6en3uYh293OeRdfTy3kVkHb3+OWcdvd7nrIvN65wojJH5GLGOXp+7WEev9znrYvu5iHWx/Rixjl6euxLr6PU+Zx29vHeRWEf/gM97vNxG7G9GHfu81+tNb1vSPjy8+e9yfUihDYLEwvsFgiQMkv0gsfR+gSCxVn+BILG4f4Egsbp/gSCxvLcfJGE/QA+SbCV8u1hCTAMvssKf4UXW7DO8yKJ6hheFXpzgRZalM7zIunGGF1nYzfAiK68ZXmRpNMGLmbXLDC+ydvkBL4Z0MVDiFrS6u7bSLzdSe9rUOn1r1+v3/zfYz8ysjV4hSqy9XiFKwijZilLMgyixdnx+lNT+cWZt+gpRYu37ClFibf0KUWLt/gJRKuwNzI9S7+161/tNaddHSfVyfZS6DaLE3sPzo5TfbzzmPooSew+vECX2Hl4hSsIovUCU2Ht4hSix9/AKUWLv4RWixN7DK0SJvYfpUWrx/Z3qlja59XplL+EZXmdvYL7XJb3fteQBk6Gy1v8Br8cQr16XqHq9hny965rDwOus3ed7vcn7Xe9uV64vfbu8J1V6eL+XMPJIi9fPbrHEjxd/jacwnq7iyX6Ar3iyc+Arnuwx+IonuxG+4sm+hat4NnZEfMWTvRZf8WQXx1c82R/yFU9hPF3Fk/0hX/Fkf8hXPNkf8hVP9od8xZP9IVfx7OwP+Yon+0O+4sn+kK94sj/kK57CeLqKJ/tDvuLJ/pCveLI/5Cue7A/5iif7Q57iWTb2h3zFk/0hX/Fkf8hXPNkf8hVPYTxdxZP9IV/xZH/IVzzZH/IVT/aHfMWT/SFX8QzsD/mKJ/tDvuLJ/pCveLI/5Cuewni6iif7Q77iyf6Qr3iyP+QrnuwP+Yon+0Ou4hnZH/IVz+X9oRDkeuJYjNt3Ef16S8tbHCFen7F9ZVQesiqXs7VqeX8gYx89NbGVC4A4thZu3Z+AbBUgWzOQrQXI1gpkawOytePYmjYgWwOQrUC6KQHppiRAtgLppgSkmxKQbkpAuikB6SYB0k0CpJsESDcJkG4SAbIVSDcJkG4SIN0kQLpJgHRTBtJNGUg3ZSDdlIF0UxYgW4F0UwbSTRlIN2Ug3ZSBdFMB0k0FSDcVIN1UjOumXi62hm0LirE5xcubaznlD64ZvjBYu1xcU3tPytUpX2yUD+/ERRn5vIbLbcSa0vHFodar82rPysXb9ZPD9jH28i2awmg6iqZx7ctofiqaxtU9o/mpaBqvXxjNT0XTeIXGaH4qmsZrUEbzM9GsxqtsRvNT0TTeR2A0PxVN450SRvNT0WQvyFM0hdF0FE32gjxFk70gT9FkL8hTNNkL8hRN9oIcRbOxF+QpmuwFeYome0GeoslekKdoCqPpKJrsBXmKJntBnqLJXpCnaLIX5Cma7AU5imZnL8hTNNkL8hRN9oI8RZO9IE/RFEbTUTTZC/IUTfaCPEWTvSBP0WQvyFM02QvyE826sRfkKZrsBXmKJntBnqLJXpCnaAqj6Sia7AV5iiZ7QZ6iyV6Qp2iyF+QpmuwFOYpmYC/IUzTZC/IUTfaCPEWTvSBP0RRG01E02QvyFE32gjxFk70gT9FkL8hTNNkLchTNyF6Qp2iyF+QpmuwFeYome0GeoimMpqNoshfkKZrsBXmKJntBnqLJXpCnaLIX5Ciaib0gT9FkL8hTNNkL8hRN9oI8RVMYTUfRZC/IUzTZC/IUTfaCPEWTvSBP0WQvyFE0hb0gT9FkL8hTNNkL8hRN9oI8RVMYTUfRZC/IUzTZC/IUTfaCPEWTvSBP0WQvyFE0M3tBnqLJXpCnaLIX5Cma7AV5iqYwmo6iyV6Qp2iyF+QpmuwFeYome0GeoslekKNoFvaCPEWTvSBP0WQvyFM02QvyFE1hNB1Fk70gT9FkL8hTNNkL8hRN9oI8RZO9IEfRrOwFeYome0GeoslekKdoshfkKZrCaDqKJntBnqLJXpCnaLIX5Cma7AV5iiZ7QY6i2dgL8hRN9oI8RZO9IE/RZC/IUzSF0XQUTfaCPEWTvSBP0WQvyFM02QvyFE32ghxFs7MX5Cma7AV5iiZ7QZ6iyV6Qp2gKo+komuwFeYome0GeoslekKdoshfkKZrsBfmJZtvYC/IUTfaCPEWTvSBP0WQvyFM0hdF0FE32gjxFk70gT9FkL8hTNNkL8hRN9oIcRTOwF+QpmuwFeYome0GeoslekKdoCqPpKJrsBXmKJntBnqLJXpCnaLIX5Cma7AU5imZkL8hTNNkL8hRN9oI8RZO9IE/RFEbTUTTZC/IUTfaCPEWTvSBP0WQvyFM02QtyFM3EXpCnaLIX5Cma7AV5iiZ7QZ6iKYymo2iyF+QpmuwFeYome0GeoslekKdoshfkKJrCXpCnaLIX5Cma7AV5iiZ7QZ6iKYymo2iyF+QpmuwFeYome0GeoslekKdoshfkKJqZvSBP0WQvyFM02QvyFE32gjxFUxhNR9FkL8hTNNkL8hRN9oI8RZO9IE/RZC/IUTQLe0GeoslekKdoshfkKZrsBXmKpjCajqLJXpCnaLIX5Cma7AV5iiZ7QZ6iyV6Qo2hW9oI8RZO9IE/RZC/IUzTZC/IUTWE0HUWTvSBP0WQvyFM02QvyFM31vaAU2vXqVL+L5tdbWt/QSOXqJIlZecBC75cnLG6tXK/uoztpMVwemRZzxHvA2sZoOopmYDQdRXNGQyO1eI2mfPjBHUazpBC+XV2SFCX0fUuXj+753TEh92/3n5bfv8jlloqU7fjimDa5WLv/d/3u8q8GyKsbMC7UcrwaULakGBDyez4IOb4/FKWM7qm16ze8fzBg+A3fn5Qsl8/OvWgCL4Z4uZUY5MO3q9dxaro+nxK2767+6p0ywzvpg3dKP/ZOKpccJeGDUJZv0qrVGTdUr0kllBiPbyj00t+/xDX8/BPXXt+EvtqEuKUk19/FnPp397T/49//9tvvv//2n//2+1//9Md//PbXv/z9bfH29n/C+KThUtKlJtv/8z3ppPLl2Q/jE221VeOTU9VV4dSqeGpVOrVKTq3Kp1aVU6vqqVWnno146tlIp56NdOrZSKeejXTq2Uinno106tkYk7tLlctPTKkf8tV11TBedQuXlFK3VG5WjWmn6qpwalU8tWocr9774ao2/ltSr6vqreeln1mVt1OrwqlVY7v2X7PLqhRvvTGeRNJWjSde1FXh1Krxs5HStZpLud6uSqdWyalV+dSqoq4q8WZVveP59r6qt9tV4dSqeGpVOrVKTq0a+1Di9YmSDwX5ZdW4CaKuGt9hyxexWFsZrKrjv1Xa9W99qAmuq9qpVf3Mqj6Ocm5Xb+R++xz28TNfr0q7tsHvVy+nVtUznu/t1Kp+YlXctlOrwqlV8dSqdGqVnFqVT60qp1bVU6vaqVWnno0wjle59i5rifV2VTq1Sk6tyqdWlVOr6qlV7dSqfmbVuIb9btVtjorjGlZdFU+tSqdW3Xk2rj2wWmq7XTX24S7NL6tqkJtV41pPXRVOrYqnVt3x4XX7YV+Vb1fJqVX51KpyalU9taqdWtXPrLpT69V8fQ5rvo3XuNb7TjmE73PvoOkmLV+3rqUNnna583sXyoE+iXJGC0Upp1bVU6vaqVX9zKo7Ne/Rqv1f4e3a8ZhSeNtxvPZKU7gJ23geRl/WTy0bV2D6snBuWTy3LJ1bJueW5XPLht+AvZxO19Z4ybc18PgFJn1ZO7esn1o2fm1iv7SG92Xtdlk4t2wcgFKuRVwoe9PoZtmdANT4bluVm5ZMq+eWtXPL+qll/U4Ado3+vuy2pdDDuWXx3LJ0bpmcW5bPLSvnlt15Stp7Uigt3Px+9HZuWT+1LGz3HpMPX7gWoqYsYr3uGe7/XYJ2fc7t+vTm3G+7Mlswel/R6H0lo/clRu8rG72vYvS+qtH7as+6r2tezWW73XPc+qT7SunDfXW9wruW/ft/h9u+ddiM3ld+0n0dV8QhFKP3VY3eVzN6X93mfcXN6H3d0xP5g+gtg3Vycl0+ua6cXFdPrmsn1/Vz69J2cl04uS6eXHfyeUknn5d053lpqb5/bwZvHaRycl09ua6dXNfPrZM7ce/v+qb0Irfr4sl1d/z5YYpt74ff6rZxbzXUPSFe1tUweHtp3F39gXXh5Lp4cl06uU5Orssn15WT6+rJde3OuutLGvt/t1s9ne89L+/PWQ1d2wEp/SpDSw8fZvfacLxGLt3DFj90OMOXl9HvvAP21DsK5u4omrujZO6OxNwdZXN3VKzd0Z1dsBqvr+y+/ffN7u+dtwP3a6/bv/t/D/LfnS2mum9dv6+T2/e57uwx6evu5PdYPtzn4Hf9zi5TTe8zUjXFwXud/dy6O/tM+rpwcl08uS6dXCcn1915XpJ8WJdvn887W2L6unpyXTu57t7zkj6uu9UffTu5LpxcF0+uSyfXycl1+eS6e8/Le390/+/BW7f15Lp2cl0/te7Om637tfXDur7drgsn18WT69LJdXJyXT65rpxcd+d5kQ+/txJ/9E3XH1jXz62701/X1915XmT7uO72vbAQT65LJ9fJyXX55Lpycl09ue7O8xLbu+6RlP9X66+m8D5aPfh9vvNu7om/cx2X2f87q/tW6huAcZt0X+9z65IGb4XH8AD7R38nLvo7adHfkUV/J0/6O++4D0k9/vzzWSbdV3+3f88Jt3+nzrd/+Hfaor/T1/ydtC36O5Pyh4T6/nfSz79BnSblG0kf7JfBu+fpAfbLj77x/4C/kxf9nbLo79RTfZ47kwg/sK6fWyfbyXXh5Lp4cl06uU5Orssn15WT604+L3LyeZGTz0uOp/b74p39sNL7e923bbc6+c5+mL4un1xXTq6rJ9e1k+v6uXV3dq30deHkunhy3cnnpZx8XsqZ52X/V3y7+s545od5xHehEN72Em6uletrjvkDn+nt2j+8Na9++uPDxYr8kVj69ePvDHxO+/jw2I+Pj/349NiPl8d+fH7sx49H+Lb3j+/Kx/d6LcO2D2/RxjIik9Ucrx8cvrv27V6qoXtphu6lr72X61RS/bBpOr42hCvLMYSPbMPh1bleLv74HvjX7dg789bOjAwIRkYEI5N7I/d/pLcL7/DrPsB1PrxakdP9R+B4Sfr8Evn8kvz5JeXzS8Y/ZNfx8bbdLmmfX9I/vWTcKmj1+ppMSzdLwueXxM8vGUa/X3d6erhdIp9fMox+v45Bd2k3S8rnl1RlyYd3IS5L2ueX9E8vGb9426/b5/3D5vllSfj8knG5uF0BFGEr39/a4DWv7dKiLR9weqF9hW6nR/8BefQfyI/+A+XRf6A++g+0R/+B/uA/cKdNM/EPhEf/gUd/k8ujv8nl0d/k8uhvcnn0N7k8+ptcHv1NLo/+JtcZT9H1VeTy4RWPyx+YEYNy6SCUjx2hb3/g0zH4w11szPGitp1Z1B/s4D4jF1/rtfLhwJjLH5iRi6/zoqXdPIM9PvoPpEf/AXn0H8iP/gPl0X+gPvoPtAcnmt4f/Afu0W5m/oXw8L8QH/4X0sP/gjz8L+SH/4Xy8L9QH/4X2sP/wsO/0+Gx3+n9X/J25Z0XkfcgXTuxu7EfF39Zm7+svRfI62z19uGVozB646i+HxLw8WCkb8Mwj/34/vMff6VTVOn/9PFxm/Dx7xtg6Z8/Pvz8x18352uv//zx8bEfn37649v1SLAm/xzaKBM+/noG4YfxoG8fn3/+4+sltO3WOWXix/d/eu73f5TD7318/9q3H/vGBHlPFaUc35iaWOrbxXFcXSrH6MSaT60qp1bVU6vaqVVnDmaKbTu1KpxaFU+tSqdWnXo22qlno516NtqpZ6OdejbaqWejn3o2+qlnY1ylK4dbxTsHkRwfHRXvHESiraqnVrVTq8bxOj7cKo0LC+XoqHTnwA5tVTm1qp5Zdedgi+Ojo9Kdgy20VeXUqnpq1Z1Duw6Pjkp3XohUVt15z1FbFU6t0g/tumVmpzvv0x0fApXuvPmmrWqnVvUzq9J2atXYh8fHVKU7r08oq+TMAUbpzqEMxwdOpTuHLGir8qlV4ygfH26V7hzAd3zwQcrx1KozBzOl8S67uiqfWlVOraqnVrVTq84czJTKqWe+hFOr4qlVp56NcurZKKeejXLmYKZUzhzMlOp2alU4tSqeWpVOrZJTq/KpVfqhXYMcVeupVe3Uqn5mVbvzbBwebpXanYN7Do+OSq2cWlVPrWqnVp05mCn17dSqcGpVPLUqnVolp1blU6vuxOvwcKvU9YOWfv5wK7l3SOXh4VayndFCssVTq9KpVXJqVT616vOHdu3/al96lcPblOuOc/64M5C3+/3j4yXl80vq55e0zy/pn14yLpvytWWde7hZEj6/JH5+ybgfef0ile/eat8++8rUnVfzp318fuzHl8d+fH3sx7fHfnx/6MePy/h5Hx8e+/HxsR//2G+tPPZbK4/91spjv7Xy2G+tPPZbK4/91ubHfmvzzz85R6+H5p/3/dH7LfmTvv/DveGB4yXh80vKQ91afv4bc/TObfn5qB29K1n6Qz++bo/9+PDYj4+P/fj02I+Xx358fmg6qeWxH18f+/GPzbW1P/Tj2/bYjw+P/fj42I9Pj/14eezHP/Zb2x75rd3/1d+uHL9jEHu8ZKvYP75dmb8ufXv99n/uiP98fRMv5w9UI2n3Bf3xkvL5JfXzS9onl7x54cv57eNd/32H9dIcyx96PFL2lfs//+8f//bbH//99z//fV/y9r/+91/+9I/f/vqXb//8x//7r8v/8u9/++3333/7z3/7r7/99U9//o///tuf/+33v/7p7X/7Zfv2f/417rvBsfU/fIEv/GvY0q8hpD98DdK/vqHdYm5/+Hq3+7Xx11jkevj8l0ta+TVt9dv6vP1atuvqt4+u6bq6yv7P8o7AersmlV8lXK6Q+KvIlQPx9j+HtN9Plsvdhf1f8Xp3Yd+gD7FfVoe0/RpSfH/9+ss1/dco729Vf/mT268pv7+s+eVO669fF9bLH37b/BfJ3/5wzPvHlH75w7L1/a7letuh/Spxu7Ytv/zd/ZL9hr6tb/3Xfl0dtv0+t3y97a3s/2zv36kv15RfY3j/rrx9RgrfPLV99XPO70/Rt2Dtgdifj/0Z+f8=","brillig_names":["build_msg_block","attach_len_to_msg_block","storage_read","get_public_data_witness","field_less_than","decompose_hint","lte_hint","build_msg_block","get_l1_to_l2_membership_witness","notify_created_nullifier_oracle_wrapper","store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal","directive_to_radix","directive_invert","directive_integer_quotient"],"verification_key":"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"},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"10502589790419500451":{"error_kind":"string","string":"Function _increase_public_balance can only be called internally"},"15238796416211288225":{"error_kind":"string","string":"Balance too low"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2830029349304997821":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":27},"3219842053230618354":{"error_kind":"string","string":"Function check_balance can only be called statically"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6067862452620309358":{"error_kind":"string","string":"Function balance_of_public can only be called statically"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]}]`),s={globals:{storage:[{fields:[{name:"contract_name",value:{kind:"string",value:"ContractInstanceDeployer"}},{name:"fields",value:{fields:[{name:"updated_class_ids",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}}],kind:"struct"}}],kind:"struct"}}],kind:"struct"},{fields:[{name:"contract_name",value:{kind:"string",value:"FeeJuice"}},{name:"fields",value:{fields:[{name:"balances",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}}],kind:"struct"}},{name:"portal_address",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000002"}}],kind:"struct"}}],kind:"struct"}}],kind:"struct"}]},structs:{functions:[{fields:[{name:"parameters",type:{fields:[{name:"portal_address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],kind:"struct",path:"FeeJuice::set_portal_parameters"}}],kind:"struct",path:"FeeJuice::set_portal_abi"},{fields:[{name:"parameters",type:{fields:[{name:"portal_address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{name:"initial_mint",type:{kind:"integer",sign:"unsigned",width:128}}],kind:"struct",path:"FeeJuice::initialize_parameters"}}],kind:"struct",path:"FeeJuice::initialize_abi"},{fields:[{name:"parameters",type:{fields:[{name:"owner",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],kind:"struct",path:"FeeJuice::balance_of_public_parameters"}},{name:"return_type",type:{kind:"integer",sign:"unsigned",width:128}}],kind:"struct",path:"FeeJuice::balance_of_public_abi"},{fields:[{name:"parameters",type:{fields:[{name:"to",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"amount",type:{kind:"integer",sign:"unsigned",width:128}},{name:"secret",type:{kind:"field"}},{name:"message_leaf_index",type:{kind:"field"}}],kind:"struct",path:"FeeJuice::claim_parameters"}}],kind:"struct",path:"FeeJuice::claim_abi"},{fields:[{name:"parameters",type:{fields:[{name:"to",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"amount",type:{kind:"integer",sign:"unsigned",width:128}}],kind:"struct",path:"FeeJuice::_increase_public_balance_parameters"}}],kind:"struct",path:"FeeJuice::_increase_public_balance_abi"},{fields:[{name:"parameters",type:{fields:[{name:"fee_limit",type:{kind:"integer",sign:"unsigned",width:128}}],kind:"struct",path:"FeeJuice::check_balance_parameters"}}],kind:"struct",path:"FeeJuice::check_balance_abi"}]}},a=JSON.parse('{"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    // Safety: borrow is enforced to be boolean due to its type.\\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        // Safety: decomposition is properly checked below\\n        unsafe {\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            // Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unsafe in unconstrained\\n        unsafe {\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        // Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unconstrained context\\n        unsafe {\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        // 259, in base 256, big endian, is [1, 3].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        // 259, in base 256, little endian, is [3, 1].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    //#[test]\\n    //fn test_to_le_radix_brillig_1() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(1);\\n    //        crate::println(out);\\n    //        let expected = [0; 8];\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    //#[test]\\n    //fn test_to_le_radix_brillig_512() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(512);\\n    //        let mut expected = [0; 8];\\n    //        expected[0] = 1;\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"24":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"43":{"path":"std/ops/arith.nr","source":"// docs:start:add-trait\\npub trait Add {\\n    fn add(self, other: Self) -> Self;\\n}\\n// docs:end:add-trait\\n\\nimpl Add for Field {\\n    fn add(self, other: Field) -> Field {\\n        self + other\\n    }\\n}\\n\\nimpl Add for u128 {\\n    fn add(self, other: u128) -> u128 {\\n        self + other\\n    }\\n}\\nimpl Add for u64 {\\n    fn add(self, other: u64) -> u64 {\\n        self + other\\n    }\\n}\\nimpl Add for u32 {\\n    fn add(self, other: u32) -> u32 {\\n        self + other\\n    }\\n}\\nimpl Add for u16 {\\n    fn add(self, other: u16) -> u16 {\\n        self + other\\n    }\\n}\\nimpl Add for u8 {\\n    fn add(self, other: u8) -> u8 {\\n        self + other\\n    }\\n}\\nimpl Add for u1 {\\n    fn add(self, other: u1) -> u1 {\\n        self + other\\n    }\\n}\\n\\nimpl Add for i8 {\\n    fn add(self, other: i8) -> i8 {\\n        self + other\\n    }\\n}\\nimpl Add for i16 {\\n    fn add(self, other: i16) -> i16 {\\n        self + other\\n    }\\n}\\nimpl Add for i32 {\\n    fn add(self, other: i32) -> i32 {\\n        self + other\\n    }\\n}\\nimpl Add for i64 {\\n    fn add(self, other: i64) -> i64 {\\n        self + other\\n    }\\n}\\n\\n// docs:start:sub-trait\\npub trait Sub {\\n    fn sub(self, other: Self) -> Self;\\n}\\n// docs:end:sub-trait\\n\\nimpl Sub for Field {\\n    fn sub(self, other: Field) -> Field {\\n        self - other\\n    }\\n}\\n\\nimpl Sub for u128 {\\n    fn sub(self, other: u128) -> u128 {\\n        self - other\\n    }\\n}\\nimpl Sub for u64 {\\n    fn sub(self, other: u64) -> u64 {\\n        self - other\\n    }\\n}\\nimpl Sub for u32 {\\n    fn sub(self, other: u32) -> u32 {\\n        self - other\\n    }\\n}\\nimpl Sub for u16 {\\n    fn sub(self, other: u16) -> u16 {\\n        self - other\\n    }\\n}\\nimpl Sub for u8 {\\n    fn sub(self, other: u8) -> u8 {\\n        self - other\\n    }\\n}\\nimpl Sub for u1 {\\n    fn sub(self, other: u1) -> u1 {\\n        self - other\\n    }\\n}\\n\\nimpl Sub for i8 {\\n    fn sub(self, other: i8) -> i8 {\\n        self - other\\n    }\\n}\\nimpl Sub for i16 {\\n    fn sub(self, other: i16) -> i16 {\\n        self - other\\n    }\\n}\\nimpl Sub for i32 {\\n    fn sub(self, other: i32) -> i32 {\\n        self - other\\n    }\\n}\\nimpl Sub for i64 {\\n    fn sub(self, other: i64) -> i64 {\\n        self - other\\n    }\\n}\\n\\n// docs:start:mul-trait\\npub trait Mul {\\n    fn mul(self, other: Self) -> Self;\\n}\\n// docs:end:mul-trait\\n\\nimpl Mul for Field {\\n    fn mul(self, other: Field) -> Field {\\n        self * other\\n    }\\n}\\n\\nimpl Mul for u128 {\\n    fn mul(self, other: u128) -> u128 {\\n        self * other\\n    }\\n}\\nimpl Mul for u64 {\\n    fn mul(self, other: u64) -> u64 {\\n        self * other\\n    }\\n}\\nimpl Mul for u32 {\\n    fn mul(self, other: u32) -> u32 {\\n        self * other\\n    }\\n}\\nimpl Mul for u16 {\\n    fn mul(self, other: u16) -> u16 {\\n        self * other\\n    }\\n}\\nimpl Mul for u8 {\\n    fn mul(self, other: u8) -> u8 {\\n        self * other\\n    }\\n}\\nimpl Mul for u1 {\\n    fn mul(self, other: u1) -> u1 {\\n        self * other\\n    }\\n}\\n\\nimpl Mul for i8 {\\n    fn mul(self, other: i8) -> i8 {\\n        self * other\\n    }\\n}\\nimpl Mul for i16 {\\n    fn mul(self, other: i16) -> i16 {\\n        self * other\\n    }\\n}\\nimpl Mul for i32 {\\n    fn mul(self, other: i32) -> i32 {\\n        self * other\\n    }\\n}\\nimpl Mul for i64 {\\n    fn mul(self, other: i64) -> i64 {\\n        self * other\\n    }\\n}\\n\\n// docs:start:div-trait\\npub trait Div {\\n    fn div(self, other: Self) -> Self;\\n}\\n// docs:end:div-trait\\n\\nimpl Div for Field {\\n    fn div(self, other: Field) -> Field {\\n        self / other\\n    }\\n}\\n\\nimpl Div for u128 {\\n    fn div(self, other: u128) -> u128 {\\n        self / other\\n    }\\n}\\nimpl Div for u64 {\\n    fn div(self, other: u64) -> u64 {\\n        self / other\\n    }\\n}\\nimpl Div for u32 {\\n    fn div(self, other: u32) -> u32 {\\n        self / other\\n    }\\n}\\nimpl Div for u16 {\\n    fn div(self, other: u16) -> u16 {\\n        self / other\\n    }\\n}\\nimpl Div for u8 {\\n    fn div(self, other: u8) -> u8 {\\n        self / other\\n    }\\n}\\nimpl Div for u1 {\\n    fn div(self, other: u1) -> u1 {\\n        self / other\\n    }\\n}\\n\\nimpl Div for i8 {\\n    fn div(self, other: i8) -> i8 {\\n        self / other\\n    }\\n}\\nimpl Div for i16 {\\n    fn div(self, other: i16) -> i16 {\\n        self / other\\n    }\\n}\\nimpl Div for i32 {\\n    fn div(self, other: i32) -> i32 {\\n        self / other\\n    }\\n}\\nimpl Div for i64 {\\n    fn div(self, other: i64) -> i64 {\\n        self / other\\n    }\\n}\\n\\n// docs:start:rem-trait\\npub trait Rem {\\n    fn rem(self, other: Self) -> Self;\\n}\\n// docs:end:rem-trait\\n\\nimpl Rem for u128 {\\n    fn rem(self, other: u128) -> u128 {\\n        self % other\\n    }\\n}\\nimpl Rem for u64 {\\n    fn rem(self, other: u64) -> u64 {\\n        self % other\\n    }\\n}\\nimpl Rem for u32 {\\n    fn rem(self, other: u32) -> u32 {\\n        self % other\\n    }\\n}\\nimpl Rem for u16 {\\n    fn rem(self, other: u16) -> u16 {\\n        self % other\\n    }\\n}\\nimpl Rem for u8 {\\n    fn rem(self, other: u8) -> u8 {\\n        self % other\\n    }\\n}\\nimpl Rem for u1 {\\n    fn rem(self, other: u1) -> u1 {\\n        self % other\\n    }\\n}\\n\\nimpl Rem for i8 {\\n    fn rem(self, other: i8) -> i8 {\\n        self % other\\n    }\\n}\\nimpl Rem for i16 {\\n    fn rem(self, other: i16) -> i16 {\\n        self % other\\n    }\\n}\\nimpl Rem for i32 {\\n    fn rem(self, other: i32) -> i32 {\\n        self % other\\n    }\\n}\\nimpl Rem for i64 {\\n    fn rem(self, other: i64) -> i64 {\\n        self % other\\n    }\\n}\\n\\n// docs:start:neg-trait\\npub trait Neg {\\n    fn neg(self) -> Self;\\n}\\n// docs:end:neg-trait\\n\\n// docs:start:neg-trait-impls\\nimpl Neg for Field {\\n    fn neg(self) -> Field {\\n        -self\\n    }\\n}\\n\\nimpl Neg for i8 {\\n    fn neg(self) -> i8 {\\n        -self\\n    }\\n}\\nimpl Neg for i16 {\\n    fn neg(self) -> i16 {\\n        -self\\n    }\\n}\\nimpl Neg for i32 {\\n    fn neg(self) -> i32 {\\n        -self\\n    }\\n}\\nimpl Neg for i64 {\\n    fn neg(self) -> i64 {\\n        -self\\n    }\\n}\\n// docs:end:neg-trait-impls\\n"},"46":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"47":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"54":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fee_juice_contract/src/lib.nr","source":"use dep::aztec::context::PublicContext;\\nuse dep::aztec::prelude::AztecAddress;\\nuse dep::aztec::protocol_types::hash::sha256_to_field;\\nuse dep::aztec::protocol_types::traits::ToField;\\n\\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\\n    context.transaction_fee()\\n}\\n\\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: u128) -> Field {\\n    let mut hash_bytes = [0; 68];\\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\\n\\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\\n    // it has nothing to do with calling the function.\\n    let selector = comptime { keccak256::keccak256(\\"claim(bytes32,uint256)\\".as_bytes(), 22) };\\n\\n    for i in 0..4 {\\n        hash_bytes[i] = selector[i];\\n    }\\n\\n    for i in 0..32 {\\n        hash_bytes[i + 4] = recipient_bytes[i];\\n        hash_bytes[i + 36] = amount_bytes[i];\\n    }\\n\\n    let content_hash = sha256_to_field(hash_bytes);\\n    content_hash\\n}\\n"},"55":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fee_juice_contract/src/main.nr","source":"mod lib;\\n\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract FeeJuice {\\n    use dep::aztec::{\\n        macros::{functions::{internal, private, public, view}, storage::storage},\\n        protocol_types::address::{AztecAddress, EthAddress},\\n        state_vars::{Map, PublicImmutable, PublicMutable},\\n    };\\n\\n    use crate::lib::get_bridge_gas_msg_hash;\\n    use std::ops::Add;\\n\\n    #[storage]\\n    struct Storage<Context> {\\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\\n        // Do not change this storage layout unless you also update the base rollup circuits.\\n        balances: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\\n        portal_address: PublicImmutable<EthAddress, Context>,\\n    }\\n\\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\\n    #[private]\\n    fn initialize(portal_address: EthAddress, initial_mint: u128) {\\n        // Validate contract class parameters are correct\\n        let self = context.this_address();\\n\\n        // Increase self balance and set as fee payer, and end setup\\n        FeeJuice::at(self)._increase_public_balance(self, initial_mint).enqueue(&mut context);\\n        context.set_as_fee_payer();\\n        context.end_setup();\\n\\n        // Enqueue call to set the portal address\\n        FeeJuice::at(self).set_portal(portal_address).enqueue(&mut context);\\n    }\\n\\n    // We purposefully not set this function as an initializer so we do not bind\\n    // the contract to a specific L1 portal address, since the Fee Juice address\\n    // is a hardcoded constant in the rollup circuits.\\n    #[public]\\n    fn set_portal(portal_address: EthAddress) {\\n        assert(storage.portal_address.read().is_zero());\\n        storage.portal_address.initialize(portal_address);\\n    }\\n\\n    #[private]\\n    fn claim(to: AztecAddress, amount: u128, secret: Field, message_leaf_index: Field) {\\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\\n        let portal_address = storage.portal_address.read();\\n        assert(!portal_address.is_zero());\\n\\n        // Consume message and emit nullifier\\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, message_leaf_index);\\n\\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\\n        FeeJuice::at(context.this_address())._increase_public_balance(to, amount).enqueue(\\n            &mut context,\\n        );\\n    }\\n\\n    #[public]\\n    #[internal]\\n    fn _increase_public_balance(to: AztecAddress, amount: u128) {\\n        let new_balance = storage.balances.at(to).read().add(amount);\\n        storage.balances.at(to).write(new_balance);\\n    }\\n\\n    #[public]\\n    #[view]\\n    fn check_balance(fee_limit: u128) {\\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \\"Balance too low\\");\\n    }\\n\\n    // utility function for testing\\n    #[public]\\n    #[view]\\n    fn balance_of_public(owner: AztecAddress) -> pub u128 {\\n        storage.balances.at(owner).read()\\n    }\\n}\\n"},"65":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// A dynamically sized array backed by PXE\'s non-volatile database (called capsules). Values are persisted until\\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\\npub struct CapsuleArray<T> {\\n    contract_address: AztecAddress,\\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\\n    base_slot: Field,\\n}\\n\\nimpl<T, let N: u32> CapsuleArray<T>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{\\n    /// Returns a CapsuleArray connected to a contract\'s capsules at a base slot. Array elements are stored in\\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\\n        Self { contract_address, base_slot }\\n    }\\n\\n    /// Returns the number of elements stored in the array.\\n    pub unconstrained fn len(self) -> u32 {\\n        // An uninitialized array defaults to a length of 0.\\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\\n    }\\n\\n    /// Stores a value at the end of the array.\\n    pub unconstrained fn push(self, value: T) {\\n        let current_length = self.len();\\n\\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\\n        // array, which is where we want to place the new value.\\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\\n\\n        // Then we simply update the length.\\n        let new_length = current_length + 1;\\n        capsules::store(self.contract_address, self.base_slot, new_length);\\n    }\\n\\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn get(self, index: u32) -> T {\\n        assert(index < self.len(), \\"Attempted to read past the length of a CapsuleArray\\");\\n\\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\\n    }\\n\\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn remove(self, index: u32) {\\n        let current_length = self.len();\\n        assert(index < current_length, \\"Attempted to delete past the length of a CapsuleArray\\");\\n\\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\\n        // array past the removed element one slot backward so that we don\'t end up with a gap and preserve the\\n        // contiguous slots. We can skip this when deleting the last element however.\\n        if index != current_length - 1 {\\n            // The source and destination regions overlap, but `copy` supports this.\\n            capsules::copy(\\n                self.contract_address,\\n                self.slot_at(index + 1),\\n                self.slot_at(index),\\n                current_length - index - 1,\\n            );\\n        }\\n\\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\\n        // the element we meant to delete in the first place) and update the length.\\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\\n    }\\n\\n    unconstrained fn slot_at(self, index: u32) -> Field {\\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\\n        // element.\\n        self.base_slot + 1 + index as Field\\n    }\\n}\\n\\nmod test {\\n    use crate::test::helpers::test_environment::TestEnvironment;\\n    use super::CapsuleArray;\\n    use protocol_types::address::AztecAddress;\\n\\n    global SLOT: Field = 1230;\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        TestEnvironment::new().unkonstrained().this_address()\\n    }\\n\\n    #[test]\\n    unconstrained fn empty_array() {\\n        let contract_address = setup();\\n\\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn empty_array_read() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        let _: Field = array.get(0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_push() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        assert_eq(array.len(), 1);\\n        assert_eq(array.get(0), 5);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn read_past_len() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        let _ = array.get(1);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_last() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(5);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_some() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        assert_eq(array.len(), 3);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 8);\\n        assert_eq(array.get(2), 9);\\n\\n        array.remove(1);\\n\\n        assert_eq(array.len(), 2);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 9);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_all() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        array.remove(1);\\n        array.remove(1);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n}\\n"},"66":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::execution_cache;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field];\\n    fn get_selector(self) -> FunctionSelector;\\n    fn get_name(self) -> str<N>;\\n    fn get_contract_address(self) -> AztecAddress;\\n    fn get_is_static(self) -> bool;\\n}\\n\\n// PrivateCallInterface\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let returns: T = returns_hash.get_preimage();\\n        returns\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns_hash.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateVoidCallInterface\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\\n    }\\n\\n    pub fn call(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticCallInterface\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n        }\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticVoidCallInterface\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicCallInterface\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    gas_opts: GasOpts,\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            gas_opts: GasOpts::default(),\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicVoidCallInterface\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n\\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.set_public_teardown_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticCallInterface\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticVoidCallInterface\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n"},"73":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        gas_settings::GasSettings,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Empty, FromField, Hash, ToField},\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn gas_settings(self) -> GasSettings {\\n        self.inputs.tx_context.gas_settings\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            // for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        // the number of side effects that took place), along with the hash of the return values. We validate these\\n        // by requesting a private kernel iteration in which the return values are constrained to hash\\n        // to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"74":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\\nuse crate::hash::{\\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\\n};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\\n\\npub struct PublicContext {\\n    pub args_hash: Option<Field>,\\n    pub compute_args_hash: fn() -> Field,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\\n        PublicContext { args_hash: Option::none(), compute_args_hash }\\n    }\\n\\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\\n    }\\n\\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\\n    }\\n\\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\\n    }\\n\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_l1_to_l2_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/\\n            self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash,\\n            leaf_index,\\n        );\\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()),\\n            \\"L1-to-L2 message is already nullified\\",\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\\n            \\"Tried to consume nonexistent L1-to-L2 message\\",\\n        );\\n\\n        self.push_nullifier(nullifier);\\n    }\\n\\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { send_l2_to_l1_msg(recipient, content) };\\n    }\\n\\n    pub unconstrained fn call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub unconstrained fn static_call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call_static(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_note_hash(note_hash) };\\n    }\\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_nullifier(nullifier) };\\n    }\\n\\n    pub fn this_address(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            address()\\n        }\\n    }\\n    pub fn msg_sender(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            sender()\\n        }\\n    }\\n    pub fn selector(_self: Self) -> FunctionSelector {\\n        // The selector is the first element of the calldata when calling a public function through dispatch.\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\\n        FunctionSelector::from_field(raw_selector[0])\\n    }\\n    pub fn get_args_hash(mut self) -> Field {\\n        if !self.args_hash.is_some() {\\n            self.args_hash = Option::some((self.compute_args_hash)());\\n        }\\n\\n        self.args_hash.unwrap_unchecked()\\n    }\\n    pub fn transaction_fee(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            transaction_fee()\\n        }\\n    }\\n\\n    pub fn chain_id(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            chain_id()\\n        }\\n    }\\n    pub fn version(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            version()\\n        }\\n    }\\n    pub fn block_number(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            block_number()\\n        }\\n    }\\n    pub fn timestamp(_self: Self) -> u64 {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            timestamp()\\n        }\\n    }\\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_l2_gas()\\n        }\\n    }\\n    pub fn fee_per_da_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_da_gas()\\n        }\\n    }\\n\\n    pub fn l2_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            l2_gas_left()\\n        }\\n    }\\n    pub fn da_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            da_gas_left()\\n        }\\n    }\\n    pub fn is_static_call(_self: Self) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { is_static_call() } == 1\\n    }\\n\\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        let mut out = [0; N];\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\\n        }\\n        out\\n    }\\n\\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n\\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\\n        }\\n    }\\n\\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\\n    where\\n        T: Packable<N>,\\n    {\\n        self.raw_storage_write(storage_slot, value.pack());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn is_static_call() -> Field {\\n    is_static_call_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_public_log(message: [Field]) {\\n    emit_public_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_opcode(gas, address, args)\\n}\\n\\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_static_opcode(gas, address, args)\\n}\\n\\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\\n    calldata_copy_opcode(cdoffset, copy_size)\\n}\\n\\n// `success_copy` is placed immediately after the CALL opcode to get the success value\\nunconstrained fn success_copy() -> bool {\\n    success_copy_opcode()\\n}\\n\\nunconstrained fn returndata_size() -> u32 {\\n    returndata_size_opcode()\\n}\\n\\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\\n    returndata_copy_opcode(rdoffset, copy_size)\\n}\\n\\npub unconstrained fn avm_return(returndata: [Field]) {\\n    return_opcode(returndata)\\n}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\nunconstrained fn avm_revert(revertdata: [Field]) {\\n    revert_opcode(revertdata)\\n}\\n\\nunconstrained fn storage_read(storage_slot: Field) -> Field {\\n    storage_read_opcode(storage_slot)\\n}\\n\\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\\n    storage_write_opcode(storage_slot, value);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(|| 0)\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeIsStaticCall)]\\nunconstrained fn is_static_call_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n// TODO(#11124): rename unencrypted to public in avm\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCalldataCopy)]\\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeReturndataSize)]\\nunconstrained fn returndata_size_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeReturndataCopy)]\\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\\n\\n#[oracle(avmOpcodeReturn)]\\nunconstrained fn return_opcode(returndata: [Field]) {}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\n#[oracle(avmOpcodeRevert)]\\nunconstrained fn revert_opcode(revertdata: [Field]) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeSuccessCopy)]\\nunconstrained fn success_copy_opcode() -> bool {}\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\\n"},"76":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"78":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr","source":"// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\\n\\npub mod private_logs;\\npub mod partial_notes;\\npub mod nonce_discovery;\\n\\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\\n/// one for the combined log and note type ID.\\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\\n\\n/// The maximum length of the packed representation of a note\'s contents. This is limited by private log size, encryption\\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\\npub global MAX_NOTE_PACKED_LEN: u32 =\\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\\n\\npub struct NoteHashAndNullifier {\\n    /// The result of NoteHash::compute_note_hash\\n    pub note_hash: Field,\\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\\n    pub inner_nullifier: Field,\\n}\\n\\n/// A function which takes a note\'s packed content, address of the emitting contract, nonce, storage slot and note type\\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\\n/// address).\\n///\\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\\n///\\n/// ```\\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\\n///     if note_type_id == MyNoteType::get_id() {\\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\\n///\\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n///\\n///         let note_hash = note.compute_note_hash(storage_slot);\\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\\n///             storage_slot\\n///         );\\n///\\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\\n///\\n///         Option::some(\\n///             aztec::discovery::NoteHashAndNullifier {\\n///                 note_hash, inner_nullifier\\n///             }\\n///         )\\n///     } else if note_type_id == MyOtherNoteType::get_id() {\\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\\n///     } else {\\n///         Option::none() // Unknown note type ID\\n///     };\\n/// }\\n/// ```\\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\\n\\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\\n///\\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\\n/// along with its `compute_note_hash_and_nullifier` function.\\npub unconstrained fn discover_new_notes<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    debug_log(\\"Performing note discovery\\");\\n\\n    private_logs::fetch_and_process_private_tagged_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n\\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n}\\n"},"79":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr","source":"use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::MAX_NOTE_HASHES_PER_TX,\\n    debug_log::debug_log_format,\\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\\n    traits::ToField,\\n};\\n\\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\\n/// the complete note information, since it does not include content, storage slot, etc.\\npub struct DiscoveredNoteInfo {\\n    pub nonce: Field,\\n    pub note_hash: Field,\\n    pub inner_nullifier: Field,\\n}\\n\\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\\n/// cases it will contain a single element.\\n///\\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\\npub unconstrained fn attempt_note_nonce_discovery<Env>(\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\\n    let discovered_notes = &mut BoundedVec::new();\\n\\n    debug_log_format(\\n        \\"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\\",\\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\\n    );\\n\\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\\n    // is one of the note hashes created by the transaction.\\n    array::for_each_in_bounded_vec(\\n        unique_note_hashes_in_tx,\\n        |expected_unique_note_hash, i| {\\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\\n\\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\\n            // the note hash at the array index we\'re currently processing.\\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\\n            let hashes = compute_note_hash_and_nullifier(\\n                packed_note_content,\\n                storage_slot,\\n                note_type_id,\\n                contract_address,\\n                candidate_nonce,\\n            )\\n                .expect(f\\"Failed to compute a note hash for note type {note_type_id}\\");\\n\\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\\n\\n            if unique_note_hash == expected_unique_note_hash {\\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn\'t, then\\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\\n                // application already has more direct means of making a call to it fail the transaction.\\n                discovered_notes.push(\\n                    DiscoveredNoteInfo {\\n                        nonce: candidate_nonce,\\n                        note_hash: hashes.note_hash,\\n                        inner_nullifier: hashes.inner_nullifier,\\n                    },\\n                );\\n\\n                // We don\'t exit the loop - it is possible (though rare) for the exact same note content to be present\\n                // multiple times in the same transaction with different nonces. This typically doesn\'t happen due to\\n                // notes containing random values in order to hide their contents.\\n            }\\n        },\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered a total of {0} notes\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    *discovered_notes\\n}\\n"},"80":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr","source":"use crate::{\\n    capsules::CapsuleArray,\\n    discovery::{\\n        ComputeNoteHashAndNullifier,\\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\\n    },\\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\\n    debug_log::debug_log_format,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\\n// TODO(#11630): come up with some sort of slot allocation scheme.\\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\\n\\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\\n/// the packed public content.\\n// TODO(#10273): improve how contract log siloing is handled\\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\\n\\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\\n/// size and extra fields in the log (e.g. the tag).\\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\\n\\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\\n/// log that will complete it and lead to a note being discovered and delivered.\\n#[derive(Serialize, Deserialize)]\\npub(crate) struct DeliveredPendingPartialNote {\\n    pub(crate) note_completion_log_tag: Field,\\n    pub(crate) storage_slot: Field,\\n    pub(crate) note_type_id: Field,\\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\\n    pub(crate) recipient: AztecAddress,\\n}\\n\\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\\n/// notes being delivered to PXE if completed.\\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let pending_partial_notes = CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    );\\n\\n    debug_log_format(\\n        \\"{} pending partial notes\\",\\n        [pending_partial_notes.len() as Field],\\n    );\\n\\n    let mut i = &mut 0;\\n    whyle(\\n        || *i < pending_partial_notes.len(),\\n        || {\\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\\n\\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\\n            if maybe_log.is_none() {\\n                debug_log_format(\\n                    \\"Found no completion logs for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                *i += 1 as u32;\\n                // Note that we\'re not removing the pending partial note from the PXE DB, so we will continue searching\\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\\n                // is somehow removed from the PXE DB.\\n            } else {\\n                debug_log_format(\\n                    \\"Completion log found for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                let log = maybe_log.unwrap();\\n\\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\\n                // that we\'re getting the logs from the expected contract.\\n                // TODO(#10273): improve how contract log siloing is handled\\n                assert_eq(\\n                    log.log_content.get(0),\\n                    contract_address.to_field(),\\n                    \\"Got a public log emitted by a different contract\\",\\n                );\\n\\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\\n                // complete packed content.\\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\\n                let complete_packed_note_content = array::append(\\n                    pending_partial_note.packed_private_note_content,\\n                    packed_public_note_content,\\n                );\\n\\n                let discovered_notes = attempt_note_nonce_discovery(\\n                    log.unique_note_hashes_in_tx,\\n                    log.first_nullifier_in_tx,\\n                    compute_note_hash_and_nullifier,\\n                    contract_address,\\n                    pending_partial_note.storage_slot,\\n                    pending_partial_note.note_type_id,\\n                    complete_packed_note_content,\\n                );\\n\\n                debug_log_format(\\n                    \\"Discovered {0} notes for partial note with tag {1}\\",\\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\\n                );\\n\\n                array::for_each_in_bounded_vec(\\n                    discovered_notes,\\n                    |discovered_note: DiscoveredNoteInfo, _| {\\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\\n                        // temporary node connectivity issue - is simply throwing good enough here?\\n                        assert(\\n                            deliver_note(\\n                                contract_address,\\n                                pending_partial_note.storage_slot,\\n                                discovered_note.nonce,\\n                                complete_packed_note_content,\\n                                discovered_note.note_hash,\\n                                discovered_note.inner_nullifier,\\n                                log.tx_hash,\\n                                pending_partial_note.recipient,\\n                            ),\\n                            \\"Failed to deliver note\\",\\n                        );\\n                    },\\n                );\\n\\n                // Because there is only a single log for a given tag, once we\'ve processed the tagged log then we\\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\\n                // being completed.\\n                pending_partial_notes.remove(*i);\\n\\n                // We don\'t increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\\n                // shifts the elements to the left if the removed element is not the last element.\\n            }\\n        },\\n    );\\n}\\n\\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\\n/// supports looping in unconstrained code.\\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\\n    if condition() {\\n        body();\\n        whyle(condition, body);\\n    }\\n}\\n"},"81":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr","source":"use std::static_assert;\\n\\nuse crate::{\\n    capsules::CapsuleArray,\\n    oracle::note_discovery::{deliver_note, sync_notes},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\\n    debug_log::{debug_log, debug_log_format},\\n};\\n\\nuse crate::discovery::{\\n    ComputeNoteHashAndNullifier,\\n    MAX_NOTE_PACKED_LEN,\\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\\n    partial_notes::{\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\\n    },\\n};\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\\n// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\n\\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\\n/// the note completion log tag).\\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\\n\\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\\n/// public logs that will complete them.\\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\\n    _contract_address: AztecAddress,\\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\\n    // decrypted log, letting us continue the work outside of PXE.\\n    sync_notes();\\n}\\n\\n/// Processes a log\'s ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\\n/// which the notes would\'ve been created (typically the same transaction in which the log was emitted), along with the\\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\\npub unconstrained fn do_process_log<Env>(\\n    contract_address: AztecAddress,\\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let log_plaintext = decrypt_log(log, recipient);\\n\\n    // The first thing to do after decrypting the log is to determine what type of private log we\'re processing. We\\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\\n    // improved upon in the future to also handle events, etc.\\n\\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\\n        destructure_log_plaintext(log_plaintext);\\n\\n    if log_type_id == 0 {\\n        debug_log(\\"Processing private note log\\");\\n\\n        attempt_note_discovery(\\n            contract_address,\\n            tx_hash,\\n            unique_note_hashes_in_tx,\\n            first_nullifier_in_tx,\\n            recipient,\\n            compute_note_hash_and_nullifier,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n        );\\n    } else if log_type_id == 1 {\\n        debug_log(\\"Processing partial note private log\\");\\n\\n        process_partial_note_private_log(\\n            contract_address,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n            recipient,\\n        );\\n    } else {\\n        // TODO(#11569): handle events\\n        debug_log_format(\\n            \\"Unknown log type id {0} (probably belonging to an event log)\\",\\n            [log_type_id],\\n        );\\n    }\\n}\\n\\nunconstrained fn destructure_log_plaintext(\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\\n    // `storage_slot` and `note_type_id` must be updated as well.\\n    static_assert(\\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\\n        \\"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\\",\\n    );\\n    let storage_slot = log_plaintext.get(0);\\n\\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\\n    // distinguish private note logs and partial note logs.\\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we\'d be able to\\n    // leverage enums and tagged unions to achieve this goal.\\n    let combined_type_id = log_plaintext.get(1);\\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\\n\\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    (storage_slot, note_type_id, log_type_id, log_payload)\\n}\\n\\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\\n/// suspected the note was created.\\npub unconstrained fn attempt_note_discovery<Env>(\\n    contract_address: AztecAddress,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) {\\n    let discovered_notes = attempt_note_nonce_discovery(\\n        unique_note_hashes_in_tx,\\n        first_nullifier_in_tx,\\n        compute_note_hash_and_nullifier,\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered {0} notes from a private log\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    array::for_each_in_bounded_vec(\\n        discovered_notes,\\n        |discovered_note: DiscoveredNoteInfo, _| {\\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\\n            // issue, and we should perhaps not have marked the tag index as taken.\\n            assert(\\n                deliver_note(\\n                    contract_address,\\n                    storage_slot,\\n                    discovered_note.nonce,\\n                    packed_note_content,\\n                    discovered_note.note_hash,\\n                    discovered_note.inner_nullifier,\\n                    tx_hash,\\n                    recipient,\\n                ),\\n                \\"Failed to deliver note\\",\\n            );\\n        },\\n    );\\n}\\n\\nunconstrained fn process_partial_note_private_log(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    recipient: AztecAddress,\\n) {\\n    // We store the information of the partial note we found so that we can later search for the public log that will\\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\\n    static_assert(\\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\\n        \\"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\\",\\n    );\\n\\n    let pending = DeliveredPendingPartialNote {\\n        note_completion_log_tag: log_payload.get(0),\\n        storage_slot,\\n        note_type_id,\\n        packed_private_note_content: array::subbvec(log_payload, 1),\\n        recipient,\\n    };\\n\\n    CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    )\\n        .push(pending);\\n}\\n"},"95":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::{Hash, ToField},\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"107":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\\n};\\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\\n\\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\\nuse protocol_types::traits::{Hash, ToField};\\n\\nmod test;\\n\\npub trait PublicStorageHistoricalRead {\\n    fn public_storage_historical_read(\\n        header: BlockHeader,\\n        storage_slot: Field,\\n        contract_address: AztecAddress,\\n    ) -> Field;\\n}\\n\\nimpl PublicStorageHistoricalRead for BlockHeader {\\n    fn public_storage_historical_read(\\n        self,\\n        storage_slot: Field,\\n        contract_address: AztecAddress,\\n    ) -> Field {\\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\\n        let public_data_tree_index = poseidon2_hash_with_separator(\\n            [contract_address.to_field(), storage_slot],\\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\\n        );\\n\\n        // 2) Get the membership witness for the tree index.\\n        // Safety: The witness is only used as a \\"magical value\\" that makes the proof below pass. Hence it\'s safe.\\n        let witness = unsafe {\\n            get_public_data_witness(\\n                self.global_variables.block_number as u32,\\n                public_data_tree_index,\\n            )\\n        };\\n\\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\\n        // (slot, next index and next slot).\\n        assert_eq(\\n            self.state.partial.public_data_tree.root,\\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\\n            \\"Proving public value inclusion failed\\",\\n        );\\n\\n        // 4) Now that we know the preimage is valid, we determine the value that\'s represented by this tree entry. Here\\n        // we have two scenarios:\\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\\n        // 2. The entry was never initialized, and the value is default zero (the default)\\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\\n        let preimage = witness.leaf_preimage;\\n\\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\\n\\n        let value = if is_in_range {\\n            0\\n        } else {\\n            assert_eq(\\n                preimage.slot,\\n                public_data_tree_index,\\n                \\"Public data tree index doesn\'t match witness\\",\\n            );\\n            preimage.value\\n        };\\n\\n        value\\n    }\\n}\\n"},"116":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr","source":"use super::utils::compute_fn_selector;\\nuse std::panic;\\n\\n/// Returns an `fn public_dispatch(...)` function for the given module that\'s assumed to be an Aztec contract.\\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\\n    let functions = m.functions();\\n    let functions =\\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\\"public\\"));\\n\\n    let unit = get_type::<()>();\\n\\n    let ifs = functions.map(|function: FunctionDefinition| {\\n        let name = function.name();\\n        let parameters = function.parameters();\\n        let return_type = function.return_type();\\n\\n        let selector: Field = compute_fn_selector(function);\\n\\n        let mut parameters_size = 0;\\n        for param in parameters {\\n            parameters_size += size_in_fields(param.1);\\n        }\\n\\n        let initial_read = if parameters.len() == 0 {\\n            quote {}\\n        } else {\\n            // The initial calldata_copy offset is 1 to skip the Field selector\\n            // The expected calldata is the serialization of\\n            // - FunctionSelector: the selector of the function intended to dispatch\\n            // - Parameters: the parameters of the function intended to dispatch\\n            // That is, exactly what is expected for a call to the target function,\\n            // but with a selector added at the beginning.\\n            quote {\\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\\n            }\\n        };\\n\\n        let parameter_index = &mut 0;\\n        let reads = parameters.map(|param: (Quoted, Type)| {\\n            let parameter_index_value = *parameter_index;\\n            let param_name = f\\"arg{parameter_index_value}\\".quoted_contents();\\n            let param_type = param.1;\\n            let read = quote {\\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\\n            };\\n            *parameter_index += 1;\\n            quote { $read }\\n        });\\n        let read = reads.join(quote { });\\n\\n        let mut args = &[];\\n        for parameter_index in 0..parameters.len() {\\n            let param_name = f\\"arg{parameter_index}\\".quoted_contents();\\n            args = args.push_back(quote { $param_name });\\n        }\\n\\n        let args = args.join(quote { , });\\n        let call = quote { $name($args) };\\n\\n        let return_code = if return_type == unit {\\n            quote {\\n                $call;\\n                // Force early return.\\n                dep::aztec::context::public_context::avm_return([]);\\n            }\\n        } else {\\n            quote {\\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\\n            }\\n        };\\n\\n        let if_ = quote {\\n            if selector == $selector {\\n                $initial_read\\n                $read\\n                $return_code\\n            }\\n        };\\n        if_\\n    });\\n\\n    if ifs.len() == 0 {\\n        // No dispatch function if there are no public functions\\n        quote {}\\n    } else {\\n        let ifs = ifs.push_back(quote { panic(f\\"Unknown selector {selector}\\") });\\n        let dispatch = ifs.join(quote {  });\\n\\n        let body = quote {\\n            // We mark this as public because our whole system depends on public\\n            // functions having this attribute. However, the public MACRO will\\n            // handle the public_dispatch function specially and do nothing.\\n            #[public]\\n            pub unconstrained fn public_dispatch(selector: Field) {\\n                $dispatch\\n            }\\n        };\\n\\n        body\\n    }\\n}\\n\\ncomptime fn size_in_fields(typ: Type) -> u32 {\\n    let size = array_size_in_fields(typ);\\n    let size = size.or_else(|| bool_size_in_fields(typ));\\n    let size = size.or_else(|| constant_size_in_fields(typ));\\n    let size = size.or_else(|| field_size_in_fields(typ));\\n    let size = size.or_else(|| int_size_in_fields(typ));\\n    let size = size.or_else(|| str_size_in_fields(typ));\\n    let size = size.or_else(|| struct_size_in_fields(typ));\\n    let size = size.or_else(|| tuple_size_in_fields(typ));\\n    if size.is_some() {\\n        size.unwrap()\\n    } else {\\n        panic(f\\"Can\'t determine size in fields of {typ}\\")\\n    }\\n}\\n\\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_array().and_then(|typ: (Type, Type)| {\\n        let (typ, element_size) = typ;\\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\\n    })\\n}\\n\\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_bool() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_field() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.as_integer().is_some() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_constant()\\n}\\n\\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_str().map(|typ| size_in_fields(typ))\\n}\\n\\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\\n        let struct_type = typ.0;\\n        let generics = typ.1;\\n        let mut size = 0;\\n        for field in struct_type.fields(generics) {\\n            size += size_in_fields(field.1);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_tuple().map(|types: [Type]| {\\n        let mut size = 0;\\n        for typ in types {\\n            size += size_in_fields(typ);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn get_type<T>() -> Type {\\n    let t: T = std::mem::zeroed();\\n    std::meta::type_of(t)\\n}\\n"},"123":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\\n    notes::NOTES,\\n    utils::{\\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\\n        module_has_storage,\\n    },\\n};\\nuse protocol_types::meta::generate_serialize_to_fields;\\nuse std::meta::type_of;\\n\\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\\n    // Private Kernel Circuit.\\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\\n    // about the execution context (e.g. the caller).\\n    let original_params = f.parameters();\\n    f.set_parameters(&[(\\n        quote { inputs },\\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\\n    )]\\n        .append(original_params));\\n\\n    let mut body = f.body().as_block().unwrap();\\n\\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we\'ve received\\n    // the correct values.\\n    // TODO: Optimize args_hasher for small number of arguments\\n    let args_hasher_name = quote { args_hasher };\\n    let args_hasher = original_params.fold(\\n        quote {\\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n        },\\n        |args_hasher, param: (Quoted, Type)| {\\n            let (name, typ) = param;\\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\\n            quote {\\n                $args_hasher\\n                $appended_arg\\n            }\\n        },\\n    );\\n\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\\n    // and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\\n    // circuit expects.\\n    let return_value_var_name = quote { macro__returned__values };\\n\\n    let return_value_type = f.return_type();\\n    let return_value = if body.len() == 0 {\\n        quote {}\\n    } else if return_value_type != type_of(()) {\\n        // The original return value is passed to a second args hasher which the context receives.\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        let return_value = last_body_expr.quoted();\\n        let return_value_assignment =\\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\\n        let return_hasher_name = quote { return_hasher };\\n        let return_value_into_hasher =\\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\\n\\n        body = body_without_return;\\n\\n        quote {\\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n            $return_value_assignment\\n            $return_value_into_hasher\\n            context.set_return_hash($return_hasher_name);\\n        }\\n    } else {\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        if !last_body_expr.has_semicolon()\\n            & last_body_expr.as_for().is_none()\\n            & last_body_expr.as_assert().is_none()\\n            & last_body_expr.as_for_range().is_none()\\n            & last_body_expr.as_assert_eq().is_none()\\n            & last_body_expr.as_let().is_none() {\\n            let unused_return_value_name = f\\"_{return_value_var_name}\\".quoted_contents();\\n            body = body_without_return.push_back(\\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\\n            );\\n        }\\n        quote {}\\n    };\\n\\n    let context_finish = quote { context.finish() };\\n\\n    let to_prepend = quote {\\n        $args_hasher\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n        $note_discovery_call\\n    };\\n\\n    let to_append = quote {\\n        $return_value\\n        $mark_as_initialized\\n        $context_finish\\n    };\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n    f.set_return_type(\\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\\n            .as_type(),\\n    );\\n    f.set_return_data();\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\\n    let original_params = f.parameters();\\n    let args_len = original_params\\n        .map(|(name, typ): (Quoted, Type)| {\\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\\n        })\\n        .fold(0, |acc: u32, val: u32| acc + val);\\n\\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\\n        // We start from 1 because we skip the selector for the dispatch function.\\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\\n        dep::aztec::hash::hash_args_array(serialized_args)\\n        });\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n        // referenced. We instead ignore \'unused variable\' warnings for it.\\n        quote {\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n    };\\n\\n    let to_append = quote {\\n        $mark_as_initialized\\n    };\\n\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n\\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\\n    // bytecode.\\n    f.set_unconstrained(true);\\n    f.set_return_public(true);\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\\n    // Top-level unconstrained fns are contract entrypoints, but they\'re not explicitly designated in any way. They\'re\\n    // the fallback case for a function that matches no other rules.\\n    // TODO(#12743): improve this\\n\\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\\n    // public, but which *are* contract entrypoints (i.e. they\'re not opting out via the #[test] or\\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\\n        !is_fn_private(f)\\n            & !is_fn_public(f)\\n            & !f.has_named_attribute(\\"contract_library_method\\")\\n            & !f.has_named_attribute(\\"test\\")\\n    });\\n\\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\\n    // https://github.com/noir-lang/noir/issues/7714). We can\'t simply print a message since that\'d otherwise break the\\n    // output of utils such as `nargo test --list-tests`.\\n    // // We don\'t expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr\'s\\n    // // #[private] macro, possibly resulting in a non-standard interface).\\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n    //     !f.is_unconstrained()\\n    // }) {\\n    //     let name = f.name();\\n    //     warn(\\n    //         f\\"found private contract function \'{name}\' which does not have the #[private] attribute - make sure you know what you\'re doing!\\",\\n    //     );\\n    // }\\n\\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n        f.is_unconstrained()\\n    }) {\\n        transform_top_level_unconstrained(f);\\n    }\\n}\\n\\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $storage_init\\n        $note_discovery_call\\n    };\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\\n    f.set_return_public(true);\\n    f.set_body(modified_body);\\n}\\n\\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called internally\\";\\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\\n}\\n\\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called statically\\";\\n    if is_fn_private(f) {\\n        // Here `context` is of type context::PrivateContext\\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\\n    } else {\\n        // Here `context` is of type context::PublicContext\\n        quote { assert(context.is_static_call(), $assertion_message); }\\n    }\\n}\\n\\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\\n/// available for the current execution.\\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\\n    quote {\\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\\n        /// safe to call.\\n        unsafe {\\n            dep::aztec::discovery::discover_new_notes(\\n                context.this_address(),\\n                _compute_note_hash_and_nullifier,\\n            );\\n        };\\n    }\\n}\\n"},"124":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/mod.nr","source":"pub mod dispatch;\\npub mod functions;\\npub mod utils;\\npub mod notes;\\npub mod storage;\\npub mod events;\\n\\nuse functions::{\\n    stub_registry,\\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\\n};\\nuse notes::{generate_note_export, NOTES};\\nuse storage::STORAGE_LAYOUT_NAME;\\n\\nuse dispatch::generate_public_dispatch;\\nuse utils::{get_trait_impl_method, module_has_storage};\\n\\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\\n\\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\\npub comptime fn aztec(m: Module) -> Quoted {\\n    let interface = generate_contract_interface(m);\\n\\n    find_and_transform_top_level_unconstrained_fns(m);\\n\\n    let contract_library_method_compute_note_hash_and_nullifier =\\n        generate_contract_library_method_compute_note_hash_and_nullifier();\\n    let process_log = generate_process_log();\\n    let note_exports = generate_note_exports();\\n    let public_dispatch = generate_public_dispatch(m);\\n    let sync_notes = generate_sync_notes();\\n\\n    quote {\\n        $note_exports\\n        $interface\\n        $contract_library_method_compute_note_hash_and_nullifier\\n        $process_log\\n        $public_dispatch\\n        $sync_notes\\n    }\\n}\\n\\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\\n    let module_name = m.name();\\n    let contract_stubs = stub_registry::get(m);\\n    let fn_stubs_quote = if contract_stubs.is_some() {\\n        contract_stubs.unwrap().join(quote {})\\n    } else {\\n        quote {}\\n    };\\n\\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\\n    let storage_layout_getter = if has_storage_layout {\\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\\n        quote {\\n            pub fn storage_layout() -> StorageLayoutFields {\\n                $storage_layout_name.fields\\n            }\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    let library_storage_layout_getter = if has_storage_layout {\\n        quote {\\n            #[contract_library_method]\\n            $storage_layout_getter\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    quote {\\n        pub struct $module_name {\\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\\n        }\\n\\n        impl $module_name {\\n            $fn_stubs_quote\\n\\n            pub fn at(\\n                addr: aztec::protocol_types::address::AztecAddress\\n            ) -> Self {\\n                Self { target_contract: addr }\\n            }\\n\\n            pub fn interface() -> Self {\\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n            }\\n\\n            $storage_layout_getter\\n        }\\n\\n        #[contract_library_method]\\n        pub fn at(\\n            addr: aztec::protocol_types::address::AztecAddress\\n        ) -> $module_name {\\n            $module_name { target_contract: addr }\\n        }\\n\\n        #[contract_library_method]\\n        pub fn interface() -> $module_name {\\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n        }\\n\\n        $library_storage_layout_getter\\n\\n    }\\n}\\n\\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        let max_note_packed_len = notes.fold(\\n            0,\\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\\n                if len > acc {\\n                    len\\n                } else {\\n                    acc\\n                }\\n            },\\n        );\\n\\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\\n            panic(\\n                f\\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\\",\\n            );\\n        }\\n\\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\\n\\n        let mut if_note_type_id_match_statements_list = &[];\\n        for i in 0..notes.len() {\\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\\n\\n            let get_note_type_id = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteType },\\n                quote { get_id },\\n            );\\n            let unpack = get_trait_impl_method(\\n                typ,\\n                quote { crate::protocol_types::traits::Packable<_> },\\n                quote { unpack },\\n            );\\n\\n            let compute_note_hash = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_note_hash },\\n            );\\n\\n            let compute_nullifier_unconstrained = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_nullifier_unconstrained },\\n            );\\n\\n            let if_or_else_if = if i == 0 {\\n                quote { if }\\n            } else {\\n                quote { else if }\\n            };\\n\\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\\n                quote {\\n                    $if_or_else_if note_type_id == $get_note_type_id() {\\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\\n                        // length, since we\'re about to interpret it\'s raw storage as a fixed-size array by calling the\\n                        // unpack function on it.\\n                        let expected_len = $packed_note_length;\\n                        let actual_len = packed_note.len();\\n                        assert(\\n                            actual_len == expected_len,\\n                            f\\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\\"\\n                        );\\n\\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n\\n                        let note_hash = $compute_note_hash(note, storage_slot);\\n    \\n                        // The note discovery process finds settled notes, that is, notes that were created in prior\\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n                            aztec::note::retrieved_note::RetrievedNote{ \\n                                note, \\n                                contract_address, \\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \\n                            }, \\n                            storage_slot,\\n                        );\\n\\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\\n\\n                        Option::some(\\n                            aztec::discovery::NoteHashAndNullifier {\\n                                note_hash, inner_nullifier\\n                            }\\n                        )\\n                    }\\n                },\\n            );\\n        }\\n\\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\\n\\n        quote {\\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\\n            /// tree with `nonce`.\\n            ///\\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\\n            /// and `attempt_note_discovery`.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                storage_slot: Field,\\n                note_type_id: Field,\\n                contract_address: aztec::protocol_types::address::AztecAddress,\\n                nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                $if_note_type_id_match_statements\\n                else {\\n                    Option::none()\\n                }\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            /// This contract does not use private notes, so this function should never be called as it will\\n            /// unconditionally fail.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                _storage_slot: Field,\\n                _note_type_id: Field,\\n                _contract_address: aztec::protocol_types::address::AztecAddress,\\n                _nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_process_log() -> Quoted {\\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\\n    // and perform note discovery of either private notes or partial notes.\\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\\n    // that function.\\n\\n    // We\'ll produce the entire body of the function in one go and then insert it into the function.\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        quote {\\n            unconstrained fn process_log(\\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                tx_hash: Field,\\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                first_nullifier_in_tx: Field,\\n                recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n                // unconstrained execution context since it will not be available otherwise.\\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n                // TODO(#10727): allow other contracts to process logs and deliver notes\\n                let contract_address = context.this_address();\\n\\n                aztec::discovery::private_logs::do_process_log(\\n                    contract_address,\\n                    log_ciphertext,\\n                    tx_hash,\\n                    unique_note_hashes_in_tx,\\n                    first_nullifier_in_tx,\\n                    recipient,\\n                    _compute_note_hash_and_nullifier,\\n                );\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            unconstrained fn process_log(\\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                _tx_hash: Field,\\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                _first_nullifier_in_tx: Field,\\n                _recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_note_exports() -> Quoted {\\n    let notes = NOTES.values();\\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it\'s only used when\\n    // generating partial note helper functions.\\n    notes\\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\\n            generate_note_export(s, note_type_id, fields)\\n        })\\n        .join(quote {})\\n}\\n\\ncomptime fn generate_sync_notes() -> Quoted {\\n    let note_discovery_call = create_note_discovery_call();\\n    quote {\\n        unconstrained fn sync_notes() {\\n            // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n            // unconstrained execution context since it will not be available otherwise.\\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n            $note_discovery_call\\n        }\\n    }\\n}\\n"},"126":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr","source":"use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\\n\\nuse super::utils::AsStrQuote;\\nuse super::utils::get_storage_size;\\nuse super::utils::is_note;\\n\\n/// Stores a map from a module to the name of the struct that describes its storage layout.\\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\\n    UHashMap::default();\\n\\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\\n/// should have this macro (or `storage_no_init`) applied to it.\\n/// The contract\'s storage is accessed via the `storage` variable, which will will automatically be made available in\\n/// all functions as an instance of the struct this macro was applied to.\\npub comptime fn storage(s: TypeDefinition) -> Quoted {\\n    // This macro performs three things:\\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\\n    //    functions will have the storage variable injected and initialized via the `init` function.\\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\\n    //    macro.\\n    let mut slot: u32 = 1;\\n    let mut storage_vars_constructors = &[];\\n    let mut storage_layout_fields = &[];\\n    let mut storage_layout_constructors = &[];\\n\\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\\n    //let mut new_storage_fields = &[];\\n    //let context_generic = s.add_generic(\\"Context\\");\\n    for field in s.fields_as_written() {\\n        // FIXME: This doesn\'t handle field types with generics\\n        let (name, typ) = field;\\n        let (storage_field_constructor, storage_size) =\\n            generate_storage_field_constructor(typ, quote { $slot }, false);\\n        storage_vars_constructors =\\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\\n        // a contract.\\n        storage_layout_fields =\\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\\n        storage_layout_constructors = storage_layout_constructors.push_back(\\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\\n        );\\n        //let with_context_generic = add_context_generic(typ, context_generic);\\n        //println(with_context_generic);\\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\\n        slot += storage_size;\\n    }\\n\\n    //s.set_fields(new_storage_fields);\\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\\n    let storage_impl = quote {\\n        impl<Context> Storage<Context> {\\n            fn init(context: Context) -> Self {\\n                Self {\\n                    $storage_vars_constructors\\n                }\\n            }\\n        }\\n    };\\n\\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\\n\\n    let module = s.module();\\n    let module_name = module.name();\\n    let storage_layout_name = f\\"STORAGE_LAYOUT_{module_name}\\".quoted_contents();\\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\\n\\n    quote {\\n        $storage_impl\\n\\n        pub struct StorageLayoutFields {\\n            $storage_layout_fields\\n        }\\n\\n        pub struct StorageLayout<let N: u32> {\\n            pub contract_name: str<N>,\\n            pub fields: StorageLayoutFields\\n        }\\n\\n        #[abi(storage)]\\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\\n            contract_name: $module_name_str,\\n            fields: StorageLayoutFields { $storage_layout_constructors }\\n        };\\n    }\\n}\\n\\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\\n/// allocation. Similarly, no `StorageLayout` struct will be created.\\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\\npub comptime fn storage_no_init(_s: TypeDefinition) {\\n    // All `storage` does is provide the `init` implementation, so we don\'t need to do anything here. Applying this\\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\\n    // the `storage` variable.\\n}\\n\\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\\n/// i.e. how many contiguous storage slots the variable requires.\\ncomptime fn generate_storage_field_constructor(\\n    typ: Type,\\n    slot: Quoted,\\n    parent_is_map: bool,\\n) -> (Quoted, u32) {\\n    assert(\\n        typ.as_data_type().is_some(),\\n        \\"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\\",\\n    );\\n    let (container_struct, generics) = typ.as_data_type().unwrap();\\n    let struct_name = container_struct.name();\\n\\n    if is_storage_map(typ) {\\n        // Map state variables recursively initialize their contents - this includes nested maps.\\n        let (value_constructor, _) =\\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\\n    } else {\\n        let storage_size = if parent_is_map {\\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\\n            // in slots very far away from one another.\\n            1\\n        } else {\\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\\n            let stored_struct = container_struct_generics[0];\\n\\n            if is_note(stored_struct) {\\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\\n                // identifier.\\n                1\\n            } else {\\n                get_storage_size(typ)\\n            }\\n        };\\n\\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\\n        (quote { $struct_name::new(context, $slot)}, storage_size)\\n    }\\n}\\n\\n/// Returns true if `typ` is `state_vars::map::Map`.\\ncomptime fn is_storage_map(typ: Type) -> bool {\\n    if typ.as_data_type().is_some() {\\n        let (def, generics) = typ.as_data_type().unwrap();\\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\\n            let maybe_key = generics[0];\\n            let maybe_value = generics[1];\\n            let maybe_context = generics[2];\\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\\n        } else {\\n            quote {()}.as_type()\\n        };\\n        typ == maybe_map\\n    } else {\\n        false\\n    }\\n}\\n\\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\\n    let (def, mut generics) = typ.as_data_type().expect(\\n        f\\"Storage containers must be generic structs of the form `Container<..., Context>`\\",\\n    );\\n    let name = def.name();\\n\\n    if is_storage_map(typ) {\\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\\n        generics[generics.len() - 1] = context_generic;\\n    } else {\\n        generics[generics.len() - 1] = context_generic;\\n    }\\n\\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\\n    quote { $name<$generics> }.as_type()\\n}\\n"},"128":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\\n};\\n\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    merkle_tree::root::root_from_sibling_path,\\n};\\n\\npub fn process_l1_to_l2_message(\\n    l1_to_l2_root: Field,\\n    contract_address: AztecAddress,\\n    portal_contract_address: EthAddress,\\n    chain_id: Field,\\n    version: Field,\\n    content: Field,\\n    secret: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let secret_hash = compute_secret_hash(secret);\\n    let message_hash = compute_l1_to_l2_message_hash(\\n        portal_contract_address,\\n        chain_id,\\n        contract_address,\\n        version,\\n        content,\\n        secret_hash,\\n        leaf_index,\\n    );\\n\\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\\n    // get from an oracle.\\n    // Safety: The witness is only used as a \\"magical value\\" that makes the merkle proof below pass. Hence it\'s safe.\\n    let (_leaf_index, sibling_path) =\\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\\n\\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\\n    assert_eq(root, l1_to_l2_root, \\"Message not in state\\");\\n\\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\\n}\\n"},"145":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\\n/// data was already stored at this slot, it is overwritten.\\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\\nwhere\\n    T: Serialize<N>,\\n{\\n    let serialized = value.serialize();\\n    store_oracle(contract_address, slot, serialized);\\n}\\n\\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\\n/// nothing was stored at the given slot.\\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\\nwhere\\n    T: Deserialize<N>,\\n{\\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\\n}\\n\\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\\n    delete_oracle(contract_address, slot);\\n}\\n\\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\\npub unconstrained fn copy(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {\\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\\n}\\n\\n#[oracle(storeCapsule)]\\nunconstrained fn store_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    values: [Field; N],\\n) {}\\n\\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\\n/// have.\\n///\\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\\n#[oracle(loadCapsule)]\\nunconstrained fn load_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    array_len: u32,\\n) -> Option<[Field; N]> {}\\n\\n#[oracle(deleteCapsule)]\\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\\n\\n#[oracle(copyCapsule)]\\nunconstrained fn copy_oracle(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {}\\n\\nmod test {\\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\\n    // oracles are hooked up correctly.\\n\\n    use crate::{\\n        oracle::capsules::{copy, delete, load, store},\\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\\n    };\\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        let env = TestEnvironment::new();\\n        env.contract_address()\\n    }\\n\\n    global SLOT: Field = 1;\\n\\n    #[test]\\n    unconstrained fn stores_and_loads() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\\n    }\\n\\n    #[test]\\n    unconstrained fn store_overwrites() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        let new_value = MockStruct::new(7, 8);\\n        store(contract_address, SLOT, new_value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\\n    }\\n\\n    #[test]\\n    unconstrained fn loads_empty_slot() {\\n        let contract_address = setup();\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_stored_value() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n        delete(contract_address, SLOT);\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_empty_slot() {\\n        let contract_address = setup();\\n\\n        delete(contract_address, SLOT);\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_non_overlapping_values() {\\n        let contract_address = setup();\\n\\n        let src = 5;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 10;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 1;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 2;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 2;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 1;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\\n    }\\n\\n    #[test(should_fail_with = \\"copy empty slot\\")]\\n    unconstrained fn cannot_copy_empty_values() {\\n        let contract_address = setup();\\n\\n        copy(contract_address, SLOT, SLOT, 1);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_store_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let value = MockStruct::new(5, 6);\\n        store(other_contract_address, SLOT, value);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_load_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_delete_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        delete(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_copy_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        copy(other_contract_address, SLOT, SLOT, 0);\\n    }\\n}\\n"},"146":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"147":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"148":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"150":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use crate::utils::array;\\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\\n\\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\\n/// its existence.\\npub unconstrained fn get_l1_to_l2_membership_witness(\\n    contract_address: AztecAddress,\\n    message_hash: Field,\\n    secret: Field,\\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\\n    let returned_message =\\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\\n    let leaf_index = returned_message[0];\\n    let sibling_path = array::subarray(returned_message, 1);\\n\\n    (leaf_index, sibling_path)\\n}\\n\\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\\n#[oracle(getL1ToL2MembershipWitness)]\\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\\n    _contract_address: AztecAddress,\\n    _message_hash: Field,\\n    _secret: Field,\\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\\n"},"153":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use crate::utils::array;\\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\\n\\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\\n\\npub struct PublicDataWitness {\\n    pub index: Field,\\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\\n}\\n\\n#[oracle(getPublicDataTreeWitness)]\\nunconstrained fn get_public_data_witness_oracle(\\n    _block_number: u32,\\n    _public_data_tree_index: Field,\\n) -> [Field; PUBLIC_DATA_WITNESS] {}\\n\\npub unconstrained fn get_public_data_witness(\\n    block_number: u32,\\n    public_data_tree_index: Field,\\n) -> PublicDataWitness {\\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\\n    PublicDataWitness {\\n        index: fields[0],\\n        leaf_preimage: PublicDataTreeLeafPreimage {\\n            slot: fields[1],\\n            value: fields[2],\\n            next_index: fields[3] as u32,\\n            next_slot: fields[4],\\n        },\\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\\n    }\\n}\\n"},"158":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr","source":"use crate::discovery::MAX_NOTE_PACKED_LEN;\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\\n};\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\\n/// available for later querying via the `get_notes` oracle.\\npub unconstrained fn sync_notes() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n\\n/// Informs PXE of a note\'s existence so that it can later be retrieved by the `getNotes` oracle. The note will be\\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\\n///\\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\\n///\\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\\n/// other accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized.\\n///\\n/// Returns true if the note was successfully delivered and added to PXE\'s database.\\npub unconstrained fn deliver_note(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {\\n    deliver_note_oracle(\\n        contract_address,\\n        storage_slot,\\n        nonce,\\n        packed_note,\\n        note_hash,\\n        nullifier,\\n        tx_hash,\\n        recipient,\\n    )\\n}\\n\\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\\n/// is the data required in order to discover notes that are being delivered in a log.\\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\\n// log.\\npub struct LogWithTxData {\\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\\n    pub tx_hash: Field,\\n    /// The array of new note hashes created by `tx_hash`\\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    /// The first nullifier created by `tx_hash`\\n    pub first_nullifier_in_tx: Field,\\n}\\n\\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\\n/// the tag is the first field in the log\'s content. Returns `Option::none` if no such log exists. Throws if more than\\n/// one log with that tag exists.\\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\\n// TODO(#11627): handle multiple logs with the same tag.\\n// TODO(#10273): improve contract siloing of logs, don\'t introduce an extra field.\\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\\n    get_log_by_tag_oracle(tag)\\n}\\n\\n#[oracle(deliverNote)]\\nunconstrained fn deliver_note_oracle(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {}\\n\\n#[oracle(getLogByTag)]\\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\\n"},"159":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{\\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n    traits::{Deserialize, FromField, Packable},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\\n    // call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\\n    // call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\\n) -> [Option<RetrievedNote<Note>>; S]\\nwhere\\n    Note: NoteType + Packable<N>,\\n{\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let maybe_nonce = fields[read_offset];\\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\\n            let packed_note = array::subarray(fields, read_offset + 2);\\n\\n            let note = Note::unpack(packed_note);\\n            let retrieved_note = RetrievedNote {\\n                note,\\n                contract_address,\\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\\n            };\\n\\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n"},"162":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\\n\\n#[oracle(storageRead)]\\nunconstrained fn storage_read_oracle<let N: u32>(\\n    address: Field,\\n    storage_slot: Field,\\n    block_number: Field,\\n    length: Field,\\n) -> [Field; N] {}\\n\\npub unconstrained fn raw_storage_read<let N: u32>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32,\\n) -> [Field; N] {\\n    storage_read_oracle(\\n        address.to_field(),\\n        storage_slot,\\n        block_number as Field,\\n        N as Field,\\n    )\\n}\\n\\npub unconstrained fn storage_read<T, let N: u32>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32,\\n) -> T\\nwhere\\n    T: Packable<N>,\\n{\\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\\n}\\n\\nmod tests {\\n    use crate::oracle::storage::{raw_storage_read, storage_read};\\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\\n\\n    use crate::test::mocks::mock_struct::MockStruct;\\n    use std::test::OracleMock;\\n\\n    global address: AztecAddress = AztecAddress::from_field(29);\\n    global slot: Field = 7;\\n    global block_number: u32 = 17;\\n\\n    #[test]\\n    unconstrained fn test_raw_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.pack());\\n\\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\\n        assert_eq(read[0], 13);\\n        assert_eq(read[1], 42);\\n    }\\n\\n    #[test]\\n    unconstrained fn test_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.pack());\\n\\n        let read: MockStruct = storage_read(address, slot, block_number);\\n        assert_eq(read.a, 13);\\n        assert_eq(read.b, 42);\\n    }\\n}\\n"},"164":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\\n\\n// docs:start:map\\npub struct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V\\n    where\\n        K: ToField,\\n    {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"171":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\\n    state_vars::storage::Storage,\\n    utils::with_hash::WithHash,\\n};\\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\\n\\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\\n/// contexts.\\n///\\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\\n///\\n/// This is valuable when T packs to multiple fields, as it maintains \\"almost constant\\" verification overhead\\n/// regardless of the original data size.\\n///\\n/// # Optimizing private reads in your contract\\n/// Given that reading T from public immutable in private has \\"almost constant\\" constraints cost for different sizes\\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\\n/// typically be some kind of configuration set up during contract initialization. E.g.:\\n///\\n/// ```noir\\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\\n/// use std::meta::derive;\\n///\\n/// #[derive(Eq, Packable)]\\n/// pub struct Config \\\\{\\n///     pub address_1: AztecAddress,\\n///     pub value_1: u128,\\n///     pub value_2: u64,\\n///     ...\\n/// }\\n/// ```\\n///\\n// docs:start:public_immutable_struct\\npub struct PublicImmutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_immutable_struct\\n\\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\\n/// fields.\\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\\nwhere\\n    WithHash<T, M>: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<T, Context> PublicImmutable<T, Context> {\\n    // docs:start:public_immutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicImmutable { context, storage_slot }\\n    }\\n    // docs:end:public_immutable_struct_new\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\\nwhere\\n    T: Packable<T_PACKED_LEN> + Eq,\\n{\\n    // docs:start:public_immutable_struct_write\\n    pub fn initialize(self, value: T) {\\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\\n        let init_field: Field = self.context.storage_read(initialization_slot);\\n        assert(init_field == 0, \\"PublicImmutable already initialized\\");\\n\\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\\n        self.context.storage_write(initialization_slot, 0xdead);\\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\\n    }\\n    // docs:end:public_immutable_struct_write\\n\\n    // Note that we don\'t access the context, but we do call oracles that are only available in public\\n    // docs:start:public_immutable_struct_read\\n    pub fn read(self) -> T {\\n        WithHash::public_storage_read(*self.context, self.storage_slot)\\n    }\\n    // docs:end:public_immutable_struct_read\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\\nwhere\\n    T: Packable<T_PACKED_LEN> + Eq,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\\n    }\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\\nwhere\\n    T: Packable<T_PACKED_LEN> + Eq,\\n{\\n    pub fn read(self) -> T {\\n        WithHash::historical_public_storage_read(\\n            self.context.get_block_header(),\\n            self.context.this_address(),\\n            self.storage_slot,\\n        )\\n    }\\n}\\n"},"172":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\\nuse crate::state_vars::storage::Storage;\\nuse dep::protocol_types::traits::Packable;\\n\\n// docs:start:public_mutable_struct\\npub struct PublicMutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_mutable_struct\\n\\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<T, Context> PublicMutable<T, Context> {\\n    // docs:start:public_mutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicMutable { context, storage_slot }\\n    }\\n    // docs:end:public_mutable_struct_new\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    // docs:start:public_mutable_struct_read\\n    pub fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_mutable_struct_read\\n\\n    // docs:start:public_mutable_struct_write\\n    pub fn write(self, value: T) {\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_mutable_struct_write\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n"},"186":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\\n/// large enough to fit all of the elements of both the first and second vectors.\\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\\n    a: BoundedVec<T, A_LEN>,\\n    b: BoundedVec<T, B_LEN>,\\n) -> BoundedVec<T, DST_LEN> {\\n    let mut dst = BoundedVec::new();\\n\\n    dst.extend_from_bounded_vec(a);\\n    dst.extend_from_bounded_vec(b);\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::append;\\n\\n    #[test]\\n    unconstrained fn append_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::new();\\n        let b: BoundedVec<_, 14> = BoundedVec::new();\\n\\n        let result: BoundedVec<Field, 5> = append(a, b);\\n\\n        assert_eq(result.len(), 0);\\n        assert_eq(result.storage(), std::mem::zeroed());\\n    }\\n\\n    #[test]\\n    unconstrained fn append_non_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let result: BoundedVec<Field, 8> = append(a, b);\\n\\n        assert_eq(result.len(), 6);\\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\\n    }\\n\\n    #[test(should_fail_with = \\"out of bounds\\")]\\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let _: BoundedVec<Field, 5> = append(a, b);\\n    }\\n}\\n"},"188":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr","source":"pub mod append;\\npub mod collapse;\\npub mod subarray;\\npub mod subbvec;\\n\\npub use append::append;\\npub use collapse::collapse;\\npub use subarray::subarray;\\npub use subbvec::subbvec;\\n\\n// This will eventually be replaced by `BoundedVec::for_each`, once that\'s implemented.\\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\\n    vec: BoundedVec<T, MaxLen>,\\n    f: fn[Env](T, u32) -> (),\\n) {\\n    for i in 0..vec.len() {\\n        f(vec.get_unchecked(i), i);\\n    }\\n}\\n"},"189":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"190":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\\n\\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\\n/// zeroed elements past `len()`).\\n///\\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n///\\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can\'t return just 1 element since 3 remain\\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can\'t return 10 elements since only 7 remain\\n/// ```\\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\\n    offset: u32,\\n) -> BoundedVec<T, DST_MAX_LEN> {\\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\\n    // because we\'re constructing the new storage array as a subarray of the original one (which should have zeroed\\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\\n    // their original length.\\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\\n}\\n\\nmod test {\\n    use super::subbvec;\\n\\n    #[test]\\n    unconstrained fn subbvec_empty() {\\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_complete() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n\\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_partial() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_into_empty() {\\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_offset_past_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_insufficient_dst_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // We\'re not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\\n        // for the capacity to reduce, but not the length (other than by len - offset).\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // subbvec does not supprt capacity increases\\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // This effectively requests a capacity increase, since there\'d be just one element plus the 5 empty slots,\\n        // which is less than 7.\\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\\n    }\\n}\\n"},"201":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr","source":"use crate::{\\n    context::{PublicContext, UnconstrainedContext},\\n    history::public_storage::PublicStorageHistoricalRead,\\n    oracle,\\n};\\nuse dep::protocol_types::{\\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\\n};\\n\\n/// A struct that allows for efficient reading of value `T` from public storage in private.\\n///\\n/// The efficient reads are achieved by verifying large values through a single hash check\\n/// and then proving inclusion only of the hash in public storage. This reduces the number\\n/// of required tree inclusion proofs from `N` to 1.\\n///\\n/// # Type Parameters\\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\\n/// - `N`: The number of field elements required to pack values of type `T`\\npub struct WithHash<T, let N: u32> {\\n    value: T,\\n    packed: [Field; N],\\n    hash: Field,\\n}\\n\\nimpl<T, let N: u32> WithHash<T, N>\\nwhere\\n    T: Packable<N> + Eq,\\n{\\n    pub fn new(value: T) -> Self {\\n        let packed = value.pack();\\n        Self { value, packed, hash: poseidon2_hash(packed) }\\n    }\\n\\n    pub fn get_value(self) -> T {\\n        self.value\\n    }\\n\\n    pub fn get_hash(self) -> Field {\\n        self.hash\\n    }\\n\\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\\n        context.storage_read(storage_slot)\\n    }\\n\\n    pub unconstrained fn unconstrained_public_storage_read(\\n        context: UnconstrainedContext,\\n        storage_slot: Field,\\n    ) -> T {\\n        context.storage_read(storage_slot)\\n    }\\n\\n    pub fn historical_public_storage_read(\\n        header: BlockHeader,\\n        address: AztecAddress,\\n        storage_slot: Field,\\n    ) -> T {\\n        let historical_block_number = header.global_variables.block_number as u32;\\n\\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\\n        let hint = WithHash::new(\\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\\n            unsafe {\\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\\n            },\\n        );\\n\\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\\n\\n        if hash != 0 {\\n            assert_eq(hash, hint.get_hash(), \\"Hint values do not match hash\\");\\n        } else {\\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\\n            // (i.e. the default value for public storage) as well.\\n            assert_eq(\\n                hint.get_value(),\\n                T::unpack(std::mem::zeroed()),\\n                \\"Non-zero hint for zero hash\\",\\n            );\\n        };\\n\\n        hint.get_value()\\n    }\\n}\\n\\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn pack(self) -> [Field; N + 1] {\\n        let mut result: [Field; N + 1] = std::mem::zeroed();\\n        for i in 0..N {\\n            result[i] = self.packed[i];\\n        }\\n        result[N] = self.hash;\\n\\n        result\\n    }\\n\\n    fn unpack(packed: [Field; N + 1]) -> Self {\\n        let mut value_packed: [Field; N] = std::mem::zeroed();\\n        for i in 0..N {\\n            value_packed[i] = packed[i];\\n        }\\n        let hash = packed[N];\\n\\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\\n    }\\n}\\n\\nmod test {\\n    use crate::{\\n        oracle::random::random,\\n        test::{\\n            helpers::{cheatcodes, test_environment::TestEnvironment},\\n            mocks::mock_struct::MockStruct,\\n        },\\n        utils::with_hash::WithHash,\\n    };\\n    use dep::protocol_types::hash::poseidon2_hash;\\n    use dep::protocol_types::traits::{Packable, ToField};\\n    use dep::std::{mem, test::OracleMock};\\n\\n    global storage_slot: Field = 47;\\n\\n    #[test]\\n    unconstrained fn create_and_recover() {\\n        let value = MockStruct { a: 5, b: 3 };\\n        let value_with_hash = WithHash::new(value);\\n        let recovered = WithHash::unpack(value_with_hash.pack());\\n\\n        assert_eq(recovered.value, value);\\n        assert_eq(recovered.packed, value.pack());\\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\\n    }\\n\\n    #[test]\\n    unconstrained fn read_uninitialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        let block_header = env.private().historical_header;\\n        let address = env.contract_address();\\n\\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            block_header,\\n            address,\\n            storage_slot,\\n        );\\n\\n        // We should get zeroed value\\n        let expected: MockStruct = mem::zeroed();\\n        assert_eq(result, expected);\\n    }\\n\\n    #[test]\\n    unconstrained fn read_initialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        let value = MockStruct { a: 5, b: 3 };\\n        let value_with_hash = WithHash::new(value);\\n\\n        // We write the value with hash to storage\\n        cheatcodes::direct_storage_write(\\n            env.contract_address(),\\n            storage_slot,\\n            value_with_hash.pack(),\\n        );\\n\\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\\n        env.advance_block_by(1);\\n\\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            env.private().historical_header,\\n            env.contract_address(),\\n            storage_slot,\\n        );\\n\\n        assert_eq(result, value);\\n    }\\n\\n    #[test(should_fail_with = \\"Non-zero hint for zero hash\\")]\\n    unconstrained fn test_bad_hint_uninitialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        env.advance_block_to(6);\\n\\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\\n\\n        let block_header = env.private().historical_header;\\n        let address = env.contract_address();\\n\\n        // Mock the oracle to return a non-zero hint/packed value\\n        let _ = OracleMock::mock(\\"storageRead\\")\\n            .with_params((\\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\\n                value_packed.len(),\\n            ))\\n            .returns(value_packed)\\n            .times(1);\\n\\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            block_header,\\n            address,\\n            storage_slot,\\n        );\\n    }\\n\\n    #[test(should_fail_with = \\"Hint values do not match hash\\")]\\n    unconstrained fn test_bad_hint_initialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\\n\\n        // We write the value to storage\\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\\n\\n        // Now we write incorrect hash to the hash storage slot\\n        let incorrect_hash = random();\\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\\n        cheatcodes::direct_storage_write(\\n            env.contract_address(),\\n            hash_storage_slot,\\n            [incorrect_hash],\\n        );\\n\\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\\n        env.advance_block_by(1);\\n\\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            env.private().historical_header,\\n            env.contract_address(),\\n            storage_slot,\\n        );\\n    }\\n}\\n"},"262":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\\n        MAX_PROTOCOL_CONTRACTS,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_class_id(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_protocol_contract(self) -> bool {\\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"263":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\\n    constants::ETH_ADDRESS_LENGTH,\\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\\n};\\n\\npub struct EthAddress {\\n    inner: Field,\\n}\\n\\nimpl Eq for EthAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for EthAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for EthAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        EthAddress::from_field(fields[0])\\n    }\\n}\\n\\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl EthAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn from_field(field: Field) -> Self {\\n        field.assert_max_bit_size::<160>();\\n        Self { inner: field }\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"277":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{\\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\\n    traits::{Empty, Hash},\\n};\\n\\npub struct PublicDataTreeLeafPreimage {\\n    pub slot: Field,\\n    pub value: Field,\\n    pub next_slot: Field,\\n    pub next_index: u32,\\n}\\n\\nimpl Empty for PublicDataTreeLeafPreimage {\\n    fn empty() -> Self {\\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\\n    }\\n}\\n\\nimpl Eq for PublicDataTreeLeafPreimage {\\n    fn eq(self, other: Self) -> bool {\\n        (self.slot == other.slot)\\n            & (self.value == other.value)\\n            & (self.next_slot == other.next_slot)\\n            & (self.next_index == other.next_index)\\n    }\\n}\\n\\nimpl Hash for PublicDataTreeLeafPreimage {\\n    fn hash(self) -> Field {\\n        if self.is_empty() {\\n            0\\n        } else {\\n            crate::hash::poseidon2_hash([\\n                self.slot,\\n                self.value,\\n                (self.next_index as Field),\\n                self.next_slot,\\n            ])\\n        }\\n    }\\n}\\n\\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\\n    fn get_key(self) -> Field {\\n        self.slot\\n    }\\n\\n    fn as_leaf(self) -> Field {\\n        self.hash()\\n    }\\n}\\n\\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\\n    fn get_next_key(self) -> Field {\\n        self.next_slot\\n    }\\n\\n    fn points_to_infinity(self) -> bool {\\n        (self.next_slot == 0) & (self.next_index == 0)\\n    }\\n\\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\\n    }\\n\\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\\n        Self {\\n            slot: self.slot,\\n            value: write.value,\\n            next_slot: self.next_slot,\\n            next_index: self.next_index,\\n        }\\n    }\\n\\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\\n        Self {\\n            slot: write.slot,\\n            value: write.value,\\n            next_slot: low_leaf.next_slot,\\n            next_index: low_leaf.next_index,\\n        }\\n    }\\n}\\n\\nimpl PublicDataTreeLeafPreimage {\\n    pub fn is_empty(self) -> bool {\\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\\n    }\\n}\\n"},"279":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"280":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        contract_class_log::ContractClassLog,\\n        function_selector::FunctionSelector,\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, ToField},\\n    utils::{\\n        arrays::{array_concat, unsafe_padded_array_length},\\n        field::{field_from_bytes, field_from_bytes_32_trunc},\\n    },\\n};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_field(\\n    contract_address: AztecAddress,\\n    first_field: Field,\\n) -> Field {\\n    poseidon2_hash([contract_address.to_field(), first_field])\\n}\\n\\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\\n    if contract_class_log.contract_address.is_zero() {\\n        contract_class_log\\n    } else {\\n        let mut log = contract_class_log;\\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\\n            contract_class_log.contract_address,\\n            log.log.fields[0],\\n        );\\n        log\\n    }\\n}\\n\\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\\n    let array = contract_class_log.log.fields;\\n    // Safety: The below length is constrained in the base rollup.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    if length == 0 {\\n        0\\n    } else {\\n        poseidon2_hash(array)\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a u128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"290":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\\n\\n// Calculate the Merkle tree root from the sibling path and leaf.\\n//\\n// The leaf is hashed with its sibling, and then the result is hashed\\n// with the next sibling etc in the path. The last hash is the root.\\n//\\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\\n// TODO a bit simpler in Noir to just have a bit array.\\n// TODO: I\'d generally like to avoid u256 for algorithms like\\n// this because it means we never even need to consider cases where\\n// the index is greater than p.\\npub fn root_from_sibling_path<let N: u32>(\\n    leaf: Field,\\n    leaf_index: Field,\\n    sibling_path: [Field; N],\\n) -> Field {\\n    let mut node = leaf;\\n    let indices: [u1; N] = leaf_index.to_le_bits();\\n\\n    for i in 0..N {\\n        let (hash_left, hash_right) = if indices[i] == 1 {\\n            (sibling_path[i], node)\\n        } else {\\n            (node, sibling_path[i])\\n        };\\n        node = merkle_hash(hash_left, hash_right);\\n    }\\n    node\\n}\\n\\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\\n    MerkleTree::new(leaves).get_root()\\n}\\n\\n// These values are precomputed and we run tests to ensure that they\\n// are correct. The values themselves were computed from the cpp code.\\n//\\n// Would be good if we could use width since the compute_subtree\\n// algorithm uses depth.\\npub fn calculate_empty_tree_root(depth: u32) -> Field {\\n    if depth == 0 {\\n        0\\n    } else if depth == 1 {\\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\\n    } else if depth == 2 {\\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\\n    } else if depth == 3 {\\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\\n    } else if depth == 4 {\\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\\n    } else if depth == 5 {\\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\\n    } else if depth == 6 {\\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\\n    } else if depth == 7 {\\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\\n    } else if depth == 8 {\\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\\n    } else if depth == 9 {\\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\\n    } else if depth == 10 {\\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\\n    } else {\\n        panic(f\\"depth should be between 0 and 10\\")\\n    }\\n}\\n\\n#[test]\\nfn test_merkle_root_interop_test() {\\n    // This is a test to ensure that we match the cpp implementation.\\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\\n    // to find the test that matches this.\\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\\n\\n    let empty_root = calculate_subtree_root([0; 16]);\\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\\n}\\n\\n#[test]\\nfn test_empty_subroot() {\\n    assert(calculate_empty_tree_root(0) == 0);\\n\\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\\n\\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\\n\\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\\n\\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\\n\\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\\n\\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\\n\\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\\n\\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\\n\\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\\n\\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\\n}\\n"},"294":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use super::traits::{Deserialize, Packable, Serialize};\\n\\n/// Returns the typed expression of a trait method implementation.\\n///\\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\\n/// warnings that the trait implementation is not in scope).\\n///\\n/// # Note\\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\\ncomptime fn get_trait_impl_method(\\n    typ: Type,\\n    target_trait: Quoted,\\n    target_method: Quoted,\\n) -> TypedExpr {\\n    let trait_constraint = target_trait.as_trait_constraint();\\n    typ\\n        .get_trait_impl(trait_constraint)\\n        .expect(f\\"Could not find impl for {target_trait} for type {typ}\\")\\n        .methods()\\n        .filter(|m| m.name() == target_method)[0]\\n        .as_typed_expr()\\n}\\n\\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\\n///\\n/// # Parameters\\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\\"values\\"`).\\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\\n/// and `Serialize` trait for more information about the difference between packing and serialization).\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\\n///\\n/// # Nested Struct Example\\n/// Given the following setup:\\n/// ```\\n/// struct UintNote {\\n///     value: u128,\\n///     owner: AztecAddress,\\n///     randomness: Field,\\n/// }\\n///\\n/// struct AztecAddress {\\n///     inner: Field,\\n/// }\\n/// ```\\n///\\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\\n/// ```\\n/// UintNote {\\n///     value: fields[0] as u128,\\n///     owner: AztecAddress {\\n///         inner: fields[1],\\n///     },\\n///     randomness: fields[2],\\n/// }\\n/// ```\\n/// # Nested Struct Example with Unpacking\\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\\n///   the result we get is:\\n/// ```\\n/// UintNote {\\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\\n/// }\\n/// ```\\n///\\n/// # Panics\\n/// - If the deserialization logic encounters a type it does not support.\\n/// - If an incorrect number of fields are consumed when deserializing a string.\\npub comptime fn generate_deserialize_from_fields(\\n    name: Quoted,\\n    typ: Type,\\n    field_array_name: Quoted,\\n    num_already_consumed: u32,\\n    should_unpack: bool,\\n) -> (Quoted, u32) {\\n    let mut result = quote {};\\n    // Counter for the number of fields consumed\\n    let mut consumed_counter: u32 = 0;\\n\\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n    if (should_unpack & typ.implements(packable_constraint)) {\\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\\n        let mut packed_fields_quotes = &[];\\n        for i in 0..packed_len {\\n            let index_in_field_array = i + num_already_consumed;\\n            packed_fields_quotes =\\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\\n        }\\n        let packed_fields = packed_fields_quotes.join(quote {,});\\n\\n        // Now we call unpack on the type\\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\\n        result = quote { $unpack_method([ $packed_fields ]) };\\n\\n        consumed_counter = packed_len;\\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\\n        // The field is a primitive so we just reference it in the field array\\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\\n        consumed_counter = 1;\\n    } else if typ.as_data_type().is_some() {\\n        // The field is a struct so we iterate over each struct field and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (nested_def, generics) = typ.as_data_type().unwrap();\\n        let nested_name = nested_def.name();\\n        let mut deserialized_fields_list = &[];\\n\\n        // Iterate over each field in the struct\\n        for field in nested_def.fields(generics) {\\n            let (field_name, field_type) = field;\\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                field_name,\\n                field_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\\n            deserialized_fields_list =\\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\\n        }\\n\\n        // We can construct the struct from the deserialized fields\\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\\n        result = quote {\\n                $nested_name {\\n                    $deserialized_fields\\n                }\\n            };\\n    } else if typ.as_array().is_some() {\\n        // The field is an array so we iterate over each element and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (element_type, array_len) = typ.as_array().unwrap();\\n        let array_len = array_len.as_constant().unwrap();\\n        let mut array_fields_list = &[];\\n\\n        // Iterate over each element in the array\\n        for _ in 0..array_len {\\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                element_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            array_fields_list = array_fields_list.push_back(deserialized_field);\\n        }\\n\\n        // We can construct the array from the deserialized fields\\n        let array_fields = array_fields_list.join(quote {,});\\n        result = quote { [ $array_fields ] };\\n    } else if typ.as_str().is_some() {\\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\\n        // to `generate_deserialize_from_fields`.\\n        let length_type = typ.as_str().unwrap();\\n        let str_len = length_type.as_constant().unwrap();\\n        let mut byte_list = &[];\\n\\n        // Iterate over each character in the string\\n        for _ in 0..str_len {\\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                quote {u8}.as_type(),\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n\\n            // We should consume just one field in the recursion so we sanity check that\\n            assert_eq(\\n                num_consumed_in_recursion,\\n                1,\\n                \\"Incorrect number of fields consumed in string deserialization\\",\\n            );\\n\\n            // We increment the consumed counter by 1 as we have consumed one field\\n            consumed_counter += 1;\\n\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `fields[6] as u8`\\n            byte_list = byte_list.push_back(deserialized_field);\\n        }\\n\\n        // We construct the string from the deserialized fields\\n        let bytes = byte_list.join(quote {,});\\n        result = quote { [ $bytes ].as_str_unchecked() };\\n    } else {\\n        panic(\\n            f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n        )\\n    }\\n\\n    (result, consumed_counter)\\n}\\n\\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\\n/// if it does.\\n///\\n/// # Parameters\\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\\n/// - `should_pack`: A boolean indicating whether the type should be packed.\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - A flattened array of `Quoted` field references representing the serialized fields.\\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\\n///\\n/// # Examples\\n///\\n/// ## Struct\\n/// Given the following struct:\\n/// ```rust\\n/// struct MockStruct {\\n///     a: Field,\\n///     b: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing the struct:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\\n/// // Returns:\\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\\n/// ```\\n///\\n/// ## Nested Struct\\n/// For a more complex struct:\\n/// ```rust\\n/// struct NestedStruct {\\n///     m1: MockStruct,\\n///     m2: MockStruct,\\n/// }\\n/// ```\\n///\\n/// Serialization output:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\\n/// // Returns:\\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\\n/// ```\\n///\\n/// ## Array\\n/// For an array type:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\\n/// // Returns:\\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\\n/// ```\\n///\\n/// ## String\\n/// For a string field, where each character is serialized as a `Field`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\\n/// // Returns:\\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\\n/// ```\\n///\\n/// ## Nested Struct with Omitted Field and packing enabled\\n/// - u128 has a `Packable` implementation hence it will be packed.\\n///\\n/// For a more complex struct:\\n/// ```rust\\n/// struct MyStruct {\\n///     value: u128,\\n///     value2: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing while omitting `value2`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\\n/// // Returns:\\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\\n/// ```\\n///\\n/// # Panics\\n/// - If the type is unsupported for serialization.\\n/// - If the provided `typ` contains invalid constants or incompatible structures.\\npub comptime fn generate_serialize_to_fields(\\n    name: Quoted,\\n    typ: Type,\\n    omit: [Quoted],\\n    should_pack: bool,\\n) -> ([Quoted], [Quoted]) {\\n    let mut fields = &[];\\n    let mut aux_vars = &[];\\n\\n    // Proceed if none of the omit rules omits this name\\n    if !omit.any(|to_omit| to_omit == name) {\\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n        let packable_constraint =\\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n        if (should_pack & typ.implements(packable_constraint)) {\\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \\"self.value\\" -> \\"self_value\\").\\n            let name_at_one_token = collapse_to_one_token(name);\\n            let packed_struct_name = f\\"{name_at_one_token}_aux_var\\".quoted_contents();\\n\\n            // We add the individual fields to the fields array\\n            let pack_method = get_trait_impl_method(\\n                typ,\\n                quote { crate::traits::Packable<$packed_len> },\\n                quote { pack },\\n            );\\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\\n            for i in 0..packed_len {\\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\\n            }\\n\\n            // We add the new auxiliary variable to the aux_vars array\\n            aux_vars = aux_vars.push_back(packed_struct);\\n        } else if typ.is_field() {\\n            // For field we just add the value to fields\\n            fields = fields.push_back(name);\\n        } else if typ.as_integer().is_some() | typ.is_bool() {\\n            // For integer and bool we just cast to Field and add the value to fields\\n            fields = fields.push_back(quote { $name as Field });\\n        } else if typ.as_data_type().is_some() {\\n            // For struct we pref\\n            let nested_struct = typ.as_data_type().unwrap();\\n            let params = nested_struct.0.fields(nested_struct.1);\\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\\n                let maybe_prefixed_name = if name == quote {} {\\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\\n                    // argument) --> then we don\'t prefix the name with anything.\\n                    param_name\\n                } else {\\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\\n                    // can typically be `self` when implementing a method on a struct.\\n                    quote { $name.$param_name }\\n                };\\n                generate_serialize_to_fields(\\n                    quote {$maybe_prefixed_name},\\n                    param_type,\\n                    omit,\\n                    should_pack,\\n                )\\n            });\\n            let struct_flattened_fields = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\\n            );\\n            let struct_flattened_aux_vars = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\\n            );\\n            fields = fields.append(struct_flattened_fields);\\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\\n        } else if typ.as_array().is_some() {\\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\\n            let (element_type, array_len) = typ.as_array().unwrap();\\n            let array_len = array_len.as_constant().unwrap();\\n            for i in 0..array_len {\\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\\n                    quote { $name[$i] },\\n                    element_type,\\n                    omit,\\n                    should_pack,\\n                );\\n                fields = fields.append(element_fields);\\n                aux_vars = aux_vars.append(element_aux_vars);\\n            }\\n        } else if typ.as_str().is_some() {\\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\\n            // then we add each byte to fields as a Field\\n            let length_type = typ.as_str().unwrap();\\n            let str_len = length_type.as_constant().unwrap();\\n            let as_member = name.as_expr().unwrap().as_member_access();\\n            let var_name = if as_member.is_some() {\\n                as_member.unwrap().1\\n            } else {\\n                name\\n            };\\n            let as_bytes_name = f\\"{var_name}_as_bytes\\".quoted_contents();\\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\\n            for i in 0..str_len {\\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\\n            }\\n            aux_vars = aux_vars.push_back(as_bytes);\\n        } else {\\n            panic(\\n                f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n            )\\n        }\\n    }\\n    (fields, aux_vars)\\n}\\n\\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\\n/// E.g. \\"self.values[0]\\" -> \\"self_values_0_\\"\\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\\n    let tokens = q.tokens();\\n\\n    let mut single_token = quote {};\\n    for token in tokens {\\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\\n            quote {_}\\n        } else {\\n            token\\n        };\\n        single_token = f\\"{single_token}{new_token}\\".quoted_contents();\\n    }\\n    single_token\\n}\\n\\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let field_serializations = fields.join(quote {,});\\n    let serialized_len = fields.len();\\n    quote {\\n        impl Serialize<$serialized_len> for $typ {\\n            fn serialize(self) -> [Field; $serialized_len] {\\n                $aux_vars_for_serialization\\n                [ $field_serializations ]\\n            }\\n        }\\n    }\\n}\\n\\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let serialized_len = fields.len();\\n    let (deserialized, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\\n    quote {\\n        impl Deserialize<$serialized_len> for $typ {\\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\\n                $deserialized\\n            }\\n        }\\n    }\\n}\\n\\n/// Generates `Packable` implementation for a given struct and returns the packed length.\\n///\\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\\n    let packing_enabled = true;\\n\\n    let typ = s.as_type();\\n    let (fields, aux_vars) =\\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let (unpacked, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\\n\\n    let field_packings = fields.join(quote {,});\\n    let packed_len = fields.len();\\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\\n    (\\n        quote {\\n        impl $packable_trait for $typ {\\n            fn pack(self) -> [Field; $packed_len] {\\n                $aux_vars_for_packing\\n                [ $field_packings ]\\n            }\\n\\n            fn unpack(packed: [Field; $packed_len]) -> Self {\\n                $unpacked\\n            }\\n        }\\n    },\\n        packed_len,\\n    )\\n}\\n\\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\\n    packable_impl\\n}\\n\\n#[derive(Packable, Serialize, Deserialize, Eq)]\\npub struct Smol {\\n    a: Field,\\n    b: Field,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct HasArray {\\n    a: [Field; 2],\\n    b: bool,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct Fancier {\\n    a: Smol,\\n    b: [Field; 2],\\n    c: [u8; 3],\\n    d: str<16>,\\n}\\n\\nfn main() {\\n    assert(false);\\n}\\n\\n#[test]\\nfn smol_test() {\\n    let smol = Smol { a: 1, b: 2 };\\n    let serialized = smol.serialize();\\n    assert(serialized == [1, 2], serialized);\\n    let deserialized = Smol::deserialize(serialized);\\n    assert(deserialized == smol);\\n\\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\\n    let packed = smol.pack();\\n    assert_eq(packed, serialized, \\"Packed does not match serialized\\");\\n}\\n\\n#[test]\\nfn has_array_test() {\\n    let has_array = HasArray { a: [1, 2], b: true };\\n    let serialized = has_array.serialize();\\n    assert(serialized == [1, 2, 1], serialized);\\n    let deserialized = HasArray::deserialize(serialized);\\n    assert(deserialized == has_array);\\n}\\n\\n#[test]\\nfn fancier_test() {\\n    let fancier =\\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \\"metaprogramming!\\" };\\n    let serialized = fancier.serialize();\\n    assert(\\n        serialized\\n            == [\\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\\n            ],\\n        serialized,\\n    );\\n    let deserialized = Fancier::deserialize(serialized);\\n    assert(deserialized == fancier);\\n}\\n"},"297":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"317":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\\nwhere\\n    K: ToField,\\n{\\n    poseidon2_hash([storage_slot, key.to_field()])\\n}\\n\\nmod test {\\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\\n\\n    #[test]\\n    fn test_derive_storage_slot_in_map_matches_typescript() {\\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\\n        let key = AztecAddress::from_field(\\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\\n        );\\n\\n        let slot = derive_storage_slot_in_map(map_slot, key);\\n\\n        // The following value was generated by `map_slot.test.ts`\\n        let slot_from_typescript =\\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\\n\\n        assert_eq(slot, slot_from_typescript);\\n    }\\n}\\n"},"335":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\\n\\nglobal BOOL_PACKED_LEN: u32 = 1;\\nglobal U8_PACKED_LEN: u32 = 1;\\nglobal U16_PACKED_LEN: u32 = 1;\\nglobal U32_PACKED_LEN: u32 = 1;\\nglobal U64_PACKED_LEN: u32 = 1;\\nglobal U128_PACKED_LEN: u32 = 1;\\nglobal FIELD_PACKED_LEN: u32 = 1;\\nglobal I8_PACKED_LEN: u32 = 1;\\nglobal I16_PACKED_LEN: u32 = 1;\\nglobal I32_PACKED_LEN: u32 = 1;\\nglobal I64_PACKED_LEN: u32 = 1;\\n\\nimpl Packable<BOOL_PACKED_LEN> for bool {\\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Packable<U8_PACKED_LEN> for u8 {\\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Packable<U16_PACKED_LEN> for u16 {\\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Packable<U32_PACKED_LEN> for u32 {\\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Packable<U64_PACKED_LEN> for u64 {\\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Packable<U128_PACKED_LEN> for u128 {\\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Packable<FIELD_PACKED_LEN> for Field {\\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\\n        [self]\\n    }\\n\\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Packable<I8_PACKED_LEN> for i8 {\\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Packable<I16_PACKED_LEN> for i16 {\\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Packable<I32_PACKED_LEN> for i32 {\\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Packable<I64_PACKED_LEN> for i64 {\\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\\nwhere\\n    T: Packable<M>,\\n{\\n    fn pack(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].pack();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n\\n    fn unpack(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_packing() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i8_packing() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i16_packing() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i32_packing() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i64_packing() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::unpack(a.pack()));\\n}\\n"},"336":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 1;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"352":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\\n// is not found, the function returns N as the index.\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays where validate_array(array) returns true,\\n// which ensures that:\\n// 1. All elements before the first empty element are non-empty\\n// 2. All elements after and including the first empty element are empty\\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // We get the length by checking the index of the first empty element.\\n\\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\\n    // of the element and non-emptiness of the previous element is checked below.\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\\n/// if this is not the case then elements from the end of `array2` will be dropped.\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: we constrain this array below\\n    let result = unsafe { array_merge_helper(array1, array2) };\\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\\n    let array1_len = array_length(array1);\\n    let mut add_from_left = true;\\n    for i in 0..N {\\n        add_from_left &= i != array1_len;\\n        if add_from_left {\\n            assert_eq(result[i], array1[i]);\\n        } else {\\n            assert_eq(result[i], array2[i - array1_len]);\\n        }\\n    }\\n    result\\n}\\n\\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n// Helper function to find the index of the last element in an array, allowing empty elements.\\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut index = N;\\n    for i in 0..N {\\n        let j = N - i - 1;\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & !is_empty(array[j]) {\\n            index = j;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which returns the length of an array right padded by empty elements\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\n// See smoke_validate_array_trailing for examples.\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let index = find_last_value_index(array);\\n    if index == N {\\n        0\\n    } else {\\n        index + 1\\n    }\\n}\\n\\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: this value is constrained in the below loop.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    // Check the elt just before length is non-zero:\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]), \\"invalid right padded array\\");\\n    }\\n    // Check all beyond length are zero:\\n    let mut check_zero = false;\\n    for i in 0..N {\\n        check_zero |= i == length;\\n        if check_zero {\\n            assert(is_empty(array[i]), \\"invalid right padded array\\");\\n        }\\n    }\\n    length\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test]\\nfn smoke_validate_array_trailing() {\\n    let valid_array: [Field; 0] = [];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(padded_array_length(valid_array) == 1);\\n\\n    let valid_array = [1, 0, 3];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 0, 3, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [0, 0, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nunconstrained fn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nunconstrained fn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concatenated = array_concat(array0, array1);\\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"353":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\\n    assert(bytes.len() < 32, \\"field_from_bytes: N must be less than 32\\");\\n    let mut as_field = 0;\\n    let mut offset = 1;\\n    for i in 0..N {\\n        let mut index = i;\\n        if big_endian {\\n            index = N - i - 1;\\n        }\\n        as_field += (bytes[index] as Field) * offset;\\n        offset *= 256;\\n    }\\n\\n    as_field\\n}\\n\\n// Convert a 32 byte array to a field element by truncating the final byte\\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..15 {\\n        // covers bytes 16..30 (31 is truncated and ignored)\\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\\n        v = v * 256;\\n        // covers bytes 0..14\\n        high = high + (bytes32[14 - i] as Field) * v;\\n    }\\n    // covers byte 15\\n    low = low + (bytes32[15] as Field) * v;\\n\\n    low + high * v\\n}\\n\\n// TODO to radix returns u8, so we cannot use bigger radixes. It\'d be ideal to use a radix of the maximum range-constrained integer noir supports\\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\\n    lhs.lt(rhs)\\n}\\n\\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\\n    rhs.lt(lhs)\\n}\\n\\npub fn min(f1: Field, f2: Field) -> Field {\\n    if f1.lt(f2) {\\n        f1\\n    } else {\\n        f2\\n    }\\n}\\n\\n#[test]\\nunconstrained fn bytes_field_test() {\\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\\n    let inputs = [\\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\\n    ];\\n    let field = field_from_bytes(inputs, true);\\n    let return_bytes: [u8; 31] = field.to_be_bytes();\\n    assert_eq(inputs, return_bytes);\\n    // 32 bytes - we remove the final byte, and check it matches the field\\n    let inputs2 = [\\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\\n    ];\\n    let field2 = field_from_bytes_32_trunc(inputs2);\\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\\n\\n    assert_eq(return_bytes2, return_bytes);\\n    assert_eq(field2, field);\\n}\\n\\n#[test]\\nunconstrained fn max_field_test() {\\n    // Tests the hardcoded value in constants.nr vs underlying modulus\\n    // NB: We can\'t use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\\n    let max_value = crate::constants::MAX_FIELD_VALUE;\\n    assert_eq(max_value, 0 - 1);\\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\\n    let mod_bytes = std::field::modulus_be_bytes();\\n    for i in 0..31 {\\n        assert_eq(max_bytes[i], mod_bytes[i]);\\n    }\\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\\n}\\n"},"355":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"367":{"path":"/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr","source":"use std::hash::sha256_compression;\\nuse std::runtime::is_unconstrained;\\n\\nuse constants::{\\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\\n};\\n\\nmod constants;\\nmod tests;\\n\\n// Implementation of SHA-256 mapping a byte array of variable length to\\n// 32 bytes.\\n\\n// Deprecated in favour of `sha256_var`\\n// docs:start:sha256\\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\\n// docs:end:sha256\\n{\\n    digest(input)\\n}\\n\\n// SHA-256 hash function\\n#[no_predicates]\\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\\n    sha256_var(msg, N as u64)\\n}\\n\\n// Variable size SHA-256 hash\\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\\n    let message_size = message_size as u32;\\n    assert(message_size <= N);\\n\\n    if std::runtime::is_unconstrained() {\\n        // Safety: SHA256 is running as an unconstrained function.\\n        unsafe {\\n            __sha256_var(msg, message_size)\\n        }\\n    } else {\\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\\n        // Intermediate hash, starting with the canonical initial value\\n        let mut h: STATE = INITIAL_STATE;\\n        // Pointer into msg_block on a 64 byte scale\\n        let mut msg_byte_ptr = 0;\\n        let num_blocks = N / BLOCK_SIZE;\\n        for i in 0..num_blocks {\\n            let msg_start = BLOCK_SIZE * i;\\n            let (new_msg_block, new_msg_byte_ptr) =\\n                unsafe { build_msg_block(msg, message_size, msg_start) };\\n\\n            if msg_start < message_size {\\n                msg_block = new_msg_block;\\n            }\\n\\n            // Verify the block we are compressing was appropriately constructed\\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\\n            if msg_start < message_size {\\n                msg_byte_ptr = new_msg_byte_ptr;\\n            }\\n\\n            // If the block is filled, compress it.\\n            // An un-filled block is handled after this loop.\\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\\n                h = sha256_compression(msg_block, h);\\n            }\\n        }\\n\\n        let modulo = N % BLOCK_SIZE;\\n        // Handle setup of the final msg block.\\n        // This case is only hit if the msg is less than the block size,\\n        // or our message cannot be evenly split into blocks.\\n        if modulo != 0 {\\n            let msg_start = BLOCK_SIZE * num_blocks;\\n            let (new_msg_block, new_msg_byte_ptr) =\\n                unsafe { build_msg_block(msg, message_size, msg_start) };\\n\\n            if msg_start < message_size {\\n                msg_block = new_msg_block;\\n            }\\n\\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\\n            if msg_start < message_size {\\n                msg_byte_ptr = new_msg_byte_ptr;\\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\\n            }\\n        }\\n\\n        // If we had modulo == 0 then it means the last block was full,\\n        // and we can reset the pointer to zero to overwrite it.\\n        if msg_byte_ptr == BLOCK_SIZE {\\n            msg_byte_ptr = 0;\\n        }\\n\\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\\n        // Here we rely on the fact that everything beyond the available input is set to 0.\\n        let index = msg_byte_ptr / INT_SIZE;\\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\\n\\n        msg_byte_ptr = msg_byte_ptr + 1;\\n        let last_block = msg_block;\\n\\n        // If we don\'t have room to write the size, compress the block and reset it.\\n        if msg_byte_ptr > MSG_SIZE_PTR {\\n            h = sha256_compression(msg_block, h);\\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\\n            msg_byte_ptr = 0;\\n        }\\n\\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\\n\\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\\n\\n        hash_final_block(msg_block, h)\\n    }\\n}\\n\\n// Variable size SHA-256 hash\\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\\n    let num_full_blocks = message_size / BLOCK_SIZE;\\n    // Intermediate hash, starting with the canonical initial value\\n    let mut h: STATE = INITIAL_STATE;\\n    // Pointer into msg_block on a 64 byte scale\\n    for i in 0..num_full_blocks {\\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\\n        h = sha256_compression(msg_block, h);\\n    }\\n\\n    // Handle setup of the final msg block.\\n    // This case is only hit if the msg is less than the block size,\\n    // or our message cannot be evenly split into blocks.\\n    let modulo = message_size % BLOCK_SIZE;\\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\\n        let msg_start = BLOCK_SIZE * num_full_blocks;\\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\\n\\n        (new_msg_block, new_msg_byte_ptr)\\n    } else {\\n        // If we had modulo == 0 then it means the last block was full,\\n        // and we can reset the pointer to zero to overwrite it.\\n        ([0; INT_BLOCK_SIZE], 0)\\n    };\\n\\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\\n    // Here we rely on the fact that everything beyond the available input is set to 0.\\n    let index = msg_byte_ptr / INT_SIZE;\\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\\n\\n    // If we don\'t have room to write the size, compress the block and reset it.\\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\\n        (sha256_compression(msg_block, h), 0)\\n    } else {\\n        (h, msg_byte_ptr + 1)\\n    };\\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\\n\\n    hash_final_block(msg_block, h)\\n}\\n\\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\\n// Returns the block and the length that has been copied rather than padded with zeros.\\nunconstrained fn build_msg_block<let N: u32>(\\n    msg: [u8; N],\\n    message_size: u32,\\n    msg_start: u32,\\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\\n\\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\\n    let block_input = if message_size < msg_start {\\n        // This function is sometimes called with `msg_start` past the end of the message.\\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\\n        0\\n    } else if message_size < msg_start + BLOCK_SIZE {\\n        message_size - msg_start\\n    } else {\\n        BLOCK_SIZE\\n    };\\n\\n    // Figure out the number of items in the int array that we have to pack.\\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\\n    let mut int_input = block_input / INT_SIZE;\\n    if block_input % INT_SIZE != 0 {\\n        int_input = int_input + 1;\\n    };\\n\\n    for i in 0..int_input {\\n        let mut msg_item: u32 = 0;\\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\\n        for j in 0..INT_SIZE {\\n            let k = i * INT_SIZE + j;\\n            let msg_byte = if k < block_input {\\n                msg[msg_start + k]\\n            } else {\\n                0\\n            };\\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\\n        }\\n        msg_block[i] = msg_item;\\n    }\\n\\n    // Returning the index as if it was a 64 byte array.\\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\\n    (msg_block, block_input)\\n}\\n\\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\\n// and matches the input data. Returns the index of the first unset item.\\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\\n// in that case we can skip verification, ie. no need to check that everything is zero.\\nfn verify_msg_block<let N: u32>(\\n    msg: [u8; N],\\n    message_size: u32,\\n    msg_block: MSG_BLOCK,\\n    msg_start: u32,\\n) -> BLOCK_BYTE_PTR {\\n    let mut msg_byte_ptr = 0;\\n    let mut msg_end = msg_start + BLOCK_SIZE;\\n    if msg_end > N {\\n        msg_end = N;\\n    }\\n    // We might have to go beyond the input to pad the fields.\\n    if msg_end % INT_SIZE != 0 {\\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\\n    }\\n\\n    // Reconstructed packed item.\\n    let mut msg_item: u32 = 0;\\n\\n    // Inclusive at the end so that we can compare the last item.\\n    let mut i: u32 = 0;\\n    for k in msg_start..=msg_end {\\n        if k % INT_SIZE == 0 {\\n            // If we consumed some input we can compare against the block.\\n            if (msg_start < message_size) & (k > msg_start) {\\n                assert_eq(msg_block[i], msg_item as u32);\\n                i = i + 1;\\n                msg_item = 0;\\n            }\\n        }\\n        // Shift the accumulator\\n        msg_item = lshift8(msg_item, 1);\\n        // If we have input to consume, add it at the rightmost position.\\n        if k < message_size & k < msg_end {\\n            msg_item = msg_item + msg[k] as u32;\\n            msg_byte_ptr = msg_byte_ptr + 1;\\n        }\\n    }\\n\\n    msg_byte_ptr\\n}\\n\\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\\n// This is only relevant for the last, potentially partially filled block.\\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\\n    // Check all the way to the end of the block.\\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\\n}\\n\\n// Verify that a region of ints in the message block are (partially) zeroed,\\n// up to an (exclusive) maximum which can either be the end of the block\\n// or just where the size is to be written.\\nfn verify_msg_block_zeros(\\n    msg_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n    max_int_byte_ptr: u32,\\n) {\\n    // This variable is used to get around the compiler under-constrained check giving a warning.\\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\\n    // or return values the compiler check will issue a warning.\\n    let zero = msg_block[0] - msg_block[0];\\n\\n    // First integer which is supposed to be (partially) zero.\\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\\n\\n    // Check partial zeros.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        let zeros = INT_SIZE - modulo;\\n        let mask = if zeros == 3 {\\n            TWO_POW_24\\n        } else if zeros == 2 {\\n            TWO_POW_16\\n        } else {\\n            TWO_POW_8\\n        };\\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\\n        int_byte_ptr = int_byte_ptr + 1;\\n    }\\n\\n    // Check the rest of the items.\\n    for i in 0..max_int_byte_ptr {\\n        if i >= int_byte_ptr {\\n            assert_eq(msg_block[i], zero);\\n        }\\n    }\\n}\\n\\n// Verify that up to the byte pointer the two blocks are equal.\\n// At the byte pointer the new block can be partially zeroed.\\nfn verify_msg_block_equals_last(\\n    msg_block: MSG_BLOCK,\\n    last_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n) {\\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\\n    // First integer which is supposed to be (partially) zero contains that pointer.\\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\\n\\n    // Check partial zeros.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        // Reconstruct the partially zero item from the last block.\\n        let last_field = last_block[int_byte_ptr];\\n        let mut msg_item: u32 = 0;\\n        // Reset to where they are still equal.\\n        msg_byte_ptr = msg_byte_ptr - modulo;\\n        for i in 0..INT_SIZE {\\n            msg_item = lshift8(msg_item, 1);\\n            if i < modulo {\\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\\n                msg_byte_ptr = msg_byte_ptr + 1;\\n            }\\n        }\\n        assert_eq(msg_block[int_byte_ptr], msg_item);\\n    }\\n\\n    for i in 0..INT_SIZE_PTR {\\n        if i < int_byte_ptr {\\n            assert_eq(msg_block[i], last_block[i]);\\n        }\\n    }\\n}\\n\\n// Set the rightmost `zeros` number of bytes to 0.\\n#[inline_always]\\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\\n    lshift8(rshift8(item, zeros), zeros)\\n}\\n\\n// Replace one byte in the item with a value, and set everything after it to zero.\\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\\n    zeroed_item + new_item\\n}\\n\\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\\n    // How many times do we have to shift to the right to get to the position we want?\\n    let max_shifts = INT_SIZE - 1;\\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\\n    msg_item = rshift8(msg_item, shifts as u8);\\n    // At this point the byte we want is in the rightmost position.\\n    msg_item as u8\\n}\\n\\n// Project a byte into a position in a field based on the overall block pointer.\\n// For example putting 1 into pointer 5 would be 100, because overall we would\\n// have [____, 0100] with indexes [0123,4567].\\n#[inline_always]\\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\\n    let mut msg_item = msg_byte as u32;\\n    // How many times do we have to shift to the left to get to the position we want?\\n    let max_shifts = INT_SIZE - 1;\\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\\n    lshift8(msg_item, shifts as u8)\\n}\\n\\n// Construct a field out of 4 bytes.\\n#[inline_always]\\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\\n    let mut item = b0 as u32;\\n    item = lshift8(item, 1) + b1 as u32;\\n    item = lshift8(item, 1) + b2 as u32;\\n    item = lshift8(item, 1) + b3 as u32;\\n    item\\n}\\n\\n// Shift by 8 bits to the left between 0 and 4 times.\\n// Checks `is_unconstrained()` to just use a bitshift if we\'re running in an unconstrained context,\\n// otherwise multiplies by 256.\\n#[inline_always]\\nfn lshift8(item: u32, shifts: u8) -> u32 {\\n    if is_unconstrained() {\\n        // Brillig wouldn\'t shift 0<<4 without overflow.\\n        if shifts >= 4 {\\n            0\\n        } else {\\n            item << (8 * shifts)\\n        }\\n    } else {\\n        // We can do a for loop up to INT_SIZE or an if-else.\\n        if shifts == 0 {\\n            item\\n        } else if shifts == 1 {\\n            item * TWO_POW_8\\n        } else if shifts == 2 {\\n            item * TWO_POW_16\\n        } else if shifts == 3 {\\n            item * TWO_POW_24\\n        } else {\\n            // Doesn\'t make sense, but it\'s most likely called on 0 anyway.\\n            0\\n        }\\n    }\\n}\\n\\n// Shift by 8 bits to the right between 0 and 4 times.\\n// Checks `is_unconstrained()` to just use a bitshift if we\'re running in an unconstrained context,\\n// otherwise divides by 256.\\nfn rshift8(item: u32, shifts: u8) -> u32 {\\n    if is_unconstrained() {\\n        item >> (8 * shifts)\\n    } else {\\n        // Division wouldn\'t work on `Field`.\\n        if shifts == 0 {\\n            item\\n        } else if shifts == 1 {\\n            item / TWO_POW_8\\n        } else if shifts == 2 {\\n            item / TWO_POW_16\\n        } else if shifts == 3 {\\n            item / TWO_POW_24\\n        } else {\\n            0\\n        }\\n    }\\n}\\n\\n// Zero out all bytes between the end of the message and where the length is appended,\\n// then write the length into the last 8 bytes of the block.\\nunconstrained fn attach_len_to_msg_block(\\n    mut msg_block: MSG_BLOCK,\\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\\n    message_size: u32,\\n) -> MSG_BLOCK {\\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\\n    // There can be one item which has to be partially zeroed.\\n    let modulo = msg_byte_ptr % INT_SIZE;\\n    if modulo != 0 {\\n        // Index of the block in which we find the item we need to partially zero.\\n        let i = msg_byte_ptr / INT_SIZE;\\n        let zeros = INT_SIZE - modulo;\\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\\n        msg_byte_ptr = msg_byte_ptr + zeros;\\n    }\\n\\n    // The rest can be zeroed without bit shifting anything.\\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\\n        msg_block[i] = 0;\\n    }\\n\\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\\n    let len = 8 * message_size;\\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\\n    for i in 0..=1 {\\n        let shift = i * 4;\\n        msg_block[INT_SIZE_PTR + i] = make_item(\\n            len_bytes[shift],\\n            len_bytes[shift + 1],\\n            len_bytes[shift + 2],\\n            len_bytes[shift + 3],\\n        );\\n    }\\n    msg_block\\n}\\n\\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\\n// and that everything between the byte pointer and the size pointer was zeroed,\\n// and that everything before the byte pointer was untouched.\\nfn verify_msg_len(\\n    msg_block: MSG_BLOCK,\\n    last_block: MSG_BLOCK,\\n    msg_byte_ptr: BLOCK_BYTE_PTR,\\n    message_size: u32,\\n) {\\n    // Check zeros up to the size pointer.\\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\\n\\n    // Check that up to the pointer we match the last block.\\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\\n\\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\\n    let mut reconstructed_len: u64 = 0;\\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\\n        reconstructed_len = reconstructed_len * TWO_POW_32;\\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\\n    }\\n    let len = 8 * message_size as u64;\\n    assert_eq(reconstructed_len, len);\\n}\\n\\n// Perform the final compression, then transform the `STATE` into `HASH`.\\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\\n    // Hash final padded block\\n    state = sha256_compression(msg_block, state);\\n\\n    // Return final hash as byte array\\n    for j in 0..8 {\\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\\n        for k in 0..4 {\\n            out_h[4 * j + k] = h_bytes[k];\\n        }\\n    }\\n\\n    out_h\\n}\\n\\nmod equivalence_test {\\n\\n    #[test]\\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\\n        let message_size = message_size % 100;\\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\\n        let sha = super::sha256_var(msg, message_size);\\n        assert_eq(sha, unconstrained_sha);\\n    }\\n}\\n"}}'),r={transpiled:!0,noir_version:e,name:n,functions:t,outputs:s,file_map:a};export{r as default,a as file_map,t as functions,n as name,e as noir_version,s as outputs,i as transpiled};
