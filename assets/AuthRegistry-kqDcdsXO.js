const i=!0,e="1.0.0-beta.3+0000000000000000000000000000000000000000",n="AuthRegistry",t=JSON.parse('[{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6304245522015439386":{"error_kind":"string","string":"Function _set_authorized can only be called internally"}},"parameters":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3tTttKEIbvJb/5sd8fvZXqCAGlVaQIKqBHOqq49+MAtgM78cYzLpju+wfVzb7Z8ePxzux4vfm9+XZ9+evH+fbm++395svX35vd7dXFw/b2pjv6/Xi2ubzb7nbbH+eH/71R+z/amCfB/c+Lm/3x/cPF3cPmi7bepbPN9c23p3+H0H3J9+3uujsy5vGsaO+S7pu7ZMbW0RKNk/fhpXHyUR82/uessygesSia0aJsahYF53uLgncVi1zKg0XKv7XInsIou1cWPekiT+c8T+cVpXPKD9dGpfHk9lDKTlSwfR9a27GLQHHTqb+QOqehrdXh2Ry/LnPyqswJbl3mrItOXBeduC46ya7LnLgqc7JZlznhvc0ZwqtR5pU5ZduYhzAZcx6/2cRMtLbDNzujxraUyUZn11thtJlu7E3/vd7Ew6YdP6M0+In4efCT8NMK/ET84H8ifgb+J+MH/5Pxy+An4Wct+In4JfCT8HMG/ET8IvhJ+HnM36r8gur5BV3wQ/4i4heQP8v4OfCr8RvahtdN9/wS7l8ZP8w/RPwy7l8ZP/ifhJ9V8D8ZP/ifiJ9G/UXGD/NfET+D+ouMH56fi/hZ1F9k/DB/E/FzqL/I+DnwK6HgoVAJxSPTJaAgfS2hBOQEBBQkmiWUiOhNQEFIJqCgTlVCSQjJBBSE5BJKRpmIgIKQXEBxCiGZgIIqTQlFI80noMBTSih4yYCA0ujKWWNHKM6/hdLocrqo+x0CTLSW3fiJoAPBCkEdxvML6e2SRBfbvDEXJJhwF0sJtplGLEmwzYLRLIIxDlsLxFzE4kaXdi5JsM3niMsR9AqxWEqwzSLXggQb3aJhSYKIJFKCyGaEBA18UEoQ2YyQoEU2IyWIbEZIsNEFs0sSRCSREkQkERL0iCRSgm0uE1qQYKPLfGcRzHrYVjybkiBmdUKCcYEVkDoNG58fPpGmCXbjRt/aZ3fAe29b0Trk/kyjDq+++cn49ImNT+ETG7/Eo42PM74+ahxsFP2nd6AOyq7LnLQqc/S66Oh10THromPiqsw54d3qdzUnrMqcEwoZC5vzV+2cGE4oY4DfFL8MfhJ+Hv4n4wf/E/EL8D8ZvwR+En4nLDMGvyl+Efwk/JIGPxG/AH4SfhnzN8nO2eGEGib4TfFD/izhF9+/7vtX7bwWFfIXET+N/FnGD/4n4mfgfzJ+8D8RP4v5m4yfBz8JPzx/E/Jz4Cfih/mbiJ/H/E3GD88/RPwC8mcCCorKJZSITJeAgvSVgIKcoISSHKCUUBC9SygZIZmAgjpVASUphGQCCkJyCUWjTERAQUgmoCAkl1AMqjQEFKT5JRQLTyGgYEwpofg285TJncdTbPP2WW7n8dToguzl9ixOqc0bc0GCGXexlGCbEXM5glm1WUVbbmeh3OjS2AUJ6jbrc0sSRCyWEmxzlr4gwUaLP0sSRCQRErTIZqQE4YNCgg7ZjJQgshkpQWQzQoKNLjhekiAiiZBgQCSREkQkkRJEJJHt+pzxpElKcInNf7gbIHcl85EhvQFyDLFHmNzYNupn48MnNn6JbVs+ynitlni28YHWV8eNzriK9dYM44Z1+VUfZeukfG9QUmHcAilSp+pSvz7B5bGpte7Z+Pp+F4sbb9RgvDPTxsc0fHVM0U031tqFPIy+XqvD5k8n22jVyarBCqvdm0G7o9Jm3KtQcfAVgopvc911jUqbs5cKlQBfoajAVygqbc5eTTYDFeULKtGBCkGlzbVkFSqpzXylRqXNnQ8qVBrdJLdGBaMtRQWjbUlFN7pNbY0KfIWg0uiWqBUqrs1fyp2eB+lGf4G5RgW+QlA5oZLQIJWoQIWgAl8hqCT4CkXFNUmlkq+kNn9VvUIlW1AhqLSZr0xTMSfs7tUilTYjc40KRluCisZoS1FJoFJSMfAVgopts74yTcUaR1GJtl9NF50tNPS7X9n1HWVf9kO/7TStod/vqWjifA39DodWw+ro7rqnUhU4KrpGUVV5jiqx+kqsvjKrr8zpyynFUnGul9OsvjTrvOj9DWoqerSvqiJHZTVLFWaPMY7+MaCs+hXN2RCa+eOSo+/i6X4iwzZ6PU9Fk+Zr6LUg0wzS/DHT5fn9ePq+rWjmX1OvGf1oTj90TPO9X+doCg0dbysaRj/0yu5pDb3uuaJh9OMZ/fhQuT6Eho7r09c0hPmayOgnzs+HPF2dndZkxr2Q548HQRmGJs3XaMvQMPoxjPMx830nWMXQzPeDkDlZQsicLCHS1b5uwjROnrwuVZmjoldY1FT01a2q6Ayyexo7qFJJgx4h91lsr3Kq7MtrlsqzVJmjCrRH+fGNMO9VqUocVWT1Rb+TWlUFjorOh6qqzFAl5TiqIzOZmspzVIbVlzlyXnF48djnIsona1iqyFE5z1F5xVKxaPjEUQUWQzrv0XZ8UdxaXaoCR3WkllFTOZYqcVRHRoCaikMjK81SsfrSiqVyLBWHfD4Sza2LgyqoUpU4KvpHnmsqp1iqwFEdyRxqqsxRHckBpjOHHDgZUY6apZrd12N39O/F3fbicnd932n2H/66uXrY3t68HD7897P/5PJuu9ttf5z/vLu9uv726+76fHd7tf9so17+fO2KnGdOh701+0PjzZnxcX+4PyGnY/dp7nrtev4f","brillig_names":["_set_authorized"]},{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5444967152290923376":{"error_kind":"string","string":"Function is_consumable can only be called statically"}},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["is_consumable"]},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"4939791462094160055":{"error_kind":"string","string":"Message not authorized by account"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"H4sIAAAAAAAA/+2dBXgUV9uGJ9kkENxdgpNAws5KdjdYcHd3NskGAgGKhEI1daXuClRoqSv1Um+pu7e0hbq70v95253mZJiEr82ZlOcvc133tWM7c79n7MzMmXMSjD+7Ph7DaOr5sz8BeOK/iSDNNs76VfuTHear7TCursO4+g7jGjqMawZybePaO8yX5jCug8O4jg7jujmMy4j/qp01nBv/9XuzA4FYyBcz/WbU64vkhYPeQDAvO2yGzWA4WOAL+/2xcCAciuRFQt6IGfDHzMJgxF/o/bNr4ClblrdKnS/fTc+G/9wzYB8hbo1AkuIq6bAr3t/dKOtPV/obxuex/tcIw41Bk/g+nGTbVh5bGnir1pkZGpfVyKNv2zTTtg85b5tmyrZprPQ3Ufqb2rZNcwy3AC1BK4dtk6h523TTuK+31peepno+keWm2dJB93HaRt/5pMBpX2ijbHPprP5Eo+LjtC2G24H2En81HKfNNW6/thqP0w4uH6cdlG3TTulvr/Sn2bZNRwx3Ap1BF4dto3v/7KoxDdz07PbPPX32EXu63nVU+rsq/d1s26o7htNBBugR31bWtESj4i5XT3qbVt6vsnT3Vq0zO7qxfyQZZZlVw+UAuhvu7OC6NmZ+KBQORMyQq2lQTQe5t2qd2dqzd28ry1M9uHvGr5aZ9ruyng65C925rJ4ar4ZZLuWysuLpkBSP337GcmNHytR8Zbccrf5eVnCVXUZ6/Y+XES+GTeAD/mrImmdq3Gm8JGeWXhpijoZ9Qb8vHKvMs6rpGdB3u1Dopmfwn3v67SOcjqNABY8f1KxZ0HYcZWM4BMIgomTHPEb1nHSyXb56aT8RZGk8EeS4dPXIUa4eSUa15Kv91vrd3FncyJbqdkwncMwwyA66HI0HXW+XDrreykGXbFTPfVqC4e6GrOqys81IdnZeKN/NNGhOkpvKIfH06FuWV81B9LFfHewniaoe2DoToYfhzsbSHbPGE4DZkyTmRI0xZ5LErPGgNLOqKWZv1Tqzl8b0Y7lIeA0OT5PE00fi6SfxDJB4Bkk8s0k8QySeYRLPCIlnDolnbxLPPiSefUk8+5F49ifxzCXxHEDiOZDEcxCJ52ASzyEknkNJPIeReA4n8RxB4jmSxHMUiedoEs8xJJ5jSTzHkXiOJ/GcQOI5kcRzEonnZBLPKSSeU0k8p5F4TifxnEHiOZPEcxaJ52wSzzkknnNJPOeReM4n8YySeOaReOaTeBaQeMZIPAtJPBeQeC4k8Swi8VxE4rmYxLOYxHMJiedSEs9lJJ77kXguJ/FcQeK5ksRzFYlnCYnnahLP/Uk815B4riXxPIDE80ASz4NIPA8m8TyExPNQEs9SEs/DSDwPJ/E8gsTzSBLPo0g8jybxPIbE81gSz+NIPI8n8TyBxPNEEs91JJ4nkXieTOJ5ConnqSSep5F4nk7ieQaJ55kknmeReJ5N4nkOiee5JJ7nkXieT+J5AYnnhSSeF5F4XkziuZ7EcwOJ50YSz0tIPC8l8byMxPNyEs9NJJ5XkHheSeK5mcTzKhLPq0k8ryHxvJbE8zoSz+tJPG8g8byRxPMmEs+bSTxvIfG8lcRzC4nnbSSet5N43kHieSeJ510knneTeN5D4nkviedWEs/7SDzvJ/F8gMTzQRLPh0g8HybxfITE81ESz8dIPLeReD5O4vkEieeTJJ5PkXg+TeL5DInnsySez5F4Pk/i+QKJ54skni+ReL5M4vkKieerJJ6vkXi+TuL5BonnmySeb5F4vk3iuZ3E8x0Sz3dJPN8j8dzhkmeiZs+dyrKq2nZvtocj5vc1xpxF0l7xBwaH54cknh+ReH5M4vkJieenJJ6fkXh+TuL5BYnnlySeX5F4fk3i+Q2J57cknt+ReH5P4vkDieePJJ4/kXj+TOL5C4nnrySev5F47iLx/J3EUxbI4JlA4plI4ukh8Uwi8Uwm8Uwh8axB4lmTxDOVxLMWiWdtEs86JJ51STzrkXjWJ/FsQOLZkMSzEYlnYxLPJi552t+RV/W9doLGmJuSxNxdY8zNSPbH5glVTz9fOBzKy45F3fRskaBvO1e2D3mr1pktNXp2JylP00pjzJkkMbfWGHNrkpjbaIy5J0m5qbYk5/F2JJ7tSTzTSDw7kHh2JPHsROLZmcSzC4lnVxLPbiSe3Uk800k8M0g8e5B49iTxzCTxzCLx7EXi6SXxNEk8fSSefhLPAIlnkMQzm8QzROIZJvGMkHjmkHj2JvHs8x98D9j3PxhzP5L9sb+GZ/tmNC8vFigMuLltPBpjzq2m/dFbtc4coPG9Sx+Sd00DNcacQ/KuaRDJuWIwiecQEs+hJJ7DSDyHk3iOIPEcSeI5isRzNInnGBLPsSSe40g8x5N4TiDxnEjiOYnEczKJ5xQSz6kkntNIPKeTeM4g8ZxJ4jmLxHM2ieccEs+5JJ7zSDznk3hGSTzzSDzzSTwLSDxjJJ6FJJ4LSDwXkngWkXguIvFcTOJZTOK5hMRzKYnnMhLP/Ug8l5N4riDxXEniuYrEs4TEczWJ5/4knmtIPNeSeB5A4nkgiedBJJ4Hk3geQuJ5KIlnKYnnYSSeh5N4HkHieSSJ51EknkeTeB5D4nksiedxJJ7Hk3ieQOJ5IonnOhLPk0g8TybxPIXE81QSz9NIPE8n8TyDxPNMEs+zSDzPJvE8h8TzXBLP80g8zyfxvIDE80ISz4tIPC8m8VxP4rmBxHMjieclJJ6XknheRuJ5OYnnJhLPK0g8ryTx3EzieRWJ59UknteQeF5L4nkdief1JJ43kHjeSOJ5E4nnzSSet5B43kriuYXE8zYSz9tJPO8g8byTxPMuEs+7STzvIfG8l8RzK4nnfSSe95N4PkDi+SCJ50Mkng+TeD5C4vkoiedjJJ7bSDwfJ/F8gsTzSRLPp0g8nybxfIbE81kSz+dIPJ8n8XyBxPNFEs+XSDxfJvF8hcTzVRLP10g8XyfxfIPE800Sz7dIPN8m8dxO4vkOiee7JJ7vkXjuIPHcSeL5PonnBySeH5J4fkTi+TGJ5ycknp+SeH5G4vk5iecXJJ5fknh+ReL5NYnnNySe35J4fkfi+T2J5w8knj+SeP5E4vkziecvJJ6/knj+RuK5i8TzdxJPI5HDM4HEM5HE00PimUTimUzimULiWYPEsyaJZyqJZy0Sz9oknnVIPOuSeNYj8axP4tmAxLMhiWcjEs/GJJ5NSDybkng2I/FsTuLZgsSzJYlnKxLP1iSebUg825J4tiPxbE/imUbi2YHEsyOJZycSz84knl1IPLuSeHYj8exO4plO4plB4tmDxLMniWcmiWcWiWcvEk8viadJ4ukj8fSTeAZIPIMkntkkniESzzCJZ4TEM4fEszeJZx8Sz74knv1IPPuTeOaSeA4g8RxI4jmIxHMwiecQEs+hJJ7DSDyHk3iOIPEcSeI5isRzNInnGBLPsSSe40g8x5N4TiDxnEjiOYnEczKJ5xQSz6kkntNIPKeTeM4g8ZxJ4jmLxHM2ieccEs+5JJ7zSDznk3hGSTzzSDzzSTwLSDxjJJ6FJJ4LSDwXkngWkXguIvFcTOJZTOK5hMRzKYnnMhLP/Ug8l5N4riDxXEniuYrEs4TEczWJ5/4knmtIPNeSeB5A4nkgiedBJJ4Hk3geQuJ5KIlnKYnnYSSeh5N4HkHieSSJ51EknkeTeB5D4nksiedxJJ7Hk3ieQOJ5IonnOhLPk0g8TybxPIXE81QSz9NIPE8n8TyDxPNMEs+zSDzPJvE8h8TzXBLP80g8zyfxvIDE80ISz4tIPC8m8VxP4rmBxHMjieclJJ6XknheRuJ5OYnnJhLPK0g8ryTx3EzieRWJ59UknteQeF5L4nkdief1JJ43kHjeSOJ5E4nnzSSet5B43kriuYXE8zYSz9tJPO8g8byTxPMuEs+7STzvIfG8l8RzK4nnfSSe95N4PkDi+SCJ50Mkng+TeD5C4vkoiedjJJ7bSDwfJ/F8gsTzSRLPp0g8nybxfIbE81kSz+dIPJ8n8XyBxPNFEs+XSDxfJvF8hcTzVRLP10g8XyfxfIPE800Sz7dIPN8m8dxO4vkOiee7JJ7vkXjuIPHcSeL5PonnBySeH5J4fkTi+bFLnok2T783OxCIhXwx029Gvb5IXjjoDQTzssNm2AyGgwW+sN8fCwfCoUheJOSNmAF/zCwMRvyF8WV30xjzJ9UUs7dqnflpor706+3h2M5JGtPvM5J9O1ljzJ+TxJyiMeYvSGKuoTHmL0lirqkx5q9IYk7VGPPXJDHX0hjzNyQx19YY87ckMdfRGPN3JDHX1Rjz9yQx19MY8w8kMdfXGPOPJDE30BjzTyQxN9QY888kMTfSGPMvJDE31hjzryQxN9EY828kMTfVGPMukpibaYz5d5KYm2uM2SB5HtZCY8wJJDG31BhzIknMrTTG7CGJubXGmJNIYm6jMeZkkpjbaow5hSTmdhpjrkESc3uNMdckiTlNY8ypJDF30BhzLZKYO2qMuTZJzJ00xlyHJObOGmOuSxJzF40x1yOJuavGmOtrjBmL+qOMz854wD1AT5AJskAvWQcwgU/SAQRAEGSDEAiDCMgBvUEf0Bf0A/3jcQ8AA8EgMBgMAUPBMDAcjAAjwSgwGowBY8E4MB5MABPBJDAZTAFTwTQwHcwAM8EsMBvMAXPBPDAfREEeyAcFIAYKwQKwEBSBRWAxKAZLwFKwDOwHloMVYCVYBUrAarA/WAPWggPAgeAgcDA4BBwKSsFh4HBwBDgSHAWOBseAY8Fx4HhwAjgRrAMngZPBKeBUcBo4HZwBzgRngbPBOeBccB44H1wALgQXgYvBerABbASXgEvBZeBysAlcAa4Em8FV4GpwDbgWXAeuBzeAG8FN4GZwC7gVbAG3gdvBHeBOcBe4G9wD7gVbwX3gfvAAeBA8BB4Gj4BHwWNgG3gcPAGeBE+Bp8Ez4FnwHHgevABeBC+Bl8Er4FXwGngdvAHeBG+Bt8F28A54F7wHdoCd4H3wAfgQfAQ+Bp+AT8Fn4HPwBfgSfAW+Bt+Ab8F34HvwA/gR/AR+Br+AX8FvYBf4HcgBlgASgQckgWSQAmqAmiAV1AK1QR1QF9QD9UED0BA0Ao1BE9AUNAPNQQvQErQCrUEb0Ba0A+1BGugAOoJOoDPoArqCbqA7SAcZoAfoCTJBFugFvMAEPuAHARAE2SAEwiACckBv0Af0Bf1Af5ALBoCBYBAYDIaAoWAYGA5GgJFgFBgNxoCxYBwYDyaAiWASmAymgKlgGpgOZoCZYBaYDeaAuWAemA+iIA/kgwIQA4VgAVgIisAisBgUgyVgKVgG9gPLwQqwEqwCJWA12B+sAWvBAeBAcBA4GBwCDgWl4DBwODgCHAmOAkeDY8Cx4DhwPDgBnAjWgZPAyeAUcCo4DZwOzgBngrPA2eAccC44D5wPLgAXgovAxWA92AA2gkvApeAycDnYBK4AV4LN4CpwNbgGXAuuA9eDG8CN4CZwM7gF3Aq2gNvA7eAOcCe4C9wN7gH3gq3gPnA/eAA8CB4CD4NHwKPgMbANPA6eAE+Cp8DT4BnwLHgOPA9eAC+Cl8DL4BXwKngNvA7eAG+Ct8DbYDt4B7wL3gM7wE7wPvgAfAg+Ah+DT8Cn4DPwOfgCfAm+Al+Db8C34DvwPfgB/Ah+Aj+DX8Cv4DewC/wOJDORABKBBySBZJACaoCaIBXUArVBHVAX1AP1QQPQEDQCjUET0BQ0A81BC9AStAKtQRvQFrQD7UEa6AA6gk6gM+gCuoJuoDtIBxmgB+gJMkEW6AW8wAQ+4AcBEATZIATCIAJyQG/QB/QF/UB/kAsGgIFgEBgMhoChYBgYDkaAkWAUGA3GgLFgHBgPJoCJYBKYDKaAqWAamA5mgJlgFpgN5oC5YB6YD6IgD+SDAhADhWABWAiKwCKwGBQDaa9e2oKXdtalDXNpH1za3pZ2raXNaGmPWdo6lnaEpY1eaf9W2paVdlulTVRpb1Ta8pR2MkuBtO8obSdKu4TS5p+0pydt1Uk7cNLGmrRfJm2DSbtb0qaVtBclbTFJO0fShpC0zyNt30i7MtJmi7SHIm2NSDse0kaGtD8hbTtIuwnSJoHU9y916Us99euB1K8udZdLveBS57bUZy11RUs9zFLHsdQfLHXzSr23Uqes1NcqdaFKPaNSh6fUjyl1T0q9jlJnotRHKHX9ST16Uked1P8mdatJvWVSJ5jUtyV1WUk9UVuB1G8kdQdJvTxS543UJyN1tUg9KFLHiNTfIXVjSL0TUqeD1JcgdRHId/7yDb18ny7ffst31fLNsnwPLN/aynes8o2ofH8p3zbKd4PyTZ587ybfksl3WtuBfF8k3+7IdzHyzYnkd+VbCfkOQcr4S/l5KZsuZbWlHLSU5ZWyrVLWU8o+SllAKRsnZcWk7JSUJZKyNVLWRMpeSFkEeTcv76rl3a28y5R3e/KuS979yLsQeTcgz8rl2bE8S5Vni/KsTZ49ybMYeTYh9+py7yr3cnJvI3n9xD+zEIaUVZauh1HWxU8vsoo/pkvZXinrKmU/pSyklA2UsnJSdkzKUknZIilrI2VPpCyGlE2Qd/Xy7lre5cq7TXnXJ+++5F2QvBuRdwXy7FyeJcuzVXnWKM/e0kAH0BHIvbvcy8q9ndzrSPn57iAdZBi7d8lKf5P4b9MdA1ou37ZpiDpfWiXTOsd/t+Ru2Ji+ed1gdVpGJf/LrGBaSvw3HP9Njf8mxn8lrSWdc+PD3qp1ZqqyXN3LD3sD2alG+U6zvz9VWaYLy/dZy09yZ/l/lI+WbnBp+eUbtvV6bPM5/aduvD/B2H0eKw439iNs56DL6WRay09xZ/l+K93Uc4LHISZr/XWN8tvKmu70axjlt6lhW1ctw9V92KwsNtXf2jca2Oa3p0FFy0r+m8v6N7epmtbqNv1jntKyaYm2aUnKtGTbtOTS3WOU6197ZT6nY9CaL0Pp72FLIzfPz26dF6Rr7OCvrku6GqXGX52VHh5lnJWuVjrXVOe3TUtVpiWVll9PrfhwkrIedVmWR7Jt/vT4cP34b4ryH+v/DRzWn2Jbfzlvh3H2dEl1mD/VYX7ZfzvG+2vHkX3IpyyvouMg0dh9efWN3Y95678uH7O+BGP385L9/KKuX/KTTeP9K1ctWxEbsXTImlh+yaqiZUsHRfMXxtSTsH0hhkPw1rQEZXxFF2X7fzzK/GpX2yjLyCWVlp8/Nz7eW4UuFPZ6rXVaB0SyUT4RDdv6k23zh+LDtZR41Hhz/6FnYShqFvqjhdFgtKAgkB9tZFu+YZSlo6TT7Hg/ecY3r7oyvi4diH9l6Gq4s3zHjK8aizXd2oeHlJal5ZDS8k7WPMOUeYZVMM9wZZ7hyjzSVZaBtl+8VQ+nzOBQ27QkY3c3a5p6Yrac5ARundikv5niKN2I0jL3BNu0kco0y9fNGyXs7xGXbwB8jY2Kz8PWBa+vUT5drf3Jml9NB5f2a3+CbX2G4Zz5t9Zfy3D1OP4r81/D5mNPH2s/kQtq43h/frS4ePyKotXRVbGhJUvz5ZqqhqAuNtEhxIouserubp/PfojZDyv7oaQePupyK/q/fZy17vrG7vnUFJujfZPax9nveez/l87pFJNQwa+1HmMP63Fydjpd/dP1uPyMxdvA5qquy+XTStDpFGzY0rCy7aieRuzHgOGQvoYyj3qPOEhZrn0+u4/TvatTHtm+vZyeZ+zp3tie7qkVrCc3PuytWpftdOq2x6+muX171FSm/d3tYcX0d7eHmkY1bNPUY81jm6b6qZeyvf1WYWB8+N++VVAv+fWN3fdd+7ld3U72c5vb97PWfmGltd0nRZmuzj8y/iuxTrXFph4jlT3Pszuo86txJ9nSSz3Ga1RPelWaXXFKL2t+67hPqWB+Nf3V+SfGf2V4Rrzf6brqsU1LdFi20zFvpaHsr7qPl1g4UuCNFMaipmn6CryxPR0vutcfCEZD+dGQaUYCZixgBve0/qx4/753WpV2fpefyZpu5+ecbu2d8naV3W7L8Wjdhkh/E+X/6vIMo/K8uMu3va6/9/q77yQ8tmnJyjQ1v9nWlj5uvxd0691WY6Pi/cvKI3RX0sS+7yTY0sGt98gJtvUZhvNjAWtcLRe3i1e5zjo9Z3d6JyCPBaxHUMXLogVDVyxb4vygPcEhJe2/aio4zWOfzz6/05VWvdJY4/f2N0vd4sN785ultHg/w52JVarm374zsY4U8pxOcF9Op/JOV06njlHW/9f5xnC+C8nVuG1dTPtK3/xbV2br3KZeXZYuW1VUuHbQihieOheMLSkuLiosiq2wXxkqerbzv15BGM5m1uuff/ts9v+kLGKYvCxiYF9ZxD131XBP5var931lEY19ZRH/g2URw/vKIpbNX9EdY3p8eF9ZxH1lEcsljFOhiUSDM+O7t5RFtE6W5Bnf6L6yiJV3+8oi7rksovUCRi2XWFlZRJcz+ZG94cVCy/hwHaU/tnR5SawkNr4kr7go3yo1NyhaXGw/+as7mNrtjaXjnJ63W/4MF5R28eF/+4Lyf/DoSJQ4WQIA","debug_symbols":"7Vvdbts8DH2XXPtC/BOlvsqHD0PaZkOAIC3SdsBQ7N0nB5Pkpoo9ok2XNb4pIvscmeSh/mj3eXG7un769mW9/Xr3sLj673mxubtZPq7vtqn1vADeX3u4X2775sPjcve4uEIOsVustrfppwj/7BZf15vV4goQf3av0eh8RiOGgo7cAoegGRy9GweDRMjo9JsqHDW28F5ChnvVio6+hSZPGc3gXqD/7xYgc2iOhcbPoTkWGj3z0AjX0PgwERoELJYAyxtDE+bQHAtNbIcGqYZGJkLDIPIbzRChoBX7J6A7+ROg9QQigN8cokFQpakBBS4aUAy+wptBjR6yQel3wHF4wIIOKDihr0bOaI2RJtAkORkYB+o2sxIj5piTk3EwEGAJCMEE2EEeSuCGCcx7fXDW56z1oVmfP9JHSxRRiSZCrpo7Bo3yJn141ues9ZF30CeWsQ/sJEzow8EVgzgMNi9H4BrqJiA4Hi6gzThCiaNObHUuXXs/a3+x2uus/cVqH85e+wBc4Yzj2pOvB6wKTQm0dzaev7NSew+DBGs6m+ouEgeFFzk4UJK7MH/hk/mbphuuA10PCwaEF+Yv/VV/xQ3Op024lglfQ+1Z9zMt8Zkbn1bCvBCyHxo/r7BvWWFJzl13cG3de+M//lggjn01XmkI7y36+M2qUIRiEfNEEQEdYCmaO5yaIi99dIRZzs8kZ5zl/ERy8scfIJKEocqpbhzuqymehqtXc3sZXakiRKlRhGRU7yycu7PM2X7Pg7ex7SIIOS57NHLqDvbSjBfl7ZGTg2aDKO2TJrxNM00ZVyA+FrgXayGC+T3M0TJywSOOm5PefsSa/Apvjaf86w74j3YAHRGXlSetWi8sSo3r3XqzWX/78uLzMtf/aaeLlKEq4l5lmNgp3k5ROyUYKakFPbL9dtdTliAM3jQD0/EXjuMUsVO8naJ2SrBTmpuxgIXC4ZDSrhiOU8BOQTuF7BS2U8RO8XaK2inBTmmrH/IcFGJ8QRlbwkjrPplkZGv4ft3DabvH03ZPp+2eT9u9nLZ7f9ru9R27D/Sq+3Da7uNJu5fmqI3lQ8xIejiPCNgpaKeQncJ2itgp3k5RM8UHOyWaKXrkE9acMOj1MGEU7BS0U8hOYTtF7BRvp7S/X9f6IfWrUanBTolmSnB2CtgpaKeQkZJauD8SNM3zZQh4z4fHj/Y3vOMUslPYThE7xRspqUU98sj/LMXyAhCjPyiPpRbPR9E0t+/zrplEUophKsNFWhIxNb8vd+vl9WbVH+v7u0/bm3zKT83HH/f5Tq4D3O/ubla3T7tVXxGoxYA+Gwk6huQB9ENaXCdSjsn7Sx467/v7/QAJsYtQxkxPT8cGipnOrmOpqdFfAt8hFMmPP1AKA6Ujl9xMrv4C","brillig_names":["store_in_execution_cache_oracle_wrapper","call_private_function_internal","load","notify_created_nullifier_oracle_wrapper","store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal"],"verification_key":"AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAGGx7t6AYK9pp+sz79yGWAEZ6OnDjQw9Do3YDQmLdbp0DiRb8S8+G91LV/+Pe7k3bI+E6fj7QCRlgcD7j1rCKXRc0rL4DF9uewSIihG9yc5jiN5nrfvaKN2yfIYkVZ9OgJEShpSozifZh2sfOJXKzNzVyUcaTAl6vPRqmHhEtcb4klgEUWKDobYj+UO+lqgdjpzlayeTFqXsr6WtwOd7/JRyUI9UpUPbDkKbU7c7til3D5hUZ/uNstxo4H0eLcG+oJisiDoto9LLLkNd6uj8HfNqei1JVDCIbnlA5O7At7WEFbMQwSnkNmqvXg+nYBZKN+dC4wf9l6uGqYKvNDAncQxvpl+IP3kdKiU52C3DhuwFCnnqMTdXBX+5VOhageR7qGo4A475ukbhRQWLejSavmbZx5f61XMD5AuJT2PeCVXAu2CCCQ6Dlbk6RKkXbzIugQmCi7vb7xVMyGKXmvT0Y9R0iAC5k8tE+atr8jK6zbEEykoKw4sJzutsozhvCpcAVBFa7cBtbC0Y7vPDE/nGQVSOT0JUz4bIAS9hOn4pTqI8DgPTmuzBHdr/U+yLiCYd0FWSB6aP48JHTDbEAOm2qtCmMMxH8kXD5LelAsEKquZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsImCjclwyV9ZQIs0eVdlH3h5t+RlUI3oDlOwUkk4EvdQJFY/pw9nWn1hTCcLQT5v7xGkLwAIQ/Bk8lj1tsuOkUBEaaSojsxkh0W+CBOx+ruHewxInO99l8WBpVEQ7U588el/co6iBBGB3FWO62ZwA1hYsQppYIoSATat24EL8IkgCmHerHazcMpPQvc6Zly3Wp69xYzUvfivfn/P+jbVtxLll4nw2duz8VreU4S3hJDbHYM3nHO+QRI96/yIyfyNYrcq3BN0OMoNM3FEWlepaQ5kT1hLr6RUEkzwGtW+CxOQEZ4kHuu+v/XH1/INxsWtG2r3jcIG1/d4U/Bf3n69NyKCqLs0XGPB4YwJyVhdJP8sNrg3DqX1AKLFSisfc1nAcXV8tIZJpbEXWw6ql6jJDqzk+Pp1/WfNgovcWLYt3ury7evSlEGvXAi70WFzuAfEkL2YTT1S5xgWlf3HVSQAQ/KvH1RauHiw7PeKgD7Itu+7Btc58hids4bFjTrsLSjkcVxuGKgNkchrR65skEBSbydVx1b6LV46KKUgyEzggYBReMe20YosrIa4iSj86DpB8F7+IuXirTJbmm3FRPXJ3wL865AAyxuugu/QR41CN5sINr3qg5CkosrCz2r46ei+4wA4zdf4IAlB0VPUcMA1R/cm8vKNfGd3ssh5WTIwi0UwZmchY6s8nkd20LxF6omghe5ugW/V6UBvJUc/ra081eC5fKn2PofoFd9JOm0ExOqxWiqSNZoJJzA2/5Jjw2LhUvN1PnrdDA9h23rzcsH6rhBAzruJyhG/X7bF16rRQnUhEf2upuDlkR9eGWVrVCM0HaLO9ca2V9vsPJkPhdqyrfGAKRQOYD8pCbbRk/vb68Y+wLYtfxxS0g2kN+OWkh4N4N+xYW8RN1+bUnpz4QnLBG+PUPFvaoxAxJlXP24uMWmysxT01TvL04QBa3MAgDdHm4ut1s4BA2ul1BRg9z31wNBaHJhXmfmCz61FmLCWGYrAzHZZJsamXKUni596TlOAIDBCQjSbQXmztPZTA837S4WZ/PvkgfkgD2zgkaw5CluhrIaPns08WRy7r8ZMZrUQ4Tzcj0LKKvshJfXcHEATyHHqGPhpLupKSrsYPSFoKDDdHkVXetHhDrSAYZv1hgCM4a4alZyyDroMm5N+A2/zPDAB7JdicSK4xeDNXtxm4GkwrcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACI0/Bx6/BkMJAU7VYrBY7z/E1DWAUymCZstQRNUjiKIII650zdewGCRlEqALo3R6B2kgUMn7fMxqutLU5yPCBvQDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"},{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"_log_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"_unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/+Wc6XLbNhDHKZu0TcmyZPmK3Svp3bRpKYnU0dNt0/u+lM+KYz8HHyPta7Rf2qer/jFXWsHojDteTPxPMMOhpYV2f1wuARBYuBadl8nsqFV/x9V5vTrj+060XKTucXXOrla6hrqyUIw1AsYVAsZVAsaYgDEhYFwjYFwnYNwgYEwJGOsEjA0Cxk0CxiYB4xYBY4uAsU3AuB2AMQRnh4Rzx5BTj+1D8e5G1z9G9wgY9wkYDwgYbxAwHhIwHhEwPkPA+CwB43MEjM8TML5AwHiTgPEWAeOLBIwvETC+TMD4CgHjqwSMrxEwvk7A+AYB420CxjcJGN8iYLxDwPg2AeM7BIwZAWOXgLFHwNgnYMwJGAsCxgEB45CAcUTAOCZgfJeA8T0CxvcJGD8gYPyQgPEjAsZjAsaPCRg/IWD8lIDxLgHjZwSMnxMwfkHA+CUB41cEjF8TMH5DwPgtAeN3BIzfEzD+QMD4IwHjTwSMPxMw/hKAMQTnryScv5FwTgJxRvcc6JXZgY1b2BiFjUfY2IONM9iYgo0f2FiBjQvYGIDEeyS2I3G8PTuQ+IykYiTsIgkWSaZI4kSSJJIQkeSHJDokqSEJDElWSGJCktDN2XFrdiCJBEkaSIJAkgEW8bFIjkVoLPJiERWLlFgExCIbFrGwSISrwiIHFhEwSY9JcEwyYxIXk6SYhMQkHybRMEmFSSBMsmASQyYJ8JKLl0i8pOElCC8ZGMRjkIxBKAZ5GERhkIJBADpZdGLoJNAIo5FDI4KHFA8AgmsS/XeRIPmnOqfVeUXJDTfRdVPHrqX+UTa+n3quz5C/n1Y6N4LoL4aiPw3Dn8lG27vlQr++FrG7Wp0n5cKXk3KZSeo8VHUeOnXkesLc7zwP669ur+n4KFLXIrbrYWz3a449fV+0TOzXo5Cxeb4pWdsTHtc/0nY0pU654Kk5sri8eB0iS5RM7i/s3Fb13NjacGTCgiLx21S+kXKvksk9jZVOu3gtRmHjNc8eX7zm3ScxXmNHFpcXr+P/xquOLTdek2hRpC0V2ZqS/e7I1pXsj3Jhu1Acg+rvsG3yeR+snz3rPmzHw69toayXC39IDK6q7xLlv0f+0fUdWapkcblsp159jpUdrUs4Eqd+Xn1uVec19Rv5fdtjf82xv8Tt+c71S+qpn3rqI9buVH83qgMx9Jf8Jrr47OI4rj5nVyrDwtdO2ukfdH1toaH+U9HfCKK/l4n+zTD8836qGeb+DkT/Vhj+efy0wvD3RH87DP+Z6N8Owz9/j+kE0V/Mx+U7Yfjn8b8bxv9z/r0w/HP9+2H45/f3IIz+sYw7bkSL4o4zD9X3dv1/b3zZcabYrzusocaZhw6P6x89zoTsyMPa9sjcZ/TIY+fIY8ena9NQ14Ghrm1DXQ1DXfuGutqGuuqGuvYMdbUMdaWGuizvo6W/LGN111CXZaxuGeq6ru2E5fNo6fvrGqsbhrosY8IyVi39tWOoy7KNthwDNA11WfYdls/QdY2vp6H9CtEPhV0PzDLfPFhkp987D2aoPxNfS6zquW9tU64vcer/6fh5M4ife1N5J5M2SPvCN1dlabvm2Isi//us2G96eIS77pFd5R/Mno5OTsf383wwzIuifzKsOfqF1f1OzzvrPkfX970b++bVDH098q3xtJRfUWIl23JkiZIJo17j8c07WvJfxv/aftsjc8del72XnWg51vTz2IgWz3Bc2l/7cHTeljxirPQn0fIabuTYT5z6f1ef3bbuqs/I2XDaPetPz6bF9MGD/GTacfRrH8JP/wJJ9PoyCV0AAA==","debug_symbols":"tZbRCoMgGIXfxWsv0sq/9ipjDCsbglhYDUb07tOILbbrcxMd+fXzwg/OyjrTLI+79f0wsct1ZW5o9WwHH9O6cdYE65x93M/LLEsfUap9wzRqn/I06zCzi8iFrDkzvtv/qY6H9NaZmGS+8b95kscw0WeyoO3GI4DQgAoNqMEAlaEBAg2QaECOBhRoQIkGoE1WaJMV2mSFNpnQJhPaZEKbTGiTCW0yoU0mtMmENpmgJm8xPXWwunHmaDj94ttT4Zlfo/npPmMYWtMtwaQW9C1A6TUWkpcyXTvZK6qMi6qMkAh6Aw==","brillig_names":["process_log"]},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["unconstrained_is_consumable"]},{"name":"consume","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"12737498021964987455":{"error_kind":"string","string":"unauthorized"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"715723737710351018":{"error_kind":"string","string":"rejecting all"}},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["consume"]},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_authorized"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"12737498021964987455":{"error_kind":"string","string":"unauthorized"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2830029349304997821":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":27},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5444967152290923376":{"error_kind":"string","string":"Function is_consumable can only be called statically"},"6304245522015439386":{"error_kind":"string","string":"Function _set_authorized can only be called internally"},"715723737710351018":{"error_kind":"string","string":"rejecting all"},"9474245853673257536":{"error_kind":"string","string":"Function is_reject_all can only be called statically"}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":58},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"}},"parameters":[],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["sync_notes"]},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3bTus6EIbfpde98GF84lWWthCHLlSpalEpW9pCvPtOuohTatMQj7VU5P8GETITT77YnvH4wNvicXX/+nS73v7evSxufr0tNruHu8N6t+2u3t6Xi/v9erNZP92e/nkh+h9S6KPCy/Pdtr9+OdztD4sbSeSXi9X2sf/V2u4Rv9eb1eLG0PsyESYvB2HyahR2OiPsjbEfwt44eSr8z7Izx+fNUTaaQ+6yOVJYPQhLqaOwtDl7pI9PDj7KammP5kh9Xea4qzJHqesy57ro6Ouio6+LDsnrMsdclTlGXJc59LfNiU5CCfXJnFTWBTIfwi6E8cnKhYy0jk8mJUbZnMlKBhqsUFJdFjaRhVHuVPTIL4Afh5/V4Mfi58GPw8+h/vH4of6x+HnUPx4/B34cfkGCH4ufBT8GPyUE+LH4GfBj8cP4bZKfFQM/K8/5ScQvPH6In1n8/n6i+ufxi7L2s2jPj9B+efww/mDxM2i/PH6ofyx+FvWPxw/1j8XPIf/C44fxL4ufR/6Fx4/Aj8UP+RcWv4DxG48f8i8cflogfs5AwaRQCkUi0s1AQfiagYKYIIWiCFBSKPDeKRQNl5yBgjxVCoXgkjNQ4JJTKAZpogwUuOQMFLjkFAp2OeSgIMxPoWA/Qg4K+pQUCnYOpFBItAlF6REKmXMoqs0w38kwWOG0LhY+EmxzTDCHoLTj+1l/vk6TdJsDiJoE23SCFQk2uta1JsE2s2izCDoXYbiQ+OJG17vWJNjm5GpFgha+mEuQQJBJENEMk6CDJ+ESRDTDJOhRB7kEEc0wCQZEM1yCBIJMgohmeARNo+uIaxKEJ2ESlPAkXIKYJ+ESbHNRxCyCQarh/YJKCCqM6pgEdYX5YunjKfOnM9J5gsa4QbqbdBgZyt62lKF1A0JPo6yTf4y3P9h4+snkKfxg47+xltOZCeO1ir2GpvCpiFTaCzPY44UduWT/tQL5YX0HhVFU6z/t9RtnUNe2XYloO6nLtjsfH+28o8vCUpINsevtIrJT8f5dXZv+UYtohZZ03mE3ugl9AgpqSgoltBkcXYRiG809TEBBTUmhSNSUDJQ2E08qqAhFmIkBl4ijs+5V/TlB1WbiqSZBAsEpglLrk8g6IdhmuFSRYKNbjCsSpDbda02C8MXTBK2J7+cTT9LogZazCJIQEYZI6mCjR1rWJNjmNFpNgohmmAQb3V46i6AZk+bGiIRgm4uCKhJs9HDLegSdgC/mEkREzSTYaNK0JkFEM0yCyA9yCTa6gb8mQYzqmAQJdZBLEP3gNEEXF0eacH7CkGt0A39NgsiwMglaeBImQQdPwiUIT8IliPwgk2Cj288rEgzID04S1ONmGa1lQhD5QR5BL+CLuQThi7kE4YuZBJHlZxOEJ2ESbPSg45oEUQeZBDFPwiZIIMgkiGiGSRAr0b9BkFwkaEVCEHWQSdAgy88k2OhBxzUJIh5kEsRuCDZBrH5jEsRafuZuCO+xZoFJEDNNbIKogzyCAWv5zwj2UHw2SHZ6OG7BkT5TkSK/rSTQUE4wJtUxBTphvo7UBTr5pnXxzAkplCrSsiVaX5zJOKVVVBYVlUVFZZmiskxRWbboe9mislzRe32x8XdKK5RofREUTmkVtZSg5vcx+YUVQQwnIQaV6MiCfknmW/HlclSBbfmJgQkdKtDx8xmQLtApKCffbi/r2IJvagvKcQXl5NtrMEO9Dk4lOnl/O6FTUE5+8+yEjp+to4Qu0CkoJ7/A4OT75HTc7G+qlCrQKShHz4+HVH4DzITO/LagjC7Qmd8fqPz/UZvQmR8TKldQjit4H19Qd3zB9wkz68F7d/Xv3X59d79ZvXQa/c3X7cNhvdt+XB7+ex7u3O/Xm8366fZ5v3tYPb7uV7eb3UN/byE+fvzqPtxSeXP0092l9HopvT92If1db7u7viu1K/l/","brillig_names":["set_reject_all"]},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"9474245853673257536":{"error_kind":"string","string":"Function is_reject_all can only be called statically"}},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3bbuMsEMffJde9YDizr7L6VPWQrSJFSZWmn7Sq+u5rp7FzAMULg6pk+d9UdcJkhp8xM8CAP2bP88f3l/vF6tf6bfbj58dsuX562C7Wq+7q4/Nu9rhZLJeLl/vjj2ei/0NC7gTeXh9W/fXb9mGznf0gLRzdzear593/QXU/8muxnHdXUn7eReVdV2Rf3JEIY2mnEoWD1HZfOEh7Uvi/u84i9zcWmROLejmShXKF+qQpk1MiJae1NHsxrbUdpYxOECRhB9xEdHRzbIo3+QE3BT+WVWS/zNHXZU64KnP0ddHR10XHXBcd46/KHCuvyxx3VeY4+m5zzGCOFPLEnIQ/C3oww4Uj7yddSJRW4y9rKQ5lUyZLCnqwQpK8XNjI4XeNdMdFd/ws+HH4eQF+LH4G/Dj8Atofjx/aH4efFGh/PH4a/Fj8PPhx+JECPxY/B34cflKCH4sfxm+T/KwY+Fk656cQv/D4IX7m8QvgN8VvLGtPi/b8LJ5fHj8Nfix+eH5Z/BzaH48f2h+Ln0f74/HD/AuLX8D4l8cP8y8cfkpg/ZzHD/MvLH6E8RuPH+ZfePwQP8dQJBaFElAQ6cZQFMLXBBTEBDEUjUAzAQXeOwEFLjmG8v058rcABS45hmLhkhNQME0UQ8HeiRQUuOQYCnY5pKAgzI+hYD9CCgr6lAiKxs6BBBTZJhSpDlC0OYei2gzzHYXBCqdUceGeoG5zTJBDkOyhftZTRLDNAURFgqZNJ1iRYKO5rjUJahCcIujceN6CC5EvbjTftSJB1+biak2C8MVMgr7Nmb+aBBHNcAnCkzAJBg2CTIJogzyCRiCa4RJENMMkSIhmuAQRzXAJwpMwCTaadFyTIDwJk2Cj6cw1CbaZFJFFMJAc6hdkRPD7z4r+5whWWC8m7wcNxyvSaYLGuKF0t+hwYEi9bTFD6waEXh/KOtoZb9QtG3/L5K29YeP/IpfTminjVRh7DXuqImGOsYPxzviJdzU4dTBeC3u5cGfHeGJSb5M6Lr6rq/v2upqxrlboy+YbN/RNx1iU+uqbvLxh22+Xu210n7YSoxWK9JmjtI1OnExAQUuJoUgNKDGUNud8LkNRaCkJKGgpMRTd5oSfDHKEIszEQFeMo+Kuqj4i2OaEX0WCps0IKIsgqUP9DEUE2wyXKhJsNCm1JsE23WtFgo0mpeYRtGasn488SaPJWFkEtRjn9bSI2mBoc5tXPYJOtLl8WZMgohkmwUYPdMwiaORYP2NERLDNZKyKBFvdRV2RIHwxk6BCRM0liFEdk6BGNMMkiPlBNkHMUTMJNnqgX02CaINMgo0eFZhHcExAIhNkRBDRDJNgo69qqkiw0ZcN1SQIT8Ij6Bt94VBNgpgf5BKEL2YSJMwPThJUh01KSp2vk/hGt7vWJAhfzCSo4Iu5BOGLuQThi5kEkUfNJohohknQoA1yCSKaYRK0iGa4BBHNcAkimpkmqN1I0J6vNPlG379UkaDHLD+XIHwxk2BAPMgliDEJj2BALj+XIHL5mbshAmkQZBJEP8gk2OjZLRUJIpf/jGAHhYRMjtTceMCX0yqSSWekBz0oCibWY0SBjC6Q8fky6dzcy4dOdB+5Eql0DuaklC2R8kW6fJGuUKQrlOgiQUVSJfeLqEgXFdUrveNtUkoXSfkSKSWLpFx2H0M6yT2I4RWjQSZk8vslSj/Fl/W4AtvSM2ITMiFfxqt8Bj6/z6SQr0emn9sJmfx7KqlADxXoST+vwQztOjgZy5h8GVWgJ/263csy6TXoCZkCPaZAT3pl7ej+JGTSfv3yPbUuX8YV6PGiQMbky4SCZyHk9wdKqAKZkC9DukCmQI8sqI/MbztKUYFMZjv47K7+f9gsHh6X87dOov/yffW0XaxX+8vt79fhm8fNYrlcvNy/btZP8+f3zfx+uX7qv5uJ/Z+fXYO/k0HtIrjusj8um74u+8rIoLtvbae10/wH","brillig_names":["is_reject_all"]}]'),s={globals:{storage:[{fields:[{name:"contract_name",value:{kind:"string",value:"AuthRegistry"}},{name:"fields",value:{fields:[{name:"reject_all",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}}],kind:"struct"}},{name:"approved_actions",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000002"}}],kind:"struct"}}],kind:"struct"}}],kind:"struct"}]},structs:{functions:[{fields:[{name:"parameters",type:{fields:[{name:"reject",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::set_reject_all_parameters"}}],kind:"struct",path:"AuthRegistry::set_reject_all_abi"},{fields:[{name:"parameters",type:{fields:[{name:"message_hash",type:{kind:"field"}},{name:"authorize",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::set_authorized_parameters"}}],kind:"struct",path:"AuthRegistry::set_authorized_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],kind:"struct",path:"AuthRegistry::is_reject_all_parameters"}},{name:"return_type",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::is_reject_all_abi"},{fields:[{name:"parameters",type:{fields:[{name:"approver",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}},{name:"authorize",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::set_authorized_private_parameters"}}],kind:"struct",path:"AuthRegistry::set_authorized_private_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::is_consumable_parameters"}},{name:"return_type",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::is_consumable_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"inner_hash",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::consume_parameters"}},{name:"return_type",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::consume_abi"},{fields:[{name:"parameters",type:{fields:[{name:"approver",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}},{name:"authorize",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::_set_authorized_parameters"}}],kind:"struct",path:"AuthRegistry::_set_authorized_abi"}]}},a=JSON.parse('{"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"24":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"46":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"47":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"54":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/auth_registry_contract/src/main.nr","source":"use dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract AuthRegistry {\\n    use dep::authwit::auth::{\\n        assert_current_call_valid_authwit, compute_authwit_message_hash, IS_VALID_SELECTOR,\\n    };\\n    use dep::aztec::{\\n        macros::{functions::{internal, private, public, view}, storage::storage},\\n        protocol_types::address::AztecAddress,\\n        state_vars::{Map, PublicMutable},\\n    };\\n\\n    #[storage]\\n    struct Storage<Context> {\\n        reject_all: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\\n        // on_behalf_of => authwit hash => authorized\\n        approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\\n    }\\n\\n    /**\\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\\n     *\\n     * @param message_hash The message hash being authorized\\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\\n     */\\n    #[public]\\n    fn set_authorized(message_hash: Field, authorize: bool) {\\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\\n    }\\n\\n    /**\\n     * Updates the `reject_all` value for `msg_sender`.\\n     *\\n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\\n     *\\n     * @param reject True if all actions should be rejected, false otherwise\\n     */\\n    #[public]\\n    fn set_reject_all(reject: bool) {\\n        storage.reject_all.at(context.msg_sender()).write(reject);\\n    }\\n\\n    /**\\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\\n     *\\n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\\n     * This is to support \\"mass-revoke\\".\\n     *\\n     * @param on_behalf_of The address on whose behalf the action is being consumed\\n     * @param inner_hash The inner_hash of the authwit\\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\\n     */\\n    #[public]\\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \\"rejecting all\\");\\n\\n        let message_hash = compute_authwit_message_hash(\\n            context.msg_sender(),\\n            context.chain_id(),\\n            context.version(),\\n            inner_hash,\\n        );\\n\\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\\n\\n        assert_eq(true, authorized, \\"unauthorized\\");\\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\\n\\n        IS_VALID_SELECTOR\\n    }\\n\\n    /**\\n     * Updates a public authwit using a private authwit\\n     *\\n     * Useful for the case where you want someone else to insert a public authwit for you.\\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\\n     *\\n     * @param approver The address of the approver (Alice in the example)\\n     * @param message_hash The message hash to authorize\\n     * @param authorize True if the message hash should be authorized, false otherwise\\n     */\\n    #[private]\\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\\n        assert_current_call_valid_authwit(&mut context, approver);\\n        AuthRegistry::at(context.this_address())\\n            ._set_authorized(approver, message_hash, authorize)\\n            .enqueue(&mut context);\\n    }\\n\\n    /**\\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\\n     * Used along with `set_authorized_private` to update the public authwit.\\n     *\\n     * @param approver The address of the approver\\n     * @param message_hash The message hash being authorized\\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\\n     */\\n    #[public]\\n    #[internal]\\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\\n    }\\n\\n    /**\\n     * Fetches the `reject_all` value for `on_behalf_of`.\\n     *\\n     * @param on_behalf_of The address to check\\n     * @return True if all actions are rejected, false otherwise\\n     */\\n    #[public]\\n    #[view]\\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\\n        storage.reject_all.at(on_behalf_of).read()\\n    }\\n\\n    /**\\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\\n     *\\n     * @param on_behalf_of The address on whose behalf the action is being consumed\\n     * @param message_hash The message hash to check\\n     * @return True if the caller is authorized to perform the action, false otherwise\\n     */\\n    #[public]\\n    #[view]\\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\\n    }\\n\\n    unconstrained fn unconstrained_is_consumable(\\n        on_behalf_of: AztecAddress,\\n        message_hash: Field,\\n    ) -> pub bool {\\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\\n    }\\n}\\n"},"56":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\\nuse dep::aztec::protocol_types::{\\n    abis::function_selector::FunctionSelector,\\n    address::AztecAddress,\\n    constants::{\\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n    traits::ToField,\\n};\\n\\n/**\\n * Authenticaion witness helper library\\n *\\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\\n * (e.g. protocols or other users) to execute an action on their behalf.\\n *\\n * This library provides helper functions to manage such witnesses.\\n * The authentication witness, is some \\"witness\\" (data) that authenticates a `message_hash`.\\n * The simplest example of an authentication witness, is a signature. The signature is the \\"evidence\\",\\n * that the signer has seen the message, agrees with it, and has allowed it.\\n * It does not need to be a signature. It could be any kind of \\"proof\\" that the message is allowed.\\n * Another proof could be knowing some kind of secret, or having some kind of \\"token\\" that allows the message.\\n *\\n * The `message_hash` is a hash of the following structure:\\n * hash(consumer, chain_id, version, inner_hash)\\n * - consumer: the address of the contract that is \\"consuming\\" the message,\\n * - chain_id: the chain id of the chain that the message is being consumed on,\\n * - version: the version of the chain that the message is being consumed on,\\n * - inner_hash: the hash of the \\"inner\\" message that is being consumed, this is the \\"actual\\" message or action.\\n *\\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\\n * a hash of the \\"action\\" to approve, along with who made the call. As part of this library, we provide a few\\n * helper functions to deal with such messages.\\n *\\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\\n * This can be used to let some contract \\"allow\\" another contract to act on its behalf, as long as it can\\n * show that it is acting on behalf of the contract.\\n *\\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\\n * derived as:\\n * inner_hash = hash(caller, \\"transfer\\", hash(to, amount))\\n *\\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\\n * the arguments for the transfer.\\n *\\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\\n * allowed to transfer the tokens.\\n *\\n *\\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\\n * is executed on the user\'s device, so we can use `oracles` to \\"ask\\" the user (not contract) for information. In public\\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \\"registry\\"\\n * to store the messages that we have approved.\\n *\\n * A simple example would be a \\"token\\" that is being \\"pulled\\" from one account into another. We will first outline\\n * how this would look in private, and then in public later.\\n *\\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\\n * convince the `Token` contract that it is allowed to do so.\\n *\\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\\n * execute that call.\\n *\\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\\n * funds from `Alice`.\\n *\\n * To ensure that the same \\"approval\\" cannot be used multiple times, we also compute a `nullifier` for the\\n * authentication witness, and emit it from the `Token` contract (consumer).\\n *\\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\\n *\\n *\\n *  Person          Contract              Contract               Contract\\n *  Alice          Alice Account          Token                   DeFi\\n *   |                  |                  |                      |\\n *   | Defi.deposit(Token, 1000)           |                      |\\n *   |----------------->|                  |                      |\\n *   |                  | deposit(Token, 1000)                    |\\n *   |                  |---------------------------------------->|\\n *   |                  |                  |                      |\\n *   |                  |                  | transfer(Alice, Defi, 1000)\\n *   |                  |                  |<---------------------|\\n *   |                  |                  |                      |\\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |<-----------------|                      |\\n *   |                  |                  |                      |\\n *   | Please give me AuthWit for DeFi     |                      |\\n *   | calling transfer(Alice, Defi, 1000) |                      |\\n *   |<-----------------|                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\\n *   |----------------->|                  |                      |\\n *   |                  | AuthWit validity |                      |\\n *   |                  |----------------->|                      |\\n *   |                  |                  |                      |\\n *   |                  |       throw if invalid AuthWit          |\\n *   |                  |                  |                      |\\n *   |                  |       emit AuthWit nullifier            |\\n *   |                  |                  |                      |\\n *   |                  |       transfer(Alice, Defi, 1000)       |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  | success              |\\n *   |                  |                  |--------------------->|\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |           deposit(Token, 1000)\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *\\n *\\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\\n * the messages that we have approved.\\n *\\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\\n *\\n * The `Token` contract can then try to \\"spend\\" the approval by calling `consume` on the registry. If the message\\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\\n * registry, see `main.nr` in `auth_registry_contract`.\\n *\\n * Person          Contract              Contract            Contract               Contract\\n * Alice          Alice Account          Registry             Token                   DeFi\\n *   |                  |                    |                   |                      |\\n *   | Registry.set_authorized(..., true)    |                   |                      |\\n *   |----------------->|                    |                   |                      |\\n *   |                  | set_authorized(..., true)              |                      |\\n *   |                  |------------------->|                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |         set authorized to true         |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   | Defi.deposit(Token, 1000)             |                   |                      |\\n *   |----------------->|                    |                   |                      |\\n *   |                  | deposit(Token, 1000)                   |                      |\\n *   |                  |-------------------------------------------------------------->|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\\n *   |                  |                    |                   |<---------------------|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |                    |<------------------|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |          throw if invalid AuthWit      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |           set authorized to false      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | AuthWit validity  |                      |\\n *   |                  |                    |------------------>|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\\n *   |                  |                    |                   |<-------------------->|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | success              |\\n *   |                  |                    |                   |--------------------->|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |     deposit(Token, 1000)\\n *   |                  |                    |                   |                      |\\n *\\n *\\n * --- FAQ ---\\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\\"IS_VALID()\\")` instead of just returning a boolean?\\n * A:   We want to make sure that we don\'t accidentally return `true` if there is a collision in the function selector.\\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\\n *      a success flag.\\n *\\n * Q:   Why are we using static calls?\\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\\n *\\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\\n *\\n * Q:   Why is the chain id and the version part of the message hash?\\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\\n *      chain to avoid a case where the same message could be used across multiple chains.\\n */\\n\\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\\"IS_VALID()\\")\\n\\n/**\\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit\\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\\n    let inner_hash = compute_inner_authwit_hash([\\n        context.msg_sender().to_field(),\\n        context.selector().to_field(),\\n        context.args_hash,\\n    ]);\\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit\\n\\n/**\\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\\n *\\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn assert_inner_hash_valid_authwit(\\n    context: &mut PrivateContext,\\n    on_behalf_of: AztecAddress,\\n    inner_hash: Field,\\n) {\\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\\n    let result: Field = context\\n        .static_call_private_function(\\n            on_behalf_of,\\n            comptime { FunctionSelector::from_signature(\\"verify_private_authwit(Field)\\") },\\n            [inner_hash],\\n        )\\n        .get_preimage();\\n    assert(result == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\\n    context.push_nullifier(nullifier);\\n}\\n\\n/**\\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit_public\\npub unconstrained fn assert_current_call_valid_authwit_public(\\n    context: &mut PublicContext,\\n    on_behalf_of: AztecAddress,\\n) {\\n    let inner_hash = compute_inner_authwit_hash([\\n        (*context).msg_sender().to_field(),\\n        (*context).selector().to_field(),\\n        (*context).get_args_hash(),\\n    ]);\\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit_public\\n\\n/**\\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\\n *\\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n *\\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\\n */\\npub unconstrained fn assert_inner_hash_valid_authwit_public(\\n    context: &mut PublicContext,\\n    on_behalf_of: AztecAddress,\\n    inner_hash: Field,\\n) {\\n    let results: [Field] = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"consume((Field),Field)\\") },\\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(results.len() == 1, \\"Invalid response from registry\\");\\n    assert(results[0] == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n}\\n\\n/**\\n * Compute the `message_hash` from a function call to be used by an authentication witness\\n *\\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\\n * B to transfer T on its behalf.\\n *\\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param selector The function selector of the function that is being called\\n * @param args The arguments of the function that is being called\\n */\\n// docs:start:compute_authwit_message_hash_from_call\\npub fn compute_authwit_message_hash_from_call<let N: u32>(\\n    caller: AztecAddress,\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    selector: FunctionSelector,\\n    args: [Field; N],\\n) -> Field {\\n    let args_hash = hash_args_array(args);\\n    let inner_hash =\\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\\n}\\n// docs:end:compute_authwit_message_hash_from_call\\n\\n/**\\n * Computes the `inner_hash` of the authentication witness\\n *\\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\\n * that is not necessarily a call, but just some \\"bytes\\" or text.\\n *\\n * @param args The arguments to hash\\n */\\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\\n}\\n\\n/**\\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\\n *\\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\\n *\\n * @param on_behalf_of The address that has authorized the `inner_hash`\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [on_behalf_of.to_field(), inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\\n    )\\n}\\n\\n/**\\n * Computes the `message_hash` for the authentication witness\\n *\\n * @param consumer The address of the contract that is consuming the message\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param inner_hash The hash of the \\"inner\\" message that is being consumed\\n */\\npub fn compute_authwit_message_hash(\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    inner_hash: Field,\\n) -> Field {\\n    poseidon2_hash_with_separator(\\n        [consumer.to_field(), chain_id, version, inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_OUTER,\\n    )\\n}\\n\\n/**\\n * Helper function to set the authorization status of a message hash\\n *\\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\\n *\\n * @param message_hash The hash of the message to authorize\\n * @param authorize True if the message should be authorized, false if it should be revoked\\n */\\npub unconstrained fn set_authorized(\\n    context: &mut PublicContext,\\n    message_hash: Field,\\n    authorize: bool,\\n) {\\n    let res = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"set_authorized(Field,bool)\\") },\\n        [message_hash, authorize as Field].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(res.len() == 0);\\n}\\n\\n/**\\n * Helper function to reject all authwits\\n *\\n * Wraps a public call to the authentication registry to set the `reject_all` flag\\n *\\n * @param reject True if all authwits should be rejected, false otherwise\\n */\\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\\n    let res = context.call_public_function(\\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\\n        comptime { FunctionSelector::from_signature(\\"set_reject_all(bool)\\") },\\n        [context.this_address().to_field(), reject as Field].as_slice(),\\n        GasOpts::default(),\\n    );\\n    assert(res.len() == 0);\\n}\\n"},"64":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// A dynamically sized array backed by PXE\'s non-volatile database (called capsules). Values are persisted until\\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\\npub struct CapsuleArray<T> {\\n    contract_address: AztecAddress,\\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\\n    base_slot: Field,\\n}\\n\\nimpl<T, let N: u32> CapsuleArray<T>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{\\n    /// Returns a CapsuleArray connected to a contract\'s capsules at a base slot. Array elements are stored in\\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\\n        Self { contract_address, base_slot }\\n    }\\n\\n    /// Returns the number of elements stored in the array.\\n    pub unconstrained fn len(self) -> u32 {\\n        // An uninitialized array defaults to a length of 0.\\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\\n    }\\n\\n    /// Stores a value at the end of the array.\\n    pub unconstrained fn push(self, value: T) {\\n        let current_length = self.len();\\n\\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\\n        // array, which is where we want to place the new value.\\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\\n\\n        // Then we simply update the length.\\n        let new_length = current_length + 1;\\n        capsules::store(self.contract_address, self.base_slot, new_length);\\n    }\\n\\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn get(self, index: u32) -> T {\\n        assert(index < self.len(), \\"Attempted to read past the length of a CapsuleArray\\");\\n\\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\\n    }\\n\\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn remove(self, index: u32) {\\n        let current_length = self.len();\\n        assert(index < current_length, \\"Attempted to delete past the length of a CapsuleArray\\");\\n\\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\\n        // array past the removed element one slot backward so that we don\'t end up with a gap and preserve the\\n        // contiguous slots. We can skip this when deleting the last element however.\\n        if index != current_length - 1 {\\n            // The source and destination regions overlap, but `copy` supports this.\\n            capsules::copy(\\n                self.contract_address,\\n                self.slot_at(index + 1),\\n                self.slot_at(index),\\n                current_length - index - 1,\\n            );\\n        }\\n\\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\\n        // the element we meant to delete in the first place) and update the length.\\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\\n    }\\n\\n    unconstrained fn slot_at(self, index: u32) -> Field {\\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\\n        // element.\\n        self.base_slot + 1 + index as Field\\n    }\\n}\\n\\nmod test {\\n    use crate::test::helpers::test_environment::TestEnvironment;\\n    use super::CapsuleArray;\\n    use protocol_types::address::AztecAddress;\\n\\n    global SLOT: Field = 1230;\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        TestEnvironment::new().unkonstrained().this_address()\\n    }\\n\\n    #[test]\\n    unconstrained fn empty_array() {\\n        let contract_address = setup();\\n\\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn empty_array_read() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        let _: Field = array.get(0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_push() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        assert_eq(array.len(), 1);\\n        assert_eq(array.get(0), 5);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn read_past_len() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        let _ = array.get(1);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_last() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(5);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_some() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        assert_eq(array.len(), 3);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 8);\\n        assert_eq(array.get(2), 9);\\n\\n        array.remove(1);\\n\\n        assert_eq(array.len(), 2);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 9);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_all() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        array.remove(1);\\n        array.remove(1);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n}\\n"},"65":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::execution_cache;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field];\\n    fn get_selector(self) -> FunctionSelector;\\n    fn get_name(self) -> str<N>;\\n    fn get_contract_address(self) -> AztecAddress;\\n    fn get_is_static(self) -> bool;\\n}\\n\\n// PrivateCallInterface\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let returns: T = returns_hash.get_preimage();\\n        returns\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns_hash.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateVoidCallInterface\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\\n    }\\n\\n    pub fn call(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticCallInterface\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n        }\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticVoidCallInterface\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicCallInterface\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    gas_opts: GasOpts,\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            gas_opts: GasOpts::default(),\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicVoidCallInterface\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n\\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.set_public_teardown_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticCallInterface\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticVoidCallInterface\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n"},"72":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        gas_settings::GasSettings,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Empty, FromField, Hash, ToField},\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn gas_settings(self) -> GasSettings {\\n        self.inputs.tx_context.gas_settings\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            // for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        // the number of side effects that took place), along with the hash of the return values. We validate these\\n        // by requesting a private kernel iteration in which the return values are constrained to hash\\n        // to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"73":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\\nuse crate::hash::{\\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\\n};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\\n\\npub struct PublicContext {\\n    pub args_hash: Option<Field>,\\n    pub compute_args_hash: fn() -> Field,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\\n        PublicContext { args_hash: Option::none(), compute_args_hash }\\n    }\\n\\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\\n    }\\n\\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\\n    }\\n\\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\\n    }\\n\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_l1_to_l2_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/\\n            self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash,\\n            leaf_index,\\n        );\\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()),\\n            \\"L1-to-L2 message is already nullified\\",\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\\n            \\"Tried to consume nonexistent L1-to-L2 message\\",\\n        );\\n\\n        self.push_nullifier(nullifier);\\n    }\\n\\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { send_l2_to_l1_msg(recipient, content) };\\n    }\\n\\n    pub unconstrained fn call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub unconstrained fn static_call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call_static(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_note_hash(note_hash) };\\n    }\\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_nullifier(nullifier) };\\n    }\\n\\n    pub fn this_address(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            address()\\n        }\\n    }\\n    pub fn msg_sender(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            sender()\\n        }\\n    }\\n    pub fn selector(_self: Self) -> FunctionSelector {\\n        // The selector is the first element of the calldata when calling a public function through dispatch.\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\\n        FunctionSelector::from_field(raw_selector[0])\\n    }\\n    pub fn get_args_hash(mut self) -> Field {\\n        if !self.args_hash.is_some() {\\n            self.args_hash = Option::some((self.compute_args_hash)());\\n        }\\n\\n        self.args_hash.unwrap_unchecked()\\n    }\\n    pub fn transaction_fee(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            transaction_fee()\\n        }\\n    }\\n\\n    pub fn chain_id(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            chain_id()\\n        }\\n    }\\n    pub fn version(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            version()\\n        }\\n    }\\n    pub fn block_number(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            block_number()\\n        }\\n    }\\n    pub fn timestamp(_self: Self) -> u64 {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            timestamp()\\n        }\\n    }\\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_l2_gas()\\n        }\\n    }\\n    pub fn fee_per_da_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_da_gas()\\n        }\\n    }\\n\\n    pub fn l2_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            l2_gas_left()\\n        }\\n    }\\n    pub fn da_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            da_gas_left()\\n        }\\n    }\\n    pub fn is_static_call(_self: Self) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { is_static_call() } == 1\\n    }\\n\\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        let mut out = [0; N];\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\\n        }\\n        out\\n    }\\n\\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n\\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\\n        }\\n    }\\n\\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\\n    where\\n        T: Packable<N>,\\n    {\\n        self.raw_storage_write(storage_slot, value.pack());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn is_static_call() -> Field {\\n    is_static_call_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_public_log(message: [Field]) {\\n    emit_public_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_opcode(gas, address, args)\\n}\\n\\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_static_opcode(gas, address, args)\\n}\\n\\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\\n    calldata_copy_opcode(cdoffset, copy_size)\\n}\\n\\n// `success_copy` is placed immediately after the CALL opcode to get the success value\\nunconstrained fn success_copy() -> bool {\\n    success_copy_opcode()\\n}\\n\\nunconstrained fn returndata_size() -> u32 {\\n    returndata_size_opcode()\\n}\\n\\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\\n    returndata_copy_opcode(rdoffset, copy_size)\\n}\\n\\npub unconstrained fn avm_return(returndata: [Field]) {\\n    return_opcode(returndata)\\n}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\nunconstrained fn avm_revert(revertdata: [Field]) {\\n    revert_opcode(revertdata)\\n}\\n\\nunconstrained fn storage_read(storage_slot: Field) -> Field {\\n    storage_read_opcode(storage_slot)\\n}\\n\\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\\n    storage_write_opcode(storage_slot, value);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(|| 0)\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeIsStaticCall)]\\nunconstrained fn is_static_call_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n// TODO(#11124): rename unencrypted to public in avm\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCalldataCopy)]\\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeReturndataSize)]\\nunconstrained fn returndata_size_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeReturndataCopy)]\\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\\n\\n#[oracle(avmOpcodeReturn)]\\nunconstrained fn return_opcode(returndata: [Field]) {}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\n#[oracle(avmOpcodeRevert)]\\nunconstrained fn revert_opcode(revertdata: [Field]) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeSuccessCopy)]\\nunconstrained fn success_copy_opcode() -> bool {}\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\\n"},"74":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr","source":"use crate::{hash::hash_args_array, oracle::execution_cache};\\nuse dep::protocol_types::traits::Deserialize;\\n\\npub struct ReturnsHash {\\n    hash: Field,\\n}\\n\\nimpl ReturnsHash {\\n    pub fn new(hash: Field) -> Self {\\n        ReturnsHash { hash }\\n    }\\n\\n    pub fn assert_empty(self) {\\n        assert_eq(self.hash, 0);\\n    }\\n\\n    pub fn raw(self) -> Field {\\n        self.hash\\n    }\\n\\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\\n    /// values.\\n    pub fn get_preimage<T, let N: u32>(self) -> T\\n    where\\n        T: Deserialize<N>,\\n    {\\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\\n        assert_eq(self.hash, hash_args_array(preimage));\\n\\n        Deserialize::deserialize(preimage)\\n    }\\n}\\n"},"75":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"77":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr","source":"// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\\n\\npub mod private_logs;\\npub mod partial_notes;\\npub mod nonce_discovery;\\n\\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\\n/// one for the combined log and note type ID.\\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\\n\\n/// The maximum length of the packed representation of a note\'s contents. This is limited by private log size, encryption\\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\\npub global MAX_NOTE_PACKED_LEN: u32 =\\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\\n\\npub struct NoteHashAndNullifier {\\n    /// The result of NoteHash::compute_note_hash\\n    pub note_hash: Field,\\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\\n    pub inner_nullifier: Field,\\n}\\n\\n/// A function which takes a note\'s packed content, address of the emitting contract, nonce, storage slot and note type\\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\\n/// address).\\n///\\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\\n///\\n/// ```\\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\\n///     if note_type_id == MyNoteType::get_id() {\\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\\n///\\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n///\\n///         let note_hash = note.compute_note_hash(storage_slot);\\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\\n///             storage_slot\\n///         );\\n///\\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\\n///\\n///         Option::some(\\n///             aztec::discovery::NoteHashAndNullifier {\\n///                 note_hash, inner_nullifier\\n///             }\\n///         )\\n///     } else if note_type_id == MyOtherNoteType::get_id() {\\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\\n///     } else {\\n///         Option::none() // Unknown note type ID\\n///     };\\n/// }\\n/// ```\\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\\n\\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\\n///\\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\\n/// along with its `compute_note_hash_and_nullifier` function.\\npub unconstrained fn discover_new_notes<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    debug_log(\\"Performing note discovery\\");\\n\\n    private_logs::fetch_and_process_private_tagged_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n\\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n}\\n"},"78":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr","source":"use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::MAX_NOTE_HASHES_PER_TX,\\n    debug_log::debug_log_format,\\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\\n    traits::ToField,\\n};\\n\\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\\n/// the complete note information, since it does not include content, storage slot, etc.\\npub struct DiscoveredNoteInfo {\\n    pub nonce: Field,\\n    pub note_hash: Field,\\n    pub inner_nullifier: Field,\\n}\\n\\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\\n/// cases it will contain a single element.\\n///\\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\\npub unconstrained fn attempt_note_nonce_discovery<Env>(\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\\n    let discovered_notes = &mut BoundedVec::new();\\n\\n    debug_log_format(\\n        \\"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\\",\\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\\n    );\\n\\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\\n    // is one of the note hashes created by the transaction.\\n    array::for_each_in_bounded_vec(\\n        unique_note_hashes_in_tx,\\n        |expected_unique_note_hash, i| {\\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\\n\\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\\n            // the note hash at the array index we\'re currently processing.\\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\\n            let hashes = compute_note_hash_and_nullifier(\\n                packed_note_content,\\n                storage_slot,\\n                note_type_id,\\n                contract_address,\\n                candidate_nonce,\\n            )\\n                .expect(f\\"Failed to compute a note hash for note type {note_type_id}\\");\\n\\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\\n\\n            if unique_note_hash == expected_unique_note_hash {\\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn\'t, then\\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\\n                // application already has more direct means of making a call to it fail the transaction.\\n                discovered_notes.push(\\n                    DiscoveredNoteInfo {\\n                        nonce: candidate_nonce,\\n                        note_hash: hashes.note_hash,\\n                        inner_nullifier: hashes.inner_nullifier,\\n                    },\\n                );\\n\\n                // We don\'t exit the loop - it is possible (though rare) for the exact same note content to be present\\n                // multiple times in the same transaction with different nonces. This typically doesn\'t happen due to\\n                // notes containing random values in order to hide their contents.\\n            }\\n        },\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered a total of {0} notes\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    *discovered_notes\\n}\\n"},"79":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr","source":"use crate::{\\n    capsules::CapsuleArray,\\n    discovery::{\\n        ComputeNoteHashAndNullifier,\\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\\n    },\\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\\n    debug_log::debug_log_format,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\\n// TODO(#11630): come up with some sort of slot allocation scheme.\\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\\n\\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\\n/// the packed public content.\\n// TODO(#10273): improve how contract log siloing is handled\\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\\n\\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\\n/// size and extra fields in the log (e.g. the tag).\\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\\n\\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\\n/// log that will complete it and lead to a note being discovered and delivered.\\n#[derive(Serialize, Deserialize)]\\npub(crate) struct DeliveredPendingPartialNote {\\n    pub(crate) note_completion_log_tag: Field,\\n    pub(crate) storage_slot: Field,\\n    pub(crate) note_type_id: Field,\\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\\n    pub(crate) recipient: AztecAddress,\\n}\\n\\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\\n/// notes being delivered to PXE if completed.\\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let pending_partial_notes = CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    );\\n\\n    debug_log_format(\\n        \\"{} pending partial notes\\",\\n        [pending_partial_notes.len() as Field],\\n    );\\n\\n    let mut i = &mut 0;\\n    whyle(\\n        || *i < pending_partial_notes.len(),\\n        || {\\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\\n\\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\\n            if maybe_log.is_none() {\\n                debug_log_format(\\n                    \\"Found no completion logs for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                *i += 1 as u32;\\n                // Note that we\'re not removing the pending partial note from the PXE DB, so we will continue searching\\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\\n                // is somehow removed from the PXE DB.\\n            } else {\\n                debug_log_format(\\n                    \\"Completion log found for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                let log = maybe_log.unwrap();\\n\\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\\n                // that we\'re getting the logs from the expected contract.\\n                // TODO(#10273): improve how contract log siloing is handled\\n                assert_eq(\\n                    log.log_content.get(0),\\n                    contract_address.to_field(),\\n                    \\"Got a public log emitted by a different contract\\",\\n                );\\n\\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\\n                // complete packed content.\\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\\n                let complete_packed_note_content = array::append(\\n                    pending_partial_note.packed_private_note_content,\\n                    packed_public_note_content,\\n                );\\n\\n                let discovered_notes = attempt_note_nonce_discovery(\\n                    log.unique_note_hashes_in_tx,\\n                    log.first_nullifier_in_tx,\\n                    compute_note_hash_and_nullifier,\\n                    contract_address,\\n                    pending_partial_note.storage_slot,\\n                    pending_partial_note.note_type_id,\\n                    complete_packed_note_content,\\n                );\\n\\n                debug_log_format(\\n                    \\"Discovered {0} notes for partial note with tag {1}\\",\\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\\n                );\\n\\n                array::for_each_in_bounded_vec(\\n                    discovered_notes,\\n                    |discovered_note: DiscoveredNoteInfo, _| {\\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\\n                        // temporary node connectivity issue - is simply throwing good enough here?\\n                        assert(\\n                            deliver_note(\\n                                contract_address,\\n                                pending_partial_note.storage_slot,\\n                                discovered_note.nonce,\\n                                complete_packed_note_content,\\n                                discovered_note.note_hash,\\n                                discovered_note.inner_nullifier,\\n                                log.tx_hash,\\n                                pending_partial_note.recipient,\\n                            ),\\n                            \\"Failed to deliver note\\",\\n                        );\\n                    },\\n                );\\n\\n                // Because there is only a single log for a given tag, once we\'ve processed the tagged log then we\\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\\n                // being completed.\\n                pending_partial_notes.remove(*i);\\n\\n                // We don\'t increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\\n                // shifts the elements to the left if the removed element is not the last element.\\n            }\\n        },\\n    );\\n}\\n\\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\\n/// supports looping in unconstrained code.\\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\\n    if condition() {\\n        body();\\n        whyle(condition, body);\\n    }\\n}\\n"},"80":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr","source":"use std::static_assert;\\n\\nuse crate::{\\n    capsules::CapsuleArray,\\n    oracle::note_discovery::{deliver_note, sync_notes},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\\n    debug_log::{debug_log, debug_log_format},\\n};\\n\\nuse crate::discovery::{\\n    ComputeNoteHashAndNullifier,\\n    MAX_NOTE_PACKED_LEN,\\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\\n    partial_notes::{\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\\n    },\\n};\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\\n// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\n\\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\\n/// the note completion log tag).\\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\\n\\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\\n/// public logs that will complete them.\\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\\n    _contract_address: AztecAddress,\\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\\n    // decrypted log, letting us continue the work outside of PXE.\\n    sync_notes();\\n}\\n\\n/// Processes a log\'s ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\\n/// which the notes would\'ve been created (typically the same transaction in which the log was emitted), along with the\\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\\npub unconstrained fn do_process_log<Env>(\\n    contract_address: AztecAddress,\\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let log_plaintext = decrypt_log(log, recipient);\\n\\n    // The first thing to do after decrypting the log is to determine what type of private log we\'re processing. We\\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\\n    // improved upon in the future to also handle events, etc.\\n\\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\\n        destructure_log_plaintext(log_plaintext);\\n\\n    if log_type_id == 0 {\\n        debug_log(\\"Processing private note log\\");\\n\\n        attempt_note_discovery(\\n            contract_address,\\n            tx_hash,\\n            unique_note_hashes_in_tx,\\n            first_nullifier_in_tx,\\n            recipient,\\n            compute_note_hash_and_nullifier,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n        );\\n    } else if log_type_id == 1 {\\n        debug_log(\\"Processing partial note private log\\");\\n\\n        process_partial_note_private_log(\\n            contract_address,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n            recipient,\\n        );\\n    } else {\\n        // TODO(#11569): handle events\\n        debug_log_format(\\n            \\"Unknown log type id {0} (probably belonging to an event log)\\",\\n            [log_type_id],\\n        );\\n    }\\n}\\n\\nunconstrained fn destructure_log_plaintext(\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\\n    // `storage_slot` and `note_type_id` must be updated as well.\\n    static_assert(\\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\\n        \\"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\\",\\n    );\\n    let storage_slot = log_plaintext.get(0);\\n\\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\\n    // distinguish private note logs and partial note logs.\\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we\'d be able to\\n    // leverage enums and tagged unions to achieve this goal.\\n    let combined_type_id = log_plaintext.get(1);\\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\\n\\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    (storage_slot, note_type_id, log_type_id, log_payload)\\n}\\n\\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\\n/// suspected the note was created.\\npub unconstrained fn attempt_note_discovery<Env>(\\n    contract_address: AztecAddress,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) {\\n    let discovered_notes = attempt_note_nonce_discovery(\\n        unique_note_hashes_in_tx,\\n        first_nullifier_in_tx,\\n        compute_note_hash_and_nullifier,\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered {0} notes from a private log\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    array::for_each_in_bounded_vec(\\n        discovered_notes,\\n        |discovered_note: DiscoveredNoteInfo, _| {\\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\\n            // issue, and we should perhaps not have marked the tag index as taken.\\n            assert(\\n                deliver_note(\\n                    contract_address,\\n                    storage_slot,\\n                    discovered_note.nonce,\\n                    packed_note_content,\\n                    discovered_note.note_hash,\\n                    discovered_note.inner_nullifier,\\n                    tx_hash,\\n                    recipient,\\n                ),\\n                \\"Failed to deliver note\\",\\n            );\\n        },\\n    );\\n}\\n\\nunconstrained fn process_partial_note_private_log(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    recipient: AztecAddress,\\n) {\\n    // We store the information of the partial note we found so that we can later search for the public log that will\\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\\n    static_assert(\\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\\n        \\"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\\",\\n    );\\n\\n    let pending = DeliveredPendingPartialNote {\\n        note_completion_log_tag: log_payload.get(0),\\n        storage_slot,\\n        note_type_id,\\n        packed_private_note_content: array::subbvec(log_payload, 1),\\n        recipient,\\n    };\\n\\n    CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    )\\n        .push(pending);\\n}\\n"},"94":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::{Hash, ToField},\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"115":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr","source":"use super::utils::compute_fn_selector;\\nuse std::panic;\\n\\n/// Returns an `fn public_dispatch(...)` function for the given module that\'s assumed to be an Aztec contract.\\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\\n    let functions = m.functions();\\n    let functions =\\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\\"public\\"));\\n\\n    let unit = get_type::<()>();\\n\\n    let ifs = functions.map(|function: FunctionDefinition| {\\n        let name = function.name();\\n        let parameters = function.parameters();\\n        let return_type = function.return_type();\\n\\n        let selector: Field = compute_fn_selector(function);\\n\\n        let mut parameters_size = 0;\\n        for param in parameters {\\n            parameters_size += size_in_fields(param.1);\\n        }\\n\\n        let initial_read = if parameters.len() == 0 {\\n            quote {}\\n        } else {\\n            // The initial calldata_copy offset is 1 to skip the Field selector\\n            // The expected calldata is the serialization of\\n            // - FunctionSelector: the selector of the function intended to dispatch\\n            // - Parameters: the parameters of the function intended to dispatch\\n            // That is, exactly what is expected for a call to the target function,\\n            // but with a selector added at the beginning.\\n            quote {\\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\\n            }\\n        };\\n\\n        let parameter_index = &mut 0;\\n        let reads = parameters.map(|param: (Quoted, Type)| {\\n            let parameter_index_value = *parameter_index;\\n            let param_name = f\\"arg{parameter_index_value}\\".quoted_contents();\\n            let param_type = param.1;\\n            let read = quote {\\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\\n            };\\n            *parameter_index += 1;\\n            quote { $read }\\n        });\\n        let read = reads.join(quote { });\\n\\n        let mut args = &[];\\n        for parameter_index in 0..parameters.len() {\\n            let param_name = f\\"arg{parameter_index}\\".quoted_contents();\\n            args = args.push_back(quote { $param_name });\\n        }\\n\\n        let args = args.join(quote { , });\\n        let call = quote { $name($args) };\\n\\n        let return_code = if return_type == unit {\\n            quote {\\n                $call;\\n                // Force early return.\\n                dep::aztec::context::public_context::avm_return([]);\\n            }\\n        } else {\\n            quote {\\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\\n            }\\n        };\\n\\n        let if_ = quote {\\n            if selector == $selector {\\n                $initial_read\\n                $read\\n                $return_code\\n            }\\n        };\\n        if_\\n    });\\n\\n    if ifs.len() == 0 {\\n        // No dispatch function if there are no public functions\\n        quote {}\\n    } else {\\n        let ifs = ifs.push_back(quote { panic(f\\"Unknown selector {selector}\\") });\\n        let dispatch = ifs.join(quote {  });\\n\\n        let body = quote {\\n            // We mark this as public because our whole system depends on public\\n            // functions having this attribute. However, the public MACRO will\\n            // handle the public_dispatch function specially and do nothing.\\n            #[public]\\n            pub unconstrained fn public_dispatch(selector: Field) {\\n                $dispatch\\n            }\\n        };\\n\\n        body\\n    }\\n}\\n\\ncomptime fn size_in_fields(typ: Type) -> u32 {\\n    let size = array_size_in_fields(typ);\\n    let size = size.or_else(|| bool_size_in_fields(typ));\\n    let size = size.or_else(|| constant_size_in_fields(typ));\\n    let size = size.or_else(|| field_size_in_fields(typ));\\n    let size = size.or_else(|| int_size_in_fields(typ));\\n    let size = size.or_else(|| str_size_in_fields(typ));\\n    let size = size.or_else(|| struct_size_in_fields(typ));\\n    let size = size.or_else(|| tuple_size_in_fields(typ));\\n    if size.is_some() {\\n        size.unwrap()\\n    } else {\\n        panic(f\\"Can\'t determine size in fields of {typ}\\")\\n    }\\n}\\n\\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_array().and_then(|typ: (Type, Type)| {\\n        let (typ, element_size) = typ;\\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\\n    })\\n}\\n\\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_bool() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_field() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.as_integer().is_some() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_constant()\\n}\\n\\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_str().map(|typ| size_in_fields(typ))\\n}\\n\\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\\n        let struct_type = typ.0;\\n        let generics = typ.1;\\n        let mut size = 0;\\n        for field in struct_type.fields(generics) {\\n            size += size_in_fields(field.1);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_tuple().map(|types: [Type]| {\\n        let mut size = 0;\\n        for typ in types {\\n            size += size_in_fields(typ);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn get_type<T>() -> Type {\\n    let t: T = std::mem::zeroed();\\n    std::meta::type_of(t)\\n}\\n"},"122":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\\n    notes::NOTES,\\n    utils::{\\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\\n        module_has_storage,\\n    },\\n};\\nuse protocol_types::meta::generate_serialize_to_fields;\\nuse std::meta::type_of;\\n\\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\\n    // Private Kernel Circuit.\\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\\n    // about the execution context (e.g. the caller).\\n    let original_params = f.parameters();\\n    f.set_parameters(&[(\\n        quote { inputs },\\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\\n    )]\\n        .append(original_params));\\n\\n    let mut body = f.body().as_block().unwrap();\\n\\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we\'ve received\\n    // the correct values.\\n    // TODO: Optimize args_hasher for small number of arguments\\n    let args_hasher_name = quote { args_hasher };\\n    let args_hasher = original_params.fold(\\n        quote {\\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n        },\\n        |args_hasher, param: (Quoted, Type)| {\\n            let (name, typ) = param;\\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\\n            quote {\\n                $args_hasher\\n                $appended_arg\\n            }\\n        },\\n    );\\n\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\\n    // and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\\n    // circuit expects.\\n    let return_value_var_name = quote { macro__returned__values };\\n\\n    let return_value_type = f.return_type();\\n    let return_value = if body.len() == 0 {\\n        quote {}\\n    } else if return_value_type != type_of(()) {\\n        // The original return value is passed to a second args hasher which the context receives.\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        let return_value = last_body_expr.quoted();\\n        let return_value_assignment =\\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\\n        let return_hasher_name = quote { return_hasher };\\n        let return_value_into_hasher =\\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\\n\\n        body = body_without_return;\\n\\n        quote {\\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n            $return_value_assignment\\n            $return_value_into_hasher\\n            context.set_return_hash($return_hasher_name);\\n        }\\n    } else {\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        if !last_body_expr.has_semicolon()\\n            & last_body_expr.as_for().is_none()\\n            & last_body_expr.as_assert().is_none()\\n            & last_body_expr.as_for_range().is_none()\\n            & last_body_expr.as_assert_eq().is_none()\\n            & last_body_expr.as_let().is_none() {\\n            let unused_return_value_name = f\\"_{return_value_var_name}\\".quoted_contents();\\n            body = body_without_return.push_back(\\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\\n            );\\n        }\\n        quote {}\\n    };\\n\\n    let context_finish = quote { context.finish() };\\n\\n    let to_prepend = quote {\\n        $args_hasher\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n        $note_discovery_call\\n    };\\n\\n    let to_append = quote {\\n        $return_value\\n        $mark_as_initialized\\n        $context_finish\\n    };\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n    f.set_return_type(\\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\\n            .as_type(),\\n    );\\n    f.set_return_data();\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\\n    let original_params = f.parameters();\\n    let args_len = original_params\\n        .map(|(name, typ): (Quoted, Type)| {\\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\\n        })\\n        .fold(0, |acc: u32, val: u32| acc + val);\\n\\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\\n        // We start from 1 because we skip the selector for the dispatch function.\\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\\n        dep::aztec::hash::hash_args_array(serialized_args)\\n        });\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n        // referenced. We instead ignore \'unused variable\' warnings for it.\\n        quote {\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n    };\\n\\n    let to_append = quote {\\n        $mark_as_initialized\\n    };\\n\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n\\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\\n    // bytecode.\\n    f.set_unconstrained(true);\\n    f.set_return_public(true);\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\\n    // Top-level unconstrained fns are contract entrypoints, but they\'re not explicitly designated in any way. They\'re\\n    // the fallback case for a function that matches no other rules.\\n    // TODO(#12743): improve this\\n\\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\\n    // public, but which *are* contract entrypoints (i.e. they\'re not opting out via the #[test] or\\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\\n        !is_fn_private(f)\\n            & !is_fn_public(f)\\n            & !f.has_named_attribute(\\"contract_library_method\\")\\n            & !f.has_named_attribute(\\"test\\")\\n    });\\n\\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\\n    // https://github.com/noir-lang/noir/issues/7714). We can\'t simply print a message since that\'d otherwise break the\\n    // output of utils such as `nargo test --list-tests`.\\n    // // We don\'t expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr\'s\\n    // // #[private] macro, possibly resulting in a non-standard interface).\\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n    //     !f.is_unconstrained()\\n    // }) {\\n    //     let name = f.name();\\n    //     warn(\\n    //         f\\"found private contract function \'{name}\' which does not have the #[private] attribute - make sure you know what you\'re doing!\\",\\n    //     );\\n    // }\\n\\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n        f.is_unconstrained()\\n    }) {\\n        transform_top_level_unconstrained(f);\\n    }\\n}\\n\\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $storage_init\\n        $note_discovery_call\\n    };\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\\n    f.set_return_public(true);\\n    f.set_body(modified_body);\\n}\\n\\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called internally\\";\\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\\n}\\n\\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called statically\\";\\n    if is_fn_private(f) {\\n        // Here `context` is of type context::PrivateContext\\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\\n    } else {\\n        // Here `context` is of type context::PublicContext\\n        quote { assert(context.is_static_call(), $assertion_message); }\\n    }\\n}\\n\\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\\n/// available for the current execution.\\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\\n    quote {\\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\\n        /// safe to call.\\n        unsafe {\\n            dep::aztec::discovery::discover_new_notes(\\n                context.this_address(),\\n                _compute_note_hash_and_nullifier,\\n            );\\n        };\\n    }\\n}\\n"},"123":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/mod.nr","source":"pub mod dispatch;\\npub mod functions;\\npub mod utils;\\npub mod notes;\\npub mod storage;\\npub mod events;\\n\\nuse functions::{\\n    stub_registry,\\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\\n};\\nuse notes::{generate_note_export, NOTES};\\nuse storage::STORAGE_LAYOUT_NAME;\\n\\nuse dispatch::generate_public_dispatch;\\nuse utils::{get_trait_impl_method, module_has_storage};\\n\\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\\n\\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\\npub comptime fn aztec(m: Module) -> Quoted {\\n    let interface = generate_contract_interface(m);\\n\\n    find_and_transform_top_level_unconstrained_fns(m);\\n\\n    let contract_library_method_compute_note_hash_and_nullifier =\\n        generate_contract_library_method_compute_note_hash_and_nullifier();\\n    let process_log = generate_process_log();\\n    let note_exports = generate_note_exports();\\n    let public_dispatch = generate_public_dispatch(m);\\n    let sync_notes = generate_sync_notes();\\n\\n    quote {\\n        $note_exports\\n        $interface\\n        $contract_library_method_compute_note_hash_and_nullifier\\n        $process_log\\n        $public_dispatch\\n        $sync_notes\\n    }\\n}\\n\\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\\n    let module_name = m.name();\\n    let contract_stubs = stub_registry::get(m);\\n    let fn_stubs_quote = if contract_stubs.is_some() {\\n        contract_stubs.unwrap().join(quote {})\\n    } else {\\n        quote {}\\n    };\\n\\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\\n    let storage_layout_getter = if has_storage_layout {\\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\\n        quote {\\n            pub fn storage_layout() -> StorageLayoutFields {\\n                $storage_layout_name.fields\\n            }\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    let library_storage_layout_getter = if has_storage_layout {\\n        quote {\\n            #[contract_library_method]\\n            $storage_layout_getter\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    quote {\\n        pub struct $module_name {\\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\\n        }\\n\\n        impl $module_name {\\n            $fn_stubs_quote\\n\\n            pub fn at(\\n                addr: aztec::protocol_types::address::AztecAddress\\n            ) -> Self {\\n                Self { target_contract: addr }\\n            }\\n\\n            pub fn interface() -> Self {\\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n            }\\n\\n            $storage_layout_getter\\n        }\\n\\n        #[contract_library_method]\\n        pub fn at(\\n            addr: aztec::protocol_types::address::AztecAddress\\n        ) -> $module_name {\\n            $module_name { target_contract: addr }\\n        }\\n\\n        #[contract_library_method]\\n        pub fn interface() -> $module_name {\\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n        }\\n\\n        $library_storage_layout_getter\\n\\n    }\\n}\\n\\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        let max_note_packed_len = notes.fold(\\n            0,\\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\\n                if len > acc {\\n                    len\\n                } else {\\n                    acc\\n                }\\n            },\\n        );\\n\\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\\n            panic(\\n                f\\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\\",\\n            );\\n        }\\n\\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\\n\\n        let mut if_note_type_id_match_statements_list = &[];\\n        for i in 0..notes.len() {\\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\\n\\n            let get_note_type_id = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteType },\\n                quote { get_id },\\n            );\\n            let unpack = get_trait_impl_method(\\n                typ,\\n                quote { crate::protocol_types::traits::Packable<_> },\\n                quote { unpack },\\n            );\\n\\n            let compute_note_hash = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_note_hash },\\n            );\\n\\n            let compute_nullifier_unconstrained = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_nullifier_unconstrained },\\n            );\\n\\n            let if_or_else_if = if i == 0 {\\n                quote { if }\\n            } else {\\n                quote { else if }\\n            };\\n\\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\\n                quote {\\n                    $if_or_else_if note_type_id == $get_note_type_id() {\\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\\n                        // length, since we\'re about to interpret it\'s raw storage as a fixed-size array by calling the\\n                        // unpack function on it.\\n                        let expected_len = $packed_note_length;\\n                        let actual_len = packed_note.len();\\n                        assert(\\n                            actual_len == expected_len,\\n                            f\\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\\"\\n                        );\\n\\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n\\n                        let note_hash = $compute_note_hash(note, storage_slot);\\n    \\n                        // The note discovery process finds settled notes, that is, notes that were created in prior\\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n                            aztec::note::retrieved_note::RetrievedNote{ \\n                                note, \\n                                contract_address, \\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \\n                            }, \\n                            storage_slot,\\n                        );\\n\\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\\n\\n                        Option::some(\\n                            aztec::discovery::NoteHashAndNullifier {\\n                                note_hash, inner_nullifier\\n                            }\\n                        )\\n                    }\\n                },\\n            );\\n        }\\n\\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\\n\\n        quote {\\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\\n            /// tree with `nonce`.\\n            ///\\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\\n            /// and `attempt_note_discovery`.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                storage_slot: Field,\\n                note_type_id: Field,\\n                contract_address: aztec::protocol_types::address::AztecAddress,\\n                nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                $if_note_type_id_match_statements\\n                else {\\n                    Option::none()\\n                }\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            /// This contract does not use private notes, so this function should never be called as it will\\n            /// unconditionally fail.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                _storage_slot: Field,\\n                _note_type_id: Field,\\n                _contract_address: aztec::protocol_types::address::AztecAddress,\\n                _nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_process_log() -> Quoted {\\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\\n    // and perform note discovery of either private notes or partial notes.\\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\\n    // that function.\\n\\n    // We\'ll produce the entire body of the function in one go and then insert it into the function.\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        quote {\\n            unconstrained fn process_log(\\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                tx_hash: Field,\\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                first_nullifier_in_tx: Field,\\n                recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n                // unconstrained execution context since it will not be available otherwise.\\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n                // TODO(#10727): allow other contracts to process logs and deliver notes\\n                let contract_address = context.this_address();\\n\\n                aztec::discovery::private_logs::do_process_log(\\n                    contract_address,\\n                    log_ciphertext,\\n                    tx_hash,\\n                    unique_note_hashes_in_tx,\\n                    first_nullifier_in_tx,\\n                    recipient,\\n                    _compute_note_hash_and_nullifier,\\n                );\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            unconstrained fn process_log(\\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                _tx_hash: Field,\\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                _first_nullifier_in_tx: Field,\\n                _recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_note_exports() -> Quoted {\\n    let notes = NOTES.values();\\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it\'s only used when\\n    // generating partial note helper functions.\\n    notes\\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\\n            generate_note_export(s, note_type_id, fields)\\n        })\\n        .join(quote {})\\n}\\n\\ncomptime fn generate_sync_notes() -> Quoted {\\n    let note_discovery_call = create_note_discovery_call();\\n    quote {\\n        unconstrained fn sync_notes() {\\n            // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n            // unconstrained execution context since it will not be available otherwise.\\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n            $note_discovery_call\\n        }\\n    }\\n}\\n"},"125":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr","source":"use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\\n\\nuse super::utils::AsStrQuote;\\nuse super::utils::get_storage_size;\\nuse super::utils::is_note;\\n\\n/// Stores a map from a module to the name of the struct that describes its storage layout.\\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\\n    UHashMap::default();\\n\\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\\n/// should have this macro (or `storage_no_init`) applied to it.\\n/// The contract\'s storage is accessed via the `storage` variable, which will will automatically be made available in\\n/// all functions as an instance of the struct this macro was applied to.\\npub comptime fn storage(s: TypeDefinition) -> Quoted {\\n    // This macro performs three things:\\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\\n    //    functions will have the storage variable injected and initialized via the `init` function.\\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\\n    //    macro.\\n    let mut slot: u32 = 1;\\n    let mut storage_vars_constructors = &[];\\n    let mut storage_layout_fields = &[];\\n    let mut storage_layout_constructors = &[];\\n\\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\\n    //let mut new_storage_fields = &[];\\n    //let context_generic = s.add_generic(\\"Context\\");\\n    for field in s.fields_as_written() {\\n        // FIXME: This doesn\'t handle field types with generics\\n        let (name, typ) = field;\\n        let (storage_field_constructor, storage_size) =\\n            generate_storage_field_constructor(typ, quote { $slot }, false);\\n        storage_vars_constructors =\\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\\n        // a contract.\\n        storage_layout_fields =\\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\\n        storage_layout_constructors = storage_layout_constructors.push_back(\\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\\n        );\\n        //let with_context_generic = add_context_generic(typ, context_generic);\\n        //println(with_context_generic);\\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\\n        slot += storage_size;\\n    }\\n\\n    //s.set_fields(new_storage_fields);\\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\\n    let storage_impl = quote {\\n        impl<Context> Storage<Context> {\\n            fn init(context: Context) -> Self {\\n                Self {\\n                    $storage_vars_constructors\\n                }\\n            }\\n        }\\n    };\\n\\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\\n\\n    let module = s.module();\\n    let module_name = module.name();\\n    let storage_layout_name = f\\"STORAGE_LAYOUT_{module_name}\\".quoted_contents();\\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\\n\\n    quote {\\n        $storage_impl\\n\\n        pub struct StorageLayoutFields {\\n            $storage_layout_fields\\n        }\\n\\n        pub struct StorageLayout<let N: u32> {\\n            pub contract_name: str<N>,\\n            pub fields: StorageLayoutFields\\n        }\\n\\n        #[abi(storage)]\\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\\n            contract_name: $module_name_str,\\n            fields: StorageLayoutFields { $storage_layout_constructors }\\n        };\\n    }\\n}\\n\\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\\n/// allocation. Similarly, no `StorageLayout` struct will be created.\\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\\npub comptime fn storage_no_init(_s: TypeDefinition) {\\n    // All `storage` does is provide the `init` implementation, so we don\'t need to do anything here. Applying this\\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\\n    // the `storage` variable.\\n}\\n\\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\\n/// i.e. how many contiguous storage slots the variable requires.\\ncomptime fn generate_storage_field_constructor(\\n    typ: Type,\\n    slot: Quoted,\\n    parent_is_map: bool,\\n) -> (Quoted, u32) {\\n    assert(\\n        typ.as_data_type().is_some(),\\n        \\"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\\",\\n    );\\n    let (container_struct, generics) = typ.as_data_type().unwrap();\\n    let struct_name = container_struct.name();\\n\\n    if is_storage_map(typ) {\\n        // Map state variables recursively initialize their contents - this includes nested maps.\\n        let (value_constructor, _) =\\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\\n    } else {\\n        let storage_size = if parent_is_map {\\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\\n            // in slots very far away from one another.\\n            1\\n        } else {\\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\\n            let stored_struct = container_struct_generics[0];\\n\\n            if is_note(stored_struct) {\\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\\n                // identifier.\\n                1\\n            } else {\\n                get_storage_size(typ)\\n            }\\n        };\\n\\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\\n        (quote { $struct_name::new(context, $slot)}, storage_size)\\n    }\\n}\\n\\n/// Returns true if `typ` is `state_vars::map::Map`.\\ncomptime fn is_storage_map(typ: Type) -> bool {\\n    if typ.as_data_type().is_some() {\\n        let (def, generics) = typ.as_data_type().unwrap();\\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\\n            let maybe_key = generics[0];\\n            let maybe_value = generics[1];\\n            let maybe_context = generics[2];\\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\\n        } else {\\n            quote {()}.as_type()\\n        };\\n        typ == maybe_map\\n    } else {\\n        false\\n    }\\n}\\n\\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\\n    let (def, mut generics) = typ.as_data_type().expect(\\n        f\\"Storage containers must be generic structs of the form `Container<..., Context>`\\",\\n    );\\n    let name = def.name();\\n\\n    if is_storage_map(typ) {\\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\\n        generics[generics.len() - 1] = context_generic;\\n    } else {\\n        generics[generics.len() - 1] = context_generic;\\n    }\\n\\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\\n    quote { $name<$generics> }.as_type()\\n}\\n"},"143":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> [Field; 2] {}\\n\\npub unconstrained fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> (u32, Field) {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n    );\\n\\n    let mut reader = Reader::new(fields);\\n    let end_side_effect_counter = reader.read_u32();\\n    let returns_hash = reader.read();\\n\\n    (end_side_effect_counter, returns_hash)\\n}\\n"},"144":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\\n/// data was already stored at this slot, it is overwritten.\\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\\nwhere\\n    T: Serialize<N>,\\n{\\n    let serialized = value.serialize();\\n    store_oracle(contract_address, slot, serialized);\\n}\\n\\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\\n/// nothing was stored at the given slot.\\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\\nwhere\\n    T: Deserialize<N>,\\n{\\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\\n}\\n\\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\\n    delete_oracle(contract_address, slot);\\n}\\n\\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\\npub unconstrained fn copy(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {\\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\\n}\\n\\n#[oracle(storeCapsule)]\\nunconstrained fn store_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    values: [Field; N],\\n) {}\\n\\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\\n/// have.\\n///\\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\\n#[oracle(loadCapsule)]\\nunconstrained fn load_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    array_len: u32,\\n) -> Option<[Field; N]> {}\\n\\n#[oracle(deleteCapsule)]\\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\\n\\n#[oracle(copyCapsule)]\\nunconstrained fn copy_oracle(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {}\\n\\nmod test {\\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\\n    // oracles are hooked up correctly.\\n\\n    use crate::{\\n        oracle::capsules::{copy, delete, load, store},\\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\\n    };\\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        let env = TestEnvironment::new();\\n        env.contract_address()\\n    }\\n\\n    global SLOT: Field = 1;\\n\\n    #[test]\\n    unconstrained fn stores_and_loads() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\\n    }\\n\\n    #[test]\\n    unconstrained fn store_overwrites() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        let new_value = MockStruct::new(7, 8);\\n        store(contract_address, SLOT, new_value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\\n    }\\n\\n    #[test]\\n    unconstrained fn loads_empty_slot() {\\n        let contract_address = setup();\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_stored_value() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n        delete(contract_address, SLOT);\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_empty_slot() {\\n        let contract_address = setup();\\n\\n        delete(contract_address, SLOT);\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_non_overlapping_values() {\\n        let contract_address = setup();\\n\\n        let src = 5;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 10;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 1;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 2;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 2;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 1;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\\n    }\\n\\n    #[test(should_fail_with = \\"copy empty slot\\")]\\n    unconstrained fn cannot_copy_empty_values() {\\n        let contract_address = setup();\\n\\n        copy(contract_address, SLOT, SLOT, 1);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_store_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let value = MockStruct::new(5, 6);\\n        store(other_contract_address, SLOT, value);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_load_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_delete_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        delete(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_copy_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        copy(other_contract_address, SLOT, SLOT, 0);\\n    }\\n}\\n"},"145":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"146":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"147":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"157":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr","source":"use crate::discovery::MAX_NOTE_PACKED_LEN;\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\\n};\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\\n/// available for later querying via the `get_notes` oracle.\\npub unconstrained fn sync_notes() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n\\n/// Informs PXE of a note\'s existence so that it can later be retrieved by the `getNotes` oracle. The note will be\\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\\n///\\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\\n///\\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\\n/// other accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized.\\n///\\n/// Returns true if the note was successfully delivered and added to PXE\'s database.\\npub unconstrained fn deliver_note(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {\\n    deliver_note_oracle(\\n        contract_address,\\n        storage_slot,\\n        nonce,\\n        packed_note,\\n        note_hash,\\n        nullifier,\\n        tx_hash,\\n        recipient,\\n    )\\n}\\n\\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\\n/// is the data required in order to discover notes that are being delivered in a log.\\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\\n// log.\\npub struct LogWithTxData {\\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\\n    pub tx_hash: Field,\\n    /// The array of new note hashes created by `tx_hash`\\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    /// The first nullifier created by `tx_hash`\\n    pub first_nullifier_in_tx: Field,\\n}\\n\\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\\n/// the tag is the first field in the log\'s content. Returns `Option::none` if no such log exists. Throws if more than\\n/// one log with that tag exists.\\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\\n// TODO(#11627): handle multiple logs with the same tag.\\n// TODO(#10273): improve contract siloing of logs, don\'t introduce an extra field.\\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\\n    get_log_by_tag_oracle(tag)\\n}\\n\\n#[oracle(deliverNote)]\\nunconstrained fn deliver_note_oracle(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {}\\n\\n#[oracle(getLogByTag)]\\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\\n"},"158":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{\\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n    traits::{Deserialize, FromField, Packable},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\\n    // call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\\n    // call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\\n) -> [Option<RetrievedNote<Note>>; S]\\nwhere\\n    Note: NoteType + Packable<N>,\\n{\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let maybe_nonce = fields[read_offset];\\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\\n            let packed_note = array::subarray(fields, read_offset + 2);\\n\\n            let note = Note::unpack(packed_note);\\n            let retrieved_note = RetrievedNote {\\n                note,\\n                contract_address,\\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\\n            };\\n\\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n"},"161":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\\n\\n#[oracle(storageRead)]\\nunconstrained fn storage_read_oracle<let N: u32>(\\n    address: Field,\\n    storage_slot: Field,\\n    block_number: Field,\\n    length: Field,\\n) -> [Field; N] {}\\n\\npub unconstrained fn raw_storage_read<let N: u32>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32,\\n) -> [Field; N] {\\n    storage_read_oracle(\\n        address.to_field(),\\n        storage_slot,\\n        block_number as Field,\\n        N as Field,\\n    )\\n}\\n\\npub unconstrained fn storage_read<T, let N: u32>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32,\\n) -> T\\nwhere\\n    T: Packable<N>,\\n{\\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\\n}\\n\\nmod tests {\\n    use crate::oracle::storage::{raw_storage_read, storage_read};\\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\\n\\n    use crate::test::mocks::mock_struct::MockStruct;\\n    use std::test::OracleMock;\\n\\n    global address: AztecAddress = AztecAddress::from_field(29);\\n    global slot: Field = 7;\\n    global block_number: u32 = 17;\\n\\n    #[test]\\n    unconstrained fn test_raw_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.pack());\\n\\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\\n        assert_eq(read[0], 13);\\n        assert_eq(read[1], 42);\\n    }\\n\\n    #[test]\\n    unconstrained fn test_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.pack());\\n\\n        let read: MockStruct = storage_read(address, slot, block_number);\\n        assert_eq(read.a, 13);\\n        assert_eq(read.b, 42);\\n    }\\n}\\n"},"163":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\\n\\n// docs:start:map\\npub struct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V\\n    where\\n        K: ToField,\\n    {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"171":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\\nuse crate::state_vars::storage::Storage;\\nuse dep::protocol_types::traits::Packable;\\n\\n// docs:start:public_mutable_struct\\npub struct PublicMutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_mutable_struct\\n\\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<T, Context> PublicMutable<T, Context> {\\n    // docs:start:public_mutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicMutable { context, storage_slot }\\n    }\\n    // docs:end:public_mutable_struct_new\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    // docs:start:public_mutable_struct_read\\n    pub fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_mutable_struct_read\\n\\n    // docs:start:public_mutable_struct_write\\n    pub fn write(self, value: T) {\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_mutable_struct_write\\n}\\n\\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\\nwhere\\n    T: Packable<T_PACKED_LEN>,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n"},"185":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\\n/// large enough to fit all of the elements of both the first and second vectors.\\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\\n    a: BoundedVec<T, A_LEN>,\\n    b: BoundedVec<T, B_LEN>,\\n) -> BoundedVec<T, DST_LEN> {\\n    let mut dst = BoundedVec::new();\\n\\n    dst.extend_from_bounded_vec(a);\\n    dst.extend_from_bounded_vec(b);\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::append;\\n\\n    #[test]\\n    unconstrained fn append_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::new();\\n        let b: BoundedVec<_, 14> = BoundedVec::new();\\n\\n        let result: BoundedVec<Field, 5> = append(a, b);\\n\\n        assert_eq(result.len(), 0);\\n        assert_eq(result.storage(), std::mem::zeroed());\\n    }\\n\\n    #[test]\\n    unconstrained fn append_non_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let result: BoundedVec<Field, 8> = append(a, b);\\n\\n        assert_eq(result.len(), 6);\\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\\n    }\\n\\n    #[test(should_fail_with = \\"out of bounds\\")]\\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let _: BoundedVec<Field, 5> = append(a, b);\\n    }\\n}\\n"},"187":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr","source":"pub mod append;\\npub mod collapse;\\npub mod subarray;\\npub mod subbvec;\\n\\npub use append::append;\\npub use collapse::collapse;\\npub use subarray::subarray;\\npub use subbvec::subbvec;\\n\\n// This will eventually be replaced by `BoundedVec::for_each`, once that\'s implemented.\\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\\n    vec: BoundedVec<T, MaxLen>,\\n    f: fn[Env](T, u32) -> (),\\n) {\\n    for i in 0..vec.len() {\\n        f(vec.get_unchecked(i), i);\\n    }\\n}\\n"},"188":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"189":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\\n\\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\\n/// zeroed elements past `len()`).\\n///\\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n///\\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can\'t return just 1 element since 3 remain\\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can\'t return 10 elements since only 7 remain\\n/// ```\\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\\n    offset: u32,\\n) -> BoundedVec<T, DST_MAX_LEN> {\\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\\n    // because we\'re constructing the new storage array as a subarray of the original one (which should have zeroed\\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\\n    // their original length.\\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\\n}\\n\\nmod test {\\n    use super::subbvec;\\n\\n    #[test]\\n    unconstrained fn subbvec_empty() {\\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_complete() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n\\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_partial() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_into_empty() {\\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_offset_past_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_insufficient_dst_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // We\'re not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\\n        // for the capacity to reduce, but not the length (other than by len - offset).\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // subbvec does not supprt capacity increases\\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // This effectively requests a capacity increase, since there\'d be just one element plus the 5 empty slots,\\n        // which is less than 7.\\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\\n    }\\n}\\n"},"261":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\\n        MAX_PROTOCOL_CONTRACTS,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_class_id(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_protocol_contract(self) -> bool {\\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"278":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"279":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        contract_class_log::ContractClassLog,\\n        function_selector::FunctionSelector,\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, ToField},\\n    utils::{\\n        arrays::{array_concat, unsafe_padded_array_length},\\n        field::{field_from_bytes, field_from_bytes_32_trunc},\\n    },\\n};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_field(\\n    contract_address: AztecAddress,\\n    first_field: Field,\\n) -> Field {\\n    poseidon2_hash([contract_address.to_field(), first_field])\\n}\\n\\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\\n    if contract_class_log.contract_address.is_zero() {\\n        contract_class_log\\n    } else {\\n        let mut log = contract_class_log;\\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\\n            contract_class_log.contract_address,\\n            log.log.fields[0],\\n        );\\n        log\\n    }\\n}\\n\\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\\n    let array = contract_class_log.log.fields;\\n    // Safety: The below length is constrained in the base rollup.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    if length == 0 {\\n        0\\n    } else {\\n        poseidon2_hash(array)\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a u128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"293":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use super::traits::{Deserialize, Packable, Serialize};\\n\\n/// Returns the typed expression of a trait method implementation.\\n///\\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\\n/// warnings that the trait implementation is not in scope).\\n///\\n/// # Note\\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\\ncomptime fn get_trait_impl_method(\\n    typ: Type,\\n    target_trait: Quoted,\\n    target_method: Quoted,\\n) -> TypedExpr {\\n    let trait_constraint = target_trait.as_trait_constraint();\\n    typ\\n        .get_trait_impl(trait_constraint)\\n        .expect(f\\"Could not find impl for {target_trait} for type {typ}\\")\\n        .methods()\\n        .filter(|m| m.name() == target_method)[0]\\n        .as_typed_expr()\\n}\\n\\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\\n///\\n/// # Parameters\\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\\"values\\"`).\\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\\n/// and `Serialize` trait for more information about the difference between packing and serialization).\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\\n///\\n/// # Nested Struct Example\\n/// Given the following setup:\\n/// ```\\n/// struct UintNote {\\n///     value: u128,\\n///     owner: AztecAddress,\\n///     randomness: Field,\\n/// }\\n///\\n/// struct AztecAddress {\\n///     inner: Field,\\n/// }\\n/// ```\\n///\\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\\n/// ```\\n/// UintNote {\\n///     value: fields[0] as u128,\\n///     owner: AztecAddress {\\n///         inner: fields[1],\\n///     },\\n///     randomness: fields[2],\\n/// }\\n/// ```\\n/// # Nested Struct Example with Unpacking\\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\\n///   the result we get is:\\n/// ```\\n/// UintNote {\\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\\n/// }\\n/// ```\\n///\\n/// # Panics\\n/// - If the deserialization logic encounters a type it does not support.\\n/// - If an incorrect number of fields are consumed when deserializing a string.\\npub comptime fn generate_deserialize_from_fields(\\n    name: Quoted,\\n    typ: Type,\\n    field_array_name: Quoted,\\n    num_already_consumed: u32,\\n    should_unpack: bool,\\n) -> (Quoted, u32) {\\n    let mut result = quote {};\\n    // Counter for the number of fields consumed\\n    let mut consumed_counter: u32 = 0;\\n\\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n    if (should_unpack & typ.implements(packable_constraint)) {\\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\\n        let mut packed_fields_quotes = &[];\\n        for i in 0..packed_len {\\n            let index_in_field_array = i + num_already_consumed;\\n            packed_fields_quotes =\\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\\n        }\\n        let packed_fields = packed_fields_quotes.join(quote {,});\\n\\n        // Now we call unpack on the type\\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\\n        result = quote { $unpack_method([ $packed_fields ]) };\\n\\n        consumed_counter = packed_len;\\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\\n        // The field is a primitive so we just reference it in the field array\\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\\n        consumed_counter = 1;\\n    } else if typ.as_data_type().is_some() {\\n        // The field is a struct so we iterate over each struct field and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (nested_def, generics) = typ.as_data_type().unwrap();\\n        let nested_name = nested_def.name();\\n        let mut deserialized_fields_list = &[];\\n\\n        // Iterate over each field in the struct\\n        for field in nested_def.fields(generics) {\\n            let (field_name, field_type) = field;\\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                field_name,\\n                field_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\\n            deserialized_fields_list =\\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\\n        }\\n\\n        // We can construct the struct from the deserialized fields\\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\\n        result = quote {\\n                $nested_name {\\n                    $deserialized_fields\\n                }\\n            };\\n    } else if typ.as_array().is_some() {\\n        // The field is an array so we iterate over each element and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (element_type, array_len) = typ.as_array().unwrap();\\n        let array_len = array_len.as_constant().unwrap();\\n        let mut array_fields_list = &[];\\n\\n        // Iterate over each element in the array\\n        for _ in 0..array_len {\\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                element_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            array_fields_list = array_fields_list.push_back(deserialized_field);\\n        }\\n\\n        // We can construct the array from the deserialized fields\\n        let array_fields = array_fields_list.join(quote {,});\\n        result = quote { [ $array_fields ] };\\n    } else if typ.as_str().is_some() {\\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\\n        // to `generate_deserialize_from_fields`.\\n        let length_type = typ.as_str().unwrap();\\n        let str_len = length_type.as_constant().unwrap();\\n        let mut byte_list = &[];\\n\\n        // Iterate over each character in the string\\n        for _ in 0..str_len {\\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                quote {u8}.as_type(),\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n\\n            // We should consume just one field in the recursion so we sanity check that\\n            assert_eq(\\n                num_consumed_in_recursion,\\n                1,\\n                \\"Incorrect number of fields consumed in string deserialization\\",\\n            );\\n\\n            // We increment the consumed counter by 1 as we have consumed one field\\n            consumed_counter += 1;\\n\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `fields[6] as u8`\\n            byte_list = byte_list.push_back(deserialized_field);\\n        }\\n\\n        // We construct the string from the deserialized fields\\n        let bytes = byte_list.join(quote {,});\\n        result = quote { [ $bytes ].as_str_unchecked() };\\n    } else {\\n        panic(\\n            f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n        )\\n    }\\n\\n    (result, consumed_counter)\\n}\\n\\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\\n/// if it does.\\n///\\n/// # Parameters\\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\\n/// - `should_pack`: A boolean indicating whether the type should be packed.\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - A flattened array of `Quoted` field references representing the serialized fields.\\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\\n///\\n/// # Examples\\n///\\n/// ## Struct\\n/// Given the following struct:\\n/// ```rust\\n/// struct MockStruct {\\n///     a: Field,\\n///     b: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing the struct:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\\n/// // Returns:\\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\\n/// ```\\n///\\n/// ## Nested Struct\\n/// For a more complex struct:\\n/// ```rust\\n/// struct NestedStruct {\\n///     m1: MockStruct,\\n///     m2: MockStruct,\\n/// }\\n/// ```\\n///\\n/// Serialization output:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\\n/// // Returns:\\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\\n/// ```\\n///\\n/// ## Array\\n/// For an array type:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\\n/// // Returns:\\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\\n/// ```\\n///\\n/// ## String\\n/// For a string field, where each character is serialized as a `Field`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\\n/// // Returns:\\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\\n/// ```\\n///\\n/// ## Nested Struct with Omitted Field and packing enabled\\n/// - u128 has a `Packable` implementation hence it will be packed.\\n///\\n/// For a more complex struct:\\n/// ```rust\\n/// struct MyStruct {\\n///     value: u128,\\n///     value2: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing while omitting `value2`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\\n/// // Returns:\\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\\n/// ```\\n///\\n/// # Panics\\n/// - If the type is unsupported for serialization.\\n/// - If the provided `typ` contains invalid constants or incompatible structures.\\npub comptime fn generate_serialize_to_fields(\\n    name: Quoted,\\n    typ: Type,\\n    omit: [Quoted],\\n    should_pack: bool,\\n) -> ([Quoted], [Quoted]) {\\n    let mut fields = &[];\\n    let mut aux_vars = &[];\\n\\n    // Proceed if none of the omit rules omits this name\\n    if !omit.any(|to_omit| to_omit == name) {\\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n        let packable_constraint =\\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n        if (should_pack & typ.implements(packable_constraint)) {\\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \\"self.value\\" -> \\"self_value\\").\\n            let name_at_one_token = collapse_to_one_token(name);\\n            let packed_struct_name = f\\"{name_at_one_token}_aux_var\\".quoted_contents();\\n\\n            // We add the individual fields to the fields array\\n            let pack_method = get_trait_impl_method(\\n                typ,\\n                quote { crate::traits::Packable<$packed_len> },\\n                quote { pack },\\n            );\\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\\n            for i in 0..packed_len {\\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\\n            }\\n\\n            // We add the new auxiliary variable to the aux_vars array\\n            aux_vars = aux_vars.push_back(packed_struct);\\n        } else if typ.is_field() {\\n            // For field we just add the value to fields\\n            fields = fields.push_back(name);\\n        } else if typ.as_integer().is_some() | typ.is_bool() {\\n            // For integer and bool we just cast to Field and add the value to fields\\n            fields = fields.push_back(quote { $name as Field });\\n        } else if typ.as_data_type().is_some() {\\n            // For struct we pref\\n            let nested_struct = typ.as_data_type().unwrap();\\n            let params = nested_struct.0.fields(nested_struct.1);\\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\\n                let maybe_prefixed_name = if name == quote {} {\\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\\n                    // argument) --> then we don\'t prefix the name with anything.\\n                    param_name\\n                } else {\\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\\n                    // can typically be `self` when implementing a method on a struct.\\n                    quote { $name.$param_name }\\n                };\\n                generate_serialize_to_fields(\\n                    quote {$maybe_prefixed_name},\\n                    param_type,\\n                    omit,\\n                    should_pack,\\n                )\\n            });\\n            let struct_flattened_fields = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\\n            );\\n            let struct_flattened_aux_vars = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\\n            );\\n            fields = fields.append(struct_flattened_fields);\\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\\n        } else if typ.as_array().is_some() {\\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\\n            let (element_type, array_len) = typ.as_array().unwrap();\\n            let array_len = array_len.as_constant().unwrap();\\n            for i in 0..array_len {\\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\\n                    quote { $name[$i] },\\n                    element_type,\\n                    omit,\\n                    should_pack,\\n                );\\n                fields = fields.append(element_fields);\\n                aux_vars = aux_vars.append(element_aux_vars);\\n            }\\n        } else if typ.as_str().is_some() {\\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\\n            // then we add each byte to fields as a Field\\n            let length_type = typ.as_str().unwrap();\\n            let str_len = length_type.as_constant().unwrap();\\n            let as_member = name.as_expr().unwrap().as_member_access();\\n            let var_name = if as_member.is_some() {\\n                as_member.unwrap().1\\n            } else {\\n                name\\n            };\\n            let as_bytes_name = f\\"{var_name}_as_bytes\\".quoted_contents();\\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\\n            for i in 0..str_len {\\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\\n            }\\n            aux_vars = aux_vars.push_back(as_bytes);\\n        } else {\\n            panic(\\n                f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n            )\\n        }\\n    }\\n    (fields, aux_vars)\\n}\\n\\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\\n/// E.g. \\"self.values[0]\\" -> \\"self_values_0_\\"\\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\\n    let tokens = q.tokens();\\n\\n    let mut single_token = quote {};\\n    for token in tokens {\\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\\n            quote {_}\\n        } else {\\n            token\\n        };\\n        single_token = f\\"{single_token}{new_token}\\".quoted_contents();\\n    }\\n    single_token\\n}\\n\\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let field_serializations = fields.join(quote {,});\\n    let serialized_len = fields.len();\\n    quote {\\n        impl Serialize<$serialized_len> for $typ {\\n            fn serialize(self) -> [Field; $serialized_len] {\\n                $aux_vars_for_serialization\\n                [ $field_serializations ]\\n            }\\n        }\\n    }\\n}\\n\\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let serialized_len = fields.len();\\n    let (deserialized, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\\n    quote {\\n        impl Deserialize<$serialized_len> for $typ {\\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\\n                $deserialized\\n            }\\n        }\\n    }\\n}\\n\\n/// Generates `Packable` implementation for a given struct and returns the packed length.\\n///\\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\\n    let packing_enabled = true;\\n\\n    let typ = s.as_type();\\n    let (fields, aux_vars) =\\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let (unpacked, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\\n\\n    let field_packings = fields.join(quote {,});\\n    let packed_len = fields.len();\\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\\n    (\\n        quote {\\n        impl $packable_trait for $typ {\\n            fn pack(self) -> [Field; $packed_len] {\\n                $aux_vars_for_packing\\n                [ $field_packings ]\\n            }\\n\\n            fn unpack(packed: [Field; $packed_len]) -> Self {\\n                $unpacked\\n            }\\n        }\\n    },\\n        packed_len,\\n    )\\n}\\n\\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\\n    packable_impl\\n}\\n\\n#[derive(Packable, Serialize, Deserialize, Eq)]\\npub struct Smol {\\n    a: Field,\\n    b: Field,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct HasArray {\\n    a: [Field; 2],\\n    b: bool,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct Fancier {\\n    a: Smol,\\n    b: [Field; 2],\\n    c: [u8; 3],\\n    d: str<16>,\\n}\\n\\nfn main() {\\n    assert(false);\\n}\\n\\n#[test]\\nfn smol_test() {\\n    let smol = Smol { a: 1, b: 2 };\\n    let serialized = smol.serialize();\\n    assert(serialized == [1, 2], serialized);\\n    let deserialized = Smol::deserialize(serialized);\\n    assert(deserialized == smol);\\n\\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\\n    let packed = smol.pack();\\n    assert_eq(packed, serialized, \\"Packed does not match serialized\\");\\n}\\n\\n#[test]\\nfn has_array_test() {\\n    let has_array = HasArray { a: [1, 2], b: true };\\n    let serialized = has_array.serialize();\\n    assert(serialized == [1, 2, 1], serialized);\\n    let deserialized = HasArray::deserialize(serialized);\\n    assert(deserialized == has_array);\\n}\\n\\n#[test]\\nfn fancier_test() {\\n    let fancier =\\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \\"metaprogramming!\\" };\\n    let serialized = fancier.serialize();\\n    assert(\\n        serialized\\n            == [\\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\\n            ],\\n        serialized,\\n    );\\n    let deserialized = Fancier::deserialize(serialized);\\n    assert(deserialized == fancier);\\n}\\n"},"296":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"316":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\\nwhere\\n    K: ToField,\\n{\\n    poseidon2_hash([storage_slot, key.to_field()])\\n}\\n\\nmod test {\\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\\n\\n    #[test]\\n    fn test_derive_storage_slot_in_map_matches_typescript() {\\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\\n        let key = AztecAddress::from_field(\\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\\n        );\\n\\n        let slot = derive_storage_slot_in_map(map_slot, key);\\n\\n        // The following value was generated by `map_slot.test.ts`\\n        let slot_from_typescript =\\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\\n\\n        assert_eq(slot, slot_from_typescript);\\n    }\\n}\\n"},"334":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\\n\\nglobal BOOL_PACKED_LEN: u32 = 1;\\nglobal U8_PACKED_LEN: u32 = 1;\\nglobal U16_PACKED_LEN: u32 = 1;\\nglobal U32_PACKED_LEN: u32 = 1;\\nglobal U64_PACKED_LEN: u32 = 1;\\nglobal U128_PACKED_LEN: u32 = 1;\\nglobal FIELD_PACKED_LEN: u32 = 1;\\nglobal I8_PACKED_LEN: u32 = 1;\\nglobal I16_PACKED_LEN: u32 = 1;\\nglobal I32_PACKED_LEN: u32 = 1;\\nglobal I64_PACKED_LEN: u32 = 1;\\n\\nimpl Packable<BOOL_PACKED_LEN> for bool {\\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Packable<U8_PACKED_LEN> for u8 {\\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Packable<U16_PACKED_LEN> for u16 {\\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Packable<U32_PACKED_LEN> for u32 {\\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Packable<U64_PACKED_LEN> for u64 {\\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Packable<U128_PACKED_LEN> for u128 {\\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Packable<FIELD_PACKED_LEN> for Field {\\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\\n        [self]\\n    }\\n\\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Packable<I8_PACKED_LEN> for i8 {\\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Packable<I16_PACKED_LEN> for i16 {\\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Packable<I32_PACKED_LEN> for i32 {\\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Packable<I64_PACKED_LEN> for i64 {\\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\\nwhere\\n    T: Packable<M>,\\n{\\n    fn pack(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].pack();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n\\n    fn unpack(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_packing() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i8_packing() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i16_packing() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i32_packing() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i64_packing() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::unpack(a.pack()));\\n}\\n"},"335":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 1;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"351":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\\n// is not found, the function returns N as the index.\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays where validate_array(array) returns true,\\n// which ensures that:\\n// 1. All elements before the first empty element are non-empty\\n// 2. All elements after and including the first empty element are empty\\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // We get the length by checking the index of the first empty element.\\n\\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\\n    // of the element and non-emptiness of the previous element is checked below.\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\\n/// if this is not the case then elements from the end of `array2` will be dropped.\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: we constrain this array below\\n    let result = unsafe { array_merge_helper(array1, array2) };\\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\\n    let array1_len = array_length(array1);\\n    let mut add_from_left = true;\\n    for i in 0..N {\\n        add_from_left &= i != array1_len;\\n        if add_from_left {\\n            assert_eq(result[i], array1[i]);\\n        } else {\\n            assert_eq(result[i], array2[i - array1_len]);\\n        }\\n    }\\n    result\\n}\\n\\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n// Helper function to find the index of the last element in an array, allowing empty elements.\\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut index = N;\\n    for i in 0..N {\\n        let j = N - i - 1;\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & !is_empty(array[j]) {\\n            index = j;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which returns the length of an array right padded by empty elements\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\n// See smoke_validate_array_trailing for examples.\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let index = find_last_value_index(array);\\n    if index == N {\\n        0\\n    } else {\\n        index + 1\\n    }\\n}\\n\\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: this value is constrained in the below loop.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    // Check the elt just before length is non-zero:\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]), \\"invalid right padded array\\");\\n    }\\n    // Check all beyond length are zero:\\n    let mut check_zero = false;\\n    for i in 0..N {\\n        check_zero |= i == length;\\n        if check_zero {\\n            assert(is_empty(array[i]), \\"invalid right padded array\\");\\n        }\\n    }\\n    length\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test]\\nfn smoke_validate_array_trailing() {\\n    let valid_array: [Field; 0] = [];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(padded_array_length(valid_array) == 1);\\n\\n    let valid_array = [1, 0, 3];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 0, 3, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [0, 0, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nunconstrained fn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nunconstrained fn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concatenated = array_concat(array0, array1);\\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"354":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"}}'),r={transpiled:!0,noir_version:e,name:n,functions:t,outputs:s,file_map:a};export{r as default,a as file_map,t as functions,n as name,e as noir_version,s as outputs,i as transpiled};
