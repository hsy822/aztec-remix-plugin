const i=!0,e="1.0.0-beta.3+0000000000000000000000000000000000000000",n="ContractInstanceDeployer",t=JSON.parse('[{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"10019982601749771606":{"error_kind":"string","string":"msg.sender is not deployed"},"11343565365413149907":{"error_kind":"string","string":"Function get_update_delay can only be called statically"},"15573886522241766899":{"error_kind":"string","string":"New update delay is too low"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2830029349304997821":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":27},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6504213605561840204":{"error_kind":"string","string":"New contract class is not registered"}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"set_update_delay","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"10019982601749771606":{"error_kind":"string","string":"msg.sender is not deployed"},"15573886522241766899":{"error_kind":"string","string":"New update delay is too low"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"new_update_delay","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_update_delay"]},{"name":"get_update_delay","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{"11343565365413149907":{"error_kind":"string","string":"Function get_update_delay can only be called statically"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_update_delay"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":58},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"}},"parameters":[],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["sync_notes"]},{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"_log_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"_unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/+Wc6XLbNhDHKZu0TcmyZPmK3Svp3bRpKYnU0dNt0/u+lM+KYz8HHyPta7Rf2qer/jFXWsHojDteTPxPMMOhpYV2f1wuARBYuBadl8nsqFV/x9V5vTrj+060XKTucXXOrla6hrqyUIw1AsYVAsZVAsaYgDEhYFwjYFwnYNwgYEwJGOsEjA0Cxk0CxiYB4xYBY4uAsU3AuB2AMQRnh4Rzx5BTj+1D8e5G1z9G9wgY9wkYDwgYbxAwHhIwHhEwPkPA+CwB43MEjM8TML5AwHiTgPEWAeOLBIwvETC+TMD4CgHjqwSMrxEwvk7A+AYB420CxjcJGN8iYLxDwPg2AeM7BIwZAWOXgLFHwNgnYMwJGAsCxgEB45CAcUTAOCZgfJeA8T0CxvcJGD8gYPyQgPEjAsZjAsaPCRg/IWD8lIDxLgHjZwSMnxMwfkHA+CUB41cEjF8TMH5DwPgtAeN3BIzfEzD+QMD4IwHjTwSMPxMw/hKAMQTnryScv5FwTgJxRvcc6JXZgY1b2BiFjUfY2IONM9iYgo0f2FiBjQvYGIDEeyS2I3G8PTuQ+IykYiTsIgkWSaZI4kSSJJIQkeSHJDokqSEJDElWSGJCktDN2XFrdiCJBEkaSIJAkgEW8bFIjkVoLPJiERWLlFgExCIbFrGwSISrwiIHFhEwSY9JcEwyYxIXk6SYhMQkHybRMEmFSSBMsmASQyYJ8JKLl0i8pOElCC8ZGMRjkIxBKAZ5GERhkIJBADpZdGLoJNAIo5FDI4KHFA8AgmsS/XeRIPmnOqfVeUXJDTfRdVPHrqX+UTa+n3quz5C/n1Y6N4LoL4aiPw3Dn8lG27vlQr++FrG7Wp0n5cKXk3KZSeo8VHUeOnXkesLc7zwP669ur+n4KFLXIrbrYWz3a449fV+0TOzXo5Cxeb4pWdsTHtc/0nY0pU654Kk5sri8eB0iS5RM7i/s3Fb13NjacGTCgiLx21S+kXKvksk9jZVOu3gtRmHjNc8eX7zm3ScxXmNHFpcXr+P/xquOLTdek2hRpC0V2ZqS/e7I1pXsj3Jhu1Acg+rvsG3yeR+snz3rPmzHw69toayXC39IDK6q7xLlv0f+0fUdWapkcblsp159jpUdrUs4Eqd+Xn1uVec19Rv5fdtjf82xv8Tt+c71S+qpn3rqI9buVH83qgMx9Jf8Jrr47OI4rj5nVyrDwtdO2ukfdH1toaH+U9HfCKK/l4n+zTD8836qGeb+DkT/Vhj+efy0wvD3RH87DP+Z6N8Owz9/j+kE0V/Mx+U7Yfjn8b8bxv9z/r0w/HP9+2H45/f3IIz+sYw7bkSL4o4zD9X3dv1/b3zZcabYrzusocaZhw6P6x89zoTsyMPa9sjcZ/TIY+fIY8ena9NQ14Ghrm1DXQ1DXfuGutqGuuqGuvYMdbUMdaWGuizvo6W/LGN111CXZaxuGeq6ru2E5fNo6fvrGqsbhrosY8IyVi39tWOoy7KNthwDNA11WfYdls/QdY2vp6H9CtEPhV0PzDLfPFhkp987D2aoPxNfS6zquW9tU64vcer/6fh5M4ife1N5J5M2SPvCN1dlabvm2Isi//us2G96eIS77pFd5R/Mno5OTsf383wwzIuifzKsOfqF1f1OzzvrPkfX970b++bVDH098q3xtJRfUWIl23JkiZIJo17j8c07WvJfxv/aftsjc8del72XnWg51vTz2IgWz3Bc2l/7cHTeljxirPQn0fIabuTYT5z6f1ef3bbuqs/I2XDaPetPz6bF9MGD/GTacfRrH8JP/wJJ9PoyCV0AAA==","debug_symbols":"tZbRCoMgGIXfxWsv0pV/7VXGGFYWglhYDUb07tOILbbrcxMd+fXzwg/OylpTL/3D+m6Y2PW2Mjc0eraDj2ndOKuDdc72j/Myy9JHFGrfMI3apzzNOszsKi5CVpwZ3+7/VMVDOutMTCLf+N88yWOY6DOZ03bnEUBoQIkGVGCAytAAgQZINOCCBuRoQIEGoE1WaJMV2mSFNpnQJhPaZEKbTGiTCW0yoU0mtMmENpmgJm8xPXWwunbmaDjd4ptT4Zlfo/npPmMYGtMuwaQW9C1A6TXmkhcyXTvZK8qMi7KIkAh6Aw==","brillig_names":["process_log"]},{"name":"update","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"10019982601749771606":{"error_kind":"string","string":"msg.sender is not deployed"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6504213605561840204":{"error_kind":"string","string":"New contract class is not registered"}},"parameters":[{"name":"new_contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["update"]},{"name":"deploy","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"initialization_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::NpkM"}},{"name":"ivpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::IvpkM"}},{"name":"ovpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::OvpkM"}},{"name":"tpk_m","type":{"fields":[{"name":"inner","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::TpkM"}}],"kind":"struct","path":"aztec::protocol_types::public_keys::PublicKeys"},"visibility":"private"},{"name":"universal_deploy","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["store_in_execution_cache_oracle_wrapper","call_private_function_internal","decompose_hint","lte_hint","notify_created_nullifier_oracle_wrapper","debug_log_oracle_wrapper","directive_integer_quotient","directive_invert"],"verification_key":"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"}]'),s={globals:{storage:[{fields:[{name:"contract_name",value:{kind:"string",value:"ContractInstanceDeployer"}},{name:"fields",value:{fields:[{name:"updated_class_ids",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}}],kind:"struct"}}],kind:"struct"}}],kind:"struct"}]},structs:{events:[{fields:[{name:"DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE",type:{kind:"field"}},{name:"address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"version",type:{kind:"integer",sign:"unsigned",width:8}},{name:"salt",type:{kind:"field"}},{name:"contract_class_id",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::contract_class_id::ContractClassId"}},{name:"initialization_hash",type:{kind:"field"}},{name:"public_keys",type:{fields:[{name:"npk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::NpkM"}},{name:"ivpk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::IvpkM"}},{name:"ovpk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::OvpkM"}},{name:"tpk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::TpkM"}}],kind:"struct",path:"aztec::protocol_types::public_keys::PublicKeys"}},{name:"deployer",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress"}}],kind:"struct",path:"ContractInstanceDeployer::ContractInstanceDeployed"},{fields:[{name:"DEPLOYER_CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE",type:{kind:"field"}},{name:"address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"prev_contract_class_id",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::contract_class_id::ContractClassId"}},{name:"new_contract_class_id",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::contract_class_id::ContractClassId"}},{name:"block_of_change",type:{kind:"integer",sign:"unsigned",width:32}}],kind:"struct",path:"ContractInstanceDeployer::ContractInstanceUpdated"}],functions:[{fields:[{name:"parameters",type:{fields:[{name:"new_contract_class_id",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::contract_class_id::ContractClassId"}}],kind:"struct",path:"ContractInstanceDeployer::update_parameters"}}],kind:"struct",path:"ContractInstanceDeployer::update_abi"},{fields:[{name:"parameters",type:{fields:[{name:"new_update_delay",type:{kind:"integer",sign:"unsigned",width:32}}],kind:"struct",path:"ContractInstanceDeployer::set_update_delay_parameters"}}],kind:"struct",path:"ContractInstanceDeployer::set_update_delay_abi"},{fields:[{name:"parameters",type:{fields:[{name:"salt",type:{kind:"field"}},{name:"contract_class_id",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"aztec::protocol_types::contract_class_id::ContractClassId"}},{name:"initialization_hash",type:{kind:"field"}},{name:"public_keys",type:{fields:[{name:"npk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::NpkM"}},{name:"ivpk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::IvpkM"}},{name:"ovpk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::OvpkM"}},{name:"tpk_m",type:{fields:[{name:"inner",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"}}],kind:"struct",path:"aztec::protocol_types::public_keys::TpkM"}}],kind:"struct",path:"aztec::protocol_types::public_keys::PublicKeys"}},{name:"universal_deploy",type:{kind:"boolean"}}],kind:"struct",path:"ContractInstanceDeployer::deploy_parameters"}}],kind:"struct",path:"ContractInstanceDeployer::deploy_abi"},{fields:[{name:"parameters",type:{fields:[],kind:"struct",path:"ContractInstanceDeployer::get_update_delay_parameters"}},{name:"return_type",type:{kind:"integer",sign:"unsigned",width:32}}],kind:"struct",path:"ContractInstanceDeployer::get_update_delay_abi"}]}},a=JSON.parse('{"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"16":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\\nuse crate::ops::arith::{Add, Neg, Sub};\\n\\n/// A point on the embedded elliptic curve\\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\\npub struct EmbeddedCurvePoint {\\n    pub x: Field,\\n    pub y: Field,\\n    pub is_infinite: bool,\\n}\\n\\nimpl EmbeddedCurvePoint {\\n    /// Elliptic curve point doubling operation\\n    /// returns the doubled point of a point P, i.e P+P\\n    pub fn double(self) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, self)\\n    }\\n\\n    /// Returns the null element of the curve; \'the point at infinity\'\\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\\n    }\\n}\\n\\nimpl Add for EmbeddedCurvePoint {\\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, other)\\n    }\\n}\\n\\nimpl Sub for EmbeddedCurvePoint {\\n    /// Points subtraction operation, using addition and negation\\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        self + other.neg()\\n    }\\n}\\n\\nimpl Neg for EmbeddedCurvePoint {\\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\\n    /// If the point is at infinity, then the result is also at infinity.\\n    fn neg(self) -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurvePoint {\\n    /// Checks whether two points are equal\\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\\n        (self.is_infinite & b.is_infinite)\\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\\n    }\\n}\\n\\n/// Scalar for the embedded curve represented as low and high limbs\\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\\npub struct EmbeddedCurveScalar {\\n    pub lo: Field,\\n    pub hi: Field,\\n}\\n\\nimpl EmbeddedCurveScalar {\\n    pub fn new(lo: Field, hi: Field) -> Self {\\n        EmbeddedCurveScalar { lo, hi }\\n    }\\n\\n    #[field(bn254)]\\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\\n        let (a, b) = crate::field::bn254::decompose(scalar);\\n        EmbeddedCurveScalar { lo: a, hi: b }\\n    }\\n\\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\n    #[field(bn254)]\\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n        let mut v = 1;\\n        let mut lo = 0 as Field;\\n        let mut hi = 0 as Field;\\n        for i in 0..16 {\\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\\n        sig_s\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurveScalar {\\n    fn eq(self, other: Self) -> bool {\\n        (other.hi == self.hi) & (other.lo == self.lo)\\n    }\\n}\\n\\n// Computes a multi scalar multiplication over the embedded curve.\\n// For bn254, We have Grumpkin and Baby JubJub.\\n// For bls12-381, we have JubJub and Bandersnatch.\\n//\\n// The embedded curve being used is decided by the\\n// underlying proof system.\\n// docs:start:multi_scalar_mul\\npub fn multi_scalar_mul<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> EmbeddedCurvePoint\\n// docs:end:multi_scalar_mul\\n{\\n    let point_array = multi_scalar_mul_array_return(points, scalars);\\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\\n}\\n\\n#[foreign(multi_scalar_mul)]\\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> [Field; 3] {}\\n\\n// docs:start:fixed_base_scalar_mul\\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\\n// docs:end:fixed_base_scalar_mul\\n{\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    multi_scalar_mul([g1], [scalar])\\n}\\n\\n/// This function only assumes that the points are on the curve\\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\\n// docs:start:embedded_curve_add\\npub fn embedded_curve_add(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    // docs:end:embedded_curve_add\\n    let x_coordinates_match = point1.x == point2.x;\\n    let y_coordinates_match = point1.y == point2.y;\\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\\n    let point1_1 = EmbeddedCurvePoint {\\n        x: point1.x + (x_coordinates_match as Field),\\n        y: point1.y,\\n        is_infinite: x_coordinates_match,\\n    };\\n    // point1_1 is guaranteed to have a different abscissa than point2\\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\\n    result.is_infinite = x_coordinates_match;\\n\\n    // dbl if x_match, y_match\\n    let double = embedded_curve_add_unsafe(point1, point1);\\n    result = if double_predicate { double } else { result };\\n\\n    // infinity if x_match, !y_match\\n    if point1.is_infinite {\\n        result = point2;\\n    }\\n    if point2.is_infinite {\\n        result = point1;\\n    }\\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\\n    result\\n}\\n\\n#[foreign(embedded_curve_add)]\\nfn embedded_curve_add_array_return(\\n    _point1: EmbeddedCurvePoint,\\n    _point2: EmbeddedCurvePoint,\\n) -> [Field; 3] {}\\n\\n/// This function assumes that:\\n/// The points are on the curve, and\\n/// The points don\'t share an x-coordinate, and\\n/// Neither point is the infinity point.\\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\\npub fn embedded_curve_add_not_nul(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    assert(point1.x != point2.x);\\n    assert(!point1.is_infinite);\\n    assert(!point2.is_infinite);\\n    embedded_curve_add_unsafe(point1, point2)\\n}\\n\\n/// Unsafe ec addition\\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\\n/// If they have the same value but are different variables, the result will be incorrect because in this case\\n/// it assumes (but does not check) that the points\' x-coordinates are not equal.\\n/// It also assumes neither point is the infinity point.\\npub fn embedded_curve_add_unsafe(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    let point_array = embedded_curve_add_array_return(point1, point2);\\n    let x = point_array[0];\\n    let y = point_array[1];\\n\\n    EmbeddedCurvePoint { x, y, is_infinite: false }\\n}\\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    // Safety: borrow is enforced to be boolean due to its type.\\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        // Safety: decomposition is properly checked below\\n        unsafe {\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            // Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unsafe in unconstrained\\n        unsafe {\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        // Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unconstrained context\\n        unsafe {\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        // 259, in base 256, big endian, is [1, 3].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        // 259, in base 256, little endian, is [3, 1].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    //#[test]\\n    //fn test_to_le_radix_brillig_1() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(1);\\n    //        crate::println(out);\\n    //        let expected = [0; 8];\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    //#[test]\\n    //fn test_to_le_radix_brillig_512() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(512);\\n    //        let mut expected = [0; 8];\\n    //        expected[0] = 1;\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"24":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"46":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"47":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"54":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"use dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract ContractInstanceDeployer {\\n    use dep::aztec::macros::{events::event, functions::{private, public, view}, storage::storage};\\n    use dep::aztec::prelude::{Map, SharedMutable};\\n    use dep::aztec::protocol_types::{\\n        address::{AztecAddress, PartialAddress},\\n        constants::{\\n            DEFAULT_UPDATE_DELAY, DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n            DEPLOYER_CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE, MINIMUM_UPDATE_DELAY,\\n            REGISTERER_CONTRACT_ADDRESS,\\n        },\\n        contract_class_id::ContractClassId,\\n        public_keys::PublicKeys,\\n        traits::{Serialize, ToField},\\n        utils::arrays::array_concat,\\n    };\\n    use dep::contract_class_registerer::ContractClassRegisterer;\\n    use std::meta::derive;\\n\\n    #[derive(Serialize)]\\n    #[event]\\n    struct ContractInstanceDeployed {\\n        DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE: Field,\\n        address: AztecAddress,\\n        version: u8,\\n        salt: Field,\\n        contract_class_id: ContractClassId,\\n        initialization_hash: Field,\\n        public_keys: PublicKeys,\\n        deployer: AztecAddress,\\n    }\\n\\n    // We need to impl this separately because ts deserializes a point as two fields only.\\n    // We had issues that:\\n    // Notice how the \'is_infinite\' field is deserialized as the next point.\\n    // {\\n    //     masterNullifierPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000012>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000000034>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // },\\n    // masterIncomingViewingPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000000>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000000056>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // },\\n    // masterOutgoingViewingPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000078>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000000000>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // },\\n    // masterTaggingPublicKey: Point {\\n    //   x: Fr<0x0000000000000000000000000000000000000000000000000000000000000910>,\\n    //   y: Fr<0x0000000000000000000000000000000000000000000000000000000000001112>,\\n    //   isInfinite: false,\\n    //   kind: \'point\'\\n    // }\\n\\n    impl ContractInstanceDeployed {\\n        fn serialize_non_standard(self) -> [Field; 15] {\\n            [\\n                self.DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n                self.address.to_field(),\\n                self.version.to_field(),\\n                self.salt,\\n                self.contract_class_id.to_field(),\\n                self.initialization_hash,\\n                self.public_keys.npk_m.serialize()[0],\\n                self.public_keys.npk_m.serialize()[1],\\n                self.public_keys.ivpk_m.serialize()[0],\\n                self.public_keys.ivpk_m.serialize()[1],\\n                self.public_keys.ovpk_m.serialize()[0],\\n                self.public_keys.ovpk_m.serialize()[1],\\n                self.public_keys.tpk_m.serialize()[0],\\n                self.public_keys.tpk_m.serialize()[1],\\n                self.deployer.to_field(),\\n            ]\\n        }\\n    }\\n\\n    #[derive(Serialize)]\\n    #[event]\\n    struct ContractInstanceUpdated {\\n        DEPLOYER_CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE: Field,\\n        address: AztecAddress,\\n        prev_contract_class_id: ContractClassId,\\n        new_contract_class_id: ContractClassId,\\n        block_of_change: u32,\\n    }\\n\\n    #[storage]\\n    struct Storage<Context> {\\n        updated_class_ids: Map<AztecAddress, SharedMutable<ContractClassId, DEFAULT_UPDATE_DELAY, Context>, Context>,\\n    }\\n\\n    #[private]\\n    fn deploy(\\n        salt: Field,\\n        contract_class_id: ContractClassId,\\n        initialization_hash: Field,\\n        public_keys: PublicKeys,\\n        universal_deploy: bool,\\n    ) {\\n        // contract class must be registered to deploy an instance\\n        ContractClassRegisterer::at(REGISTERER_CONTRACT_ADDRESS)\\n            .assert_class_id_is_registered(contract_class_id)\\n            .call(&mut context);\\n\\n        let deployer = if universal_deploy {\\n            AztecAddress::zero()\\n        } else {\\n            context.msg_sender()\\n        };\\n\\n        let partial_address =\\n            PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\\n\\n        let address = AztecAddress::compute(public_keys, partial_address);\\n\\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\\n        context.push_nullifier(address.to_field());\\n\\n        // Broadcast the event\\n        let event = ContractInstanceDeployed {\\n            DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n            contract_class_id,\\n            address,\\n            public_keys,\\n            initialization_hash,\\n            salt,\\n            deployer,\\n            version: 1,\\n        };\\n\\n        let payload = event.serialize_non_standard();\\n        dep::aztec::oracle::debug_log::debug_log_format(\\"ContractInstanceDeployed: {}\\", payload);\\n\\n        let padded_log = array_concat(payload, [0; 3]);\\n        context.emit_private_log(padded_log);\\n    }\\n\\n    #[public]\\n    fn update(new_contract_class_id: ContractClassId) {\\n        let address = context.msg_sender();\\n\\n        assert(\\n            context.nullifier_exists(address.to_field(), context.this_address()),\\n            \\"msg.sender is not deployed\\",\\n        );\\n\\n        assert(\\n            context.nullifier_exists(new_contract_class_id.to_field(), REGISTERER_CONTRACT_ADDRESS),\\n            \\"New contract class is not registered\\",\\n        );\\n\\n        let scheduled_value_update = storage\\n            .updated_class_ids\\n            .at(address)\\n            .schedule_and_return_value_change(new_contract_class_id);\\n        let (prev_contract_class_id, block_of_change) = scheduled_value_update.get_previous();\\n\\n        let event = ContractInstanceUpdated {\\n            DEPLOYER_CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE,\\n            address,\\n            prev_contract_class_id,\\n            new_contract_class_id,\\n            block_of_change,\\n        };\\n\\n        context.emit_public_log(event);\\n    }\\n\\n    #[public]\\n    fn set_update_delay(new_update_delay: u32) {\\n        let address = context.msg_sender();\\n\\n        assert(\\n            context.nullifier_exists(address.to_field(), context.this_address()),\\n            \\"msg.sender is not deployed\\",\\n        );\\n\\n        assert(new_update_delay >= MINIMUM_UPDATE_DELAY, \\"New update delay is too low\\");\\n\\n        storage.updated_class_ids.at(address).schedule_delay_change(new_update_delay);\\n    }\\n\\n    #[public]\\n    #[view]\\n    fn get_update_delay() -> u32 {\\n        storage.updated_class_ids.at(context.msg_sender()).get_current_delay()\\n    }\\n}\\n"},"55":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// A dynamically sized array backed by PXE\'s non-volatile database (called capsules). Values are persisted until\\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\\npub struct CapsuleArray<T> {\\n    contract_address: AztecAddress,\\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\\n    base_slot: Field,\\n}\\n\\nimpl<T, let N: u32> CapsuleArray<T>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{\\n    /// Returns a CapsuleArray connected to a contract\'s capsules at a base slot. Array elements are stored in\\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\\n        Self { contract_address, base_slot }\\n    }\\n\\n    /// Returns the number of elements stored in the array.\\n    pub unconstrained fn len(self) -> u32 {\\n        // An uninitialized array defaults to a length of 0.\\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\\n    }\\n\\n    /// Stores a value at the end of the array.\\n    pub unconstrained fn push(self, value: T) {\\n        let current_length = self.len();\\n\\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\\n        // array, which is where we want to place the new value.\\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\\n\\n        // Then we simply update the length.\\n        let new_length = current_length + 1;\\n        capsules::store(self.contract_address, self.base_slot, new_length);\\n    }\\n\\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn get(self, index: u32) -> T {\\n        assert(index < self.len(), \\"Attempted to read past the length of a CapsuleArray\\");\\n\\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\\n    }\\n\\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn remove(self, index: u32) {\\n        let current_length = self.len();\\n        assert(index < current_length, \\"Attempted to delete past the length of a CapsuleArray\\");\\n\\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\\n        // array past the removed element one slot backward so that we don\'t end up with a gap and preserve the\\n        // contiguous slots. We can skip this when deleting the last element however.\\n        if index != current_length - 1 {\\n            // The source and destination regions overlap, but `copy` supports this.\\n            capsules::copy(\\n                self.contract_address,\\n                self.slot_at(index + 1),\\n                self.slot_at(index),\\n                current_length - index - 1,\\n            );\\n        }\\n\\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\\n        // the element we meant to delete in the first place) and update the length.\\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\\n    }\\n\\n    unconstrained fn slot_at(self, index: u32) -> Field {\\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\\n        // element.\\n        self.base_slot + 1 + index as Field\\n    }\\n}\\n\\nmod test {\\n    use crate::test::helpers::test_environment::TestEnvironment;\\n    use super::CapsuleArray;\\n    use protocol_types::address::AztecAddress;\\n\\n    global SLOT: Field = 1230;\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        TestEnvironment::new().unkonstrained().this_address()\\n    }\\n\\n    #[test]\\n    unconstrained fn empty_array() {\\n        let contract_address = setup();\\n\\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn empty_array_read() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        let _: Field = array.get(0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_push() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        assert_eq(array.len(), 1);\\n        assert_eq(array.get(0), 5);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn read_past_len() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        let _ = array.get(1);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_last() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(5);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_some() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        assert_eq(array.len(), 3);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 8);\\n        assert_eq(array.get(2), 9);\\n\\n        array.remove(1);\\n\\n        assert_eq(array.len(), 2);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 9);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_all() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        array.remove(1);\\n        array.remove(1);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n}\\n"},"56":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::execution_cache;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field];\\n    fn get_selector(self) -> FunctionSelector;\\n    fn get_name(self) -> str<N>;\\n    fn get_contract_address(self) -> AztecAddress;\\n    fn get_is_static(self) -> bool;\\n}\\n\\n// PrivateCallInterface\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let returns: T = returns_hash.get_preimage();\\n        returns\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns_hash = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns_hash.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateVoidCallInterface\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\\n    }\\n\\n    pub fn call(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticCallInterface\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args_hash,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n        }\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        execution_cache::store(self.args);\\n        let returns = context.call_private_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.get_preimage()\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PrivateStaticVoidCallInterface\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        let args_hash = hash_args(args);\\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        execution_cache::store(self.args);\\n        context\\n            .call_private_function_with_args_hash(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicCallInterface\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    gas_opts: GasOpts,\\n    return_type: T,\\n    is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            gas_opts: GasOpts::default(),\\n            return_type: std::mem::zeroed(),\\n            is_static,\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicVoidCallInterface\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n        is_static: bool,\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n\\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.set_public_teardown_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticCallInterface\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: T,\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: std::mem::zeroed(),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\n// PublicStaticVoidCallInterface\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn new(\\n        target_contract: AztecAddress,\\n        selector: FunctionSelector,\\n        name: str<N>,\\n        args: [Field],\\n    ) -> Self {\\n        Self {\\n            target_contract,\\n            selector,\\n            name,\\n            args,\\n            return_type: (),\\n            is_static: true,\\n            gas_opts: GasOpts::default(),\\n        }\\n    }\\n\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        execution_cache::store(self.args);\\n        context.call_public_function_with_args_hash(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n"},"63":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        gas_settings::GasSettings,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Empty, FromField, Hash, ToField},\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn gas_settings(self) -> GasSettings {\\n        self.inputs.tx_context.gas_settings\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            // for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        // the number of side effects that took place), along with the hash of the return values. We validate these\\n        // by requesting a private kernel iteration in which the return values are constrained to hash\\n        // to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"64":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\\nuse crate::hash::{\\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\\n};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\\n\\npub struct PublicContext {\\n    pub args_hash: Option<Field>,\\n    pub compute_args_hash: fn() -> Field,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\\n        PublicContext { args_hash: Option::none(), compute_args_hash }\\n    }\\n\\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\\n    }\\n\\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\\n    }\\n\\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\\n    }\\n\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_l1_to_l2_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/\\n            self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash,\\n            leaf_index,\\n        );\\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()),\\n            \\"L1-to-L2 message is already nullified\\",\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\\n            \\"Tried to consume nonexistent L1-to-L2 message\\",\\n        );\\n\\n        self.push_nullifier(nullifier);\\n    }\\n\\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { send_l2_to_l1_msg(recipient, content) };\\n    }\\n\\n    pub unconstrained fn call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub unconstrained fn static_call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n\\n        call_static(gas_for_call(gas_opts), contract_address, args);\\n        // Use success_copy to determine whether the call succeeded\\n        let success = success_copy();\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_note_hash(note_hash) };\\n    }\\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_nullifier(nullifier) };\\n    }\\n\\n    pub fn this_address(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            address()\\n        }\\n    }\\n    pub fn msg_sender(_self: Self) -> AztecAddress {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            sender()\\n        }\\n    }\\n    pub fn selector(_self: Self) -> FunctionSelector {\\n        // The selector is the first element of the calldata when calling a public function through dispatch.\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\\n        FunctionSelector::from_field(raw_selector[0])\\n    }\\n    pub fn get_args_hash(mut self) -> Field {\\n        if !self.args_hash.is_some() {\\n            self.args_hash = Option::some((self.compute_args_hash)());\\n        }\\n\\n        self.args_hash.unwrap_unchecked()\\n    }\\n    pub fn transaction_fee(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            transaction_fee()\\n        }\\n    }\\n\\n    pub fn chain_id(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            chain_id()\\n        }\\n    }\\n    pub fn version(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            version()\\n        }\\n    }\\n    pub fn block_number(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            block_number()\\n        }\\n    }\\n    pub fn timestamp(_self: Self) -> u64 {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            timestamp()\\n        }\\n    }\\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_l2_gas()\\n        }\\n    }\\n    pub fn fee_per_da_gas(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_da_gas()\\n        }\\n    }\\n\\n    pub fn l2_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            l2_gas_left()\\n        }\\n    }\\n    pub fn da_gas_left(_self: Self) -> Field {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            da_gas_left()\\n        }\\n    }\\n    pub fn is_static_call(_self: Self) -> bool {\\n        // Safety: AVM opcodes are constrained by the AVM itself\\n        unsafe { is_static_call() } == 1\\n    }\\n\\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        let mut out = [0; N];\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\\n        }\\n        out\\n    }\\n\\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n\\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        for i in 0..N {\\n            // Safety: AVM opcodes are constrained by the AVM itself\\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\\n        }\\n    }\\n\\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\\n    where\\n        T: Packable<N>,\\n    {\\n        self.raw_storage_write(storage_slot, value.pack());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn is_static_call() -> Field {\\n    is_static_call_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_public_log(message: [Field]) {\\n    emit_public_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_opcode(gas, address, args)\\n}\\n\\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\\n    call_static_opcode(gas, address, args)\\n}\\n\\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\\n    calldata_copy_opcode(cdoffset, copy_size)\\n}\\n\\n// `success_copy` is placed immediately after the CALL opcode to get the success value\\nunconstrained fn success_copy() -> bool {\\n    success_copy_opcode()\\n}\\n\\nunconstrained fn returndata_size() -> u32 {\\n    returndata_size_opcode()\\n}\\n\\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\\n    returndata_copy_opcode(rdoffset, copy_size)\\n}\\n\\npub unconstrained fn avm_return(returndata: [Field]) {\\n    return_opcode(returndata)\\n}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\nunconstrained fn avm_revert(revertdata: [Field]) {\\n    revert_opcode(revertdata)\\n}\\n\\nunconstrained fn storage_read(storage_slot: Field) -> Field {\\n    storage_read_opcode(storage_slot)\\n}\\n\\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\\n    storage_write_opcode(storage_slot, value);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(|| 0)\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeIsStaticCall)]\\nunconstrained fn is_static_call_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n// TODO(#11124): rename unencrypted to public in avm\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCalldataCopy)]\\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeReturndataSize)]\\nunconstrained fn returndata_size_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeReturndataCopy)]\\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\\n\\n#[oracle(avmOpcodeReturn)]\\nunconstrained fn return_opcode(returndata: [Field]) {}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\n#[oracle(avmOpcodeRevert)]\\nunconstrained fn revert_opcode(revertdata: [Field]) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) {}\\n\\n#[oracle(avmOpcodeSuccessCopy)]\\nunconstrained fn success_copy_opcode() -> bool {}\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\\n"},"65":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr","source":"use crate::{hash::hash_args_array, oracle::execution_cache};\\nuse dep::protocol_types::traits::Deserialize;\\n\\npub struct ReturnsHash {\\n    hash: Field,\\n}\\n\\nimpl ReturnsHash {\\n    pub fn new(hash: Field) -> Self {\\n        ReturnsHash { hash }\\n    }\\n\\n    pub fn assert_empty(self) {\\n        assert_eq(self.hash, 0);\\n    }\\n\\n    pub fn raw(self) -> Field {\\n        self.hash\\n    }\\n\\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\\n    /// values.\\n    pub fn get_preimage<T, let N: u32>(self) -> T\\n    where\\n        T: Deserialize<N>,\\n    {\\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\\n        assert_eq(self.hash, hash_args_array(preimage));\\n\\n        Deserialize::deserialize(preimage)\\n    }\\n}\\n"},"66":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"68":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr","source":"// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\\n\\npub mod private_logs;\\npub mod partial_notes;\\npub mod nonce_discovery;\\n\\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\\n/// one for the combined log and note type ID.\\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\\n\\n/// The maximum length of the packed representation of a note\'s contents. This is limited by private log size, encryption\\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\\npub global MAX_NOTE_PACKED_LEN: u32 =\\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\\n\\npub struct NoteHashAndNullifier {\\n    /// The result of NoteHash::compute_note_hash\\n    pub note_hash: Field,\\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\\n    pub inner_nullifier: Field,\\n}\\n\\n/// A function which takes a note\'s packed content, address of the emitting contract, nonce, storage slot and note type\\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\\n/// address).\\n///\\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\\n///\\n/// ```\\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\\n///     if note_type_id == MyNoteType::get_id() {\\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\\n///\\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n///\\n///         let note_hash = note.compute_note_hash(storage_slot);\\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\\n///             storage_slot\\n///         );\\n///\\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\\n///\\n///         Option::some(\\n///             aztec::discovery::NoteHashAndNullifier {\\n///                 note_hash, inner_nullifier\\n///             }\\n///         )\\n///     } else if note_type_id == MyOtherNoteType::get_id() {\\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\\n///     } else {\\n///         Option::none() // Unknown note type ID\\n///     };\\n/// }\\n/// ```\\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\\n\\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\\n///\\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\\n/// along with its `compute_note_hash_and_nullifier` function.\\npub unconstrained fn discover_new_notes<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    debug_log(\\"Performing note discovery\\");\\n\\n    private_logs::fetch_and_process_private_tagged_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n\\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n}\\n"},"69":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr","source":"use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::MAX_NOTE_HASHES_PER_TX,\\n    debug_log::debug_log_format,\\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\\n    traits::ToField,\\n};\\n\\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\\n/// the complete note information, since it does not include content, storage slot, etc.\\npub struct DiscoveredNoteInfo {\\n    pub nonce: Field,\\n    pub note_hash: Field,\\n    pub inner_nullifier: Field,\\n}\\n\\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\\n/// cases it will contain a single element.\\n///\\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\\npub unconstrained fn attempt_note_nonce_discovery<Env>(\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\\n    let discovered_notes = &mut BoundedVec::new();\\n\\n    debug_log_format(\\n        \\"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\\",\\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\\n    );\\n\\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\\n    // is one of the note hashes created by the transaction.\\n    array::for_each_in_bounded_vec(\\n        unique_note_hashes_in_tx,\\n        |expected_unique_note_hash, i| {\\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\\n\\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\\n            // the note hash at the array index we\'re currently processing.\\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\\n            let hashes = compute_note_hash_and_nullifier(\\n                packed_note_content,\\n                storage_slot,\\n                note_type_id,\\n                contract_address,\\n                candidate_nonce,\\n            )\\n                .expect(f\\"Failed to compute a note hash for note type {note_type_id}\\");\\n\\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\\n\\n            if unique_note_hash == expected_unique_note_hash {\\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn\'t, then\\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\\n                // application already has more direct means of making a call to it fail the transaction.\\n                discovered_notes.push(\\n                    DiscoveredNoteInfo {\\n                        nonce: candidate_nonce,\\n                        note_hash: hashes.note_hash,\\n                        inner_nullifier: hashes.inner_nullifier,\\n                    },\\n                );\\n\\n                // We don\'t exit the loop - it is possible (though rare) for the exact same note content to be present\\n                // multiple times in the same transaction with different nonces. This typically doesn\'t happen due to\\n                // notes containing random values in order to hide their contents.\\n            }\\n        },\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered a total of {0} notes\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    *discovered_notes\\n}\\n"},"70":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr","source":"use crate::{\\n    capsules::CapsuleArray,\\n    discovery::{\\n        ComputeNoteHashAndNullifier,\\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\\n    },\\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\\n    debug_log::debug_log_format,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\\n// TODO(#11630): come up with some sort of slot allocation scheme.\\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\\n\\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\\n/// the packed public content.\\n// TODO(#10273): improve how contract log siloing is handled\\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\\n\\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\\n/// size and extra fields in the log (e.g. the tag).\\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\\n\\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\\n/// log that will complete it and lead to a note being discovered and delivered.\\n#[derive(Serialize, Deserialize)]\\npub(crate) struct DeliveredPendingPartialNote {\\n    pub(crate) note_completion_log_tag: Field,\\n    pub(crate) storage_slot: Field,\\n    pub(crate) note_type_id: Field,\\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\\n    pub(crate) recipient: AztecAddress,\\n}\\n\\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\\n/// notes being delivered to PXE if completed.\\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let pending_partial_notes = CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    );\\n\\n    debug_log_format(\\n        \\"{} pending partial notes\\",\\n        [pending_partial_notes.len() as Field],\\n    );\\n\\n    let mut i = &mut 0;\\n    whyle(\\n        || *i < pending_partial_notes.len(),\\n        || {\\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\\n\\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\\n            if maybe_log.is_none() {\\n                debug_log_format(\\n                    \\"Found no completion logs for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                *i += 1 as u32;\\n                // Note that we\'re not removing the pending partial note from the PXE DB, so we will continue searching\\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\\n                // is somehow removed from the PXE DB.\\n            } else {\\n                debug_log_format(\\n                    \\"Completion log found for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                let log = maybe_log.unwrap();\\n\\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\\n                // that we\'re getting the logs from the expected contract.\\n                // TODO(#10273): improve how contract log siloing is handled\\n                assert_eq(\\n                    log.log_content.get(0),\\n                    contract_address.to_field(),\\n                    \\"Got a public log emitted by a different contract\\",\\n                );\\n\\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\\n                // complete packed content.\\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\\n                let complete_packed_note_content = array::append(\\n                    pending_partial_note.packed_private_note_content,\\n                    packed_public_note_content,\\n                );\\n\\n                let discovered_notes = attempt_note_nonce_discovery(\\n                    log.unique_note_hashes_in_tx,\\n                    log.first_nullifier_in_tx,\\n                    compute_note_hash_and_nullifier,\\n                    contract_address,\\n                    pending_partial_note.storage_slot,\\n                    pending_partial_note.note_type_id,\\n                    complete_packed_note_content,\\n                );\\n\\n                debug_log_format(\\n                    \\"Discovered {0} notes for partial note with tag {1}\\",\\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\\n                );\\n\\n                array::for_each_in_bounded_vec(\\n                    discovered_notes,\\n                    |discovered_note: DiscoveredNoteInfo, _| {\\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\\n                        // temporary node connectivity issue - is simply throwing good enough here?\\n                        assert(\\n                            deliver_note(\\n                                contract_address,\\n                                pending_partial_note.storage_slot,\\n                                discovered_note.nonce,\\n                                complete_packed_note_content,\\n                                discovered_note.note_hash,\\n                                discovered_note.inner_nullifier,\\n                                log.tx_hash,\\n                                pending_partial_note.recipient,\\n                            ),\\n                            \\"Failed to deliver note\\",\\n                        );\\n                    },\\n                );\\n\\n                // Because there is only a single log for a given tag, once we\'ve processed the tagged log then we\\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\\n                // being completed.\\n                pending_partial_notes.remove(*i);\\n\\n                // We don\'t increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\\n                // shifts the elements to the left if the removed element is not the last element.\\n            }\\n        },\\n    );\\n}\\n\\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\\n/// supports looping in unconstrained code.\\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\\n    if condition() {\\n        body();\\n        whyle(condition, body);\\n    }\\n}\\n"},"71":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr","source":"use std::static_assert;\\n\\nuse crate::{\\n    capsules::CapsuleArray,\\n    oracle::note_discovery::{deliver_note, sync_notes},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\\n    debug_log::{debug_log, debug_log_format},\\n};\\n\\nuse crate::discovery::{\\n    ComputeNoteHashAndNullifier,\\n    MAX_NOTE_PACKED_LEN,\\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\\n    partial_notes::{\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\\n    },\\n};\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\\n// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\n\\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\\n/// the note completion log tag).\\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\\n\\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\\n/// public logs that will complete them.\\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\\n    _contract_address: AztecAddress,\\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\\n    // decrypted log, letting us continue the work outside of PXE.\\n    sync_notes();\\n}\\n\\n/// Processes a log\'s ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\\n/// which the notes would\'ve been created (typically the same transaction in which the log was emitted), along with the\\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\\npub unconstrained fn do_process_log<Env>(\\n    contract_address: AztecAddress,\\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let log_plaintext = decrypt_log(log, recipient);\\n\\n    // The first thing to do after decrypting the log is to determine what type of private log we\'re processing. We\\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\\n    // improved upon in the future to also handle events, etc.\\n\\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\\n        destructure_log_plaintext(log_plaintext);\\n\\n    if log_type_id == 0 {\\n        debug_log(\\"Processing private note log\\");\\n\\n        attempt_note_discovery(\\n            contract_address,\\n            tx_hash,\\n            unique_note_hashes_in_tx,\\n            first_nullifier_in_tx,\\n            recipient,\\n            compute_note_hash_and_nullifier,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n        );\\n    } else if log_type_id == 1 {\\n        debug_log(\\"Processing partial note private log\\");\\n\\n        process_partial_note_private_log(\\n            contract_address,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n            recipient,\\n        );\\n    } else {\\n        // TODO(#11569): handle events\\n        debug_log_format(\\n            \\"Unknown log type id {0} (probably belonging to an event log)\\",\\n            [log_type_id],\\n        );\\n    }\\n}\\n\\nunconstrained fn destructure_log_plaintext(\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\\n    // `storage_slot` and `note_type_id` must be updated as well.\\n    static_assert(\\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\\n        \\"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\\",\\n    );\\n    let storage_slot = log_plaintext.get(0);\\n\\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\\n    // distinguish private note logs and partial note logs.\\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we\'d be able to\\n    // leverage enums and tagged unions to achieve this goal.\\n    let combined_type_id = log_plaintext.get(1);\\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\\n\\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    (storage_slot, note_type_id, log_type_id, log_payload)\\n}\\n\\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\\n/// suspected the note was created.\\npub unconstrained fn attempt_note_discovery<Env>(\\n    contract_address: AztecAddress,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) {\\n    let discovered_notes = attempt_note_nonce_discovery(\\n        unique_note_hashes_in_tx,\\n        first_nullifier_in_tx,\\n        compute_note_hash_and_nullifier,\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered {0} notes from a private log\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    array::for_each_in_bounded_vec(\\n        discovered_notes,\\n        |discovered_note: DiscoveredNoteInfo, _| {\\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\\n            // issue, and we should perhaps not have marked the tag index as taken.\\n            assert(\\n                deliver_note(\\n                    contract_address,\\n                    storage_slot,\\n                    discovered_note.nonce,\\n                    packed_note_content,\\n                    discovered_note.note_hash,\\n                    discovered_note.inner_nullifier,\\n                    tx_hash,\\n                    recipient,\\n                ),\\n                \\"Failed to deliver note\\",\\n            );\\n        },\\n    );\\n}\\n\\nunconstrained fn process_partial_note_private_log(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    recipient: AztecAddress,\\n) {\\n    // We store the information of the partial note we found so that we can later search for the public log that will\\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\\n    static_assert(\\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\\n        \\"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\\",\\n    );\\n\\n    let pending = DeliveredPendingPartialNote {\\n        note_completion_log_tag: log_payload.get(0),\\n        storage_slot,\\n        note_type_id,\\n        packed_private_note_content: array::subbvec(log_payload, 1),\\n        recipient,\\n    };\\n\\n    CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    )\\n        .push(pending);\\n}\\n"},"85":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::{Hash, ToField},\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"106":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr","source":"use super::utils::compute_fn_selector;\\nuse std::panic;\\n\\n/// Returns an `fn public_dispatch(...)` function for the given module that\'s assumed to be an Aztec contract.\\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\\n    let functions = m.functions();\\n    let functions =\\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\\"public\\"));\\n\\n    let unit = get_type::<()>();\\n\\n    let ifs = functions.map(|function: FunctionDefinition| {\\n        let name = function.name();\\n        let parameters = function.parameters();\\n        let return_type = function.return_type();\\n\\n        let selector: Field = compute_fn_selector(function);\\n\\n        let mut parameters_size = 0;\\n        for param in parameters {\\n            parameters_size += size_in_fields(param.1);\\n        }\\n\\n        let initial_read = if parameters.len() == 0 {\\n            quote {}\\n        } else {\\n            // The initial calldata_copy offset is 1 to skip the Field selector\\n            // The expected calldata is the serialization of\\n            // - FunctionSelector: the selector of the function intended to dispatch\\n            // - Parameters: the parameters of the function intended to dispatch\\n            // That is, exactly what is expected for a call to the target function,\\n            // but with a selector added at the beginning.\\n            quote {\\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\\n            }\\n        };\\n\\n        let parameter_index = &mut 0;\\n        let reads = parameters.map(|param: (Quoted, Type)| {\\n            let parameter_index_value = *parameter_index;\\n            let param_name = f\\"arg{parameter_index_value}\\".quoted_contents();\\n            let param_type = param.1;\\n            let read = quote {\\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\\n            };\\n            *parameter_index += 1;\\n            quote { $read }\\n        });\\n        let read = reads.join(quote { });\\n\\n        let mut args = &[];\\n        for parameter_index in 0..parameters.len() {\\n            let param_name = f\\"arg{parameter_index}\\".quoted_contents();\\n            args = args.push_back(quote { $param_name });\\n        }\\n\\n        let args = args.join(quote { , });\\n        let call = quote { $name($args) };\\n\\n        let return_code = if return_type == unit {\\n            quote {\\n                $call;\\n                // Force early return.\\n                dep::aztec::context::public_context::avm_return([]);\\n            }\\n        } else {\\n            quote {\\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\\n            }\\n        };\\n\\n        let if_ = quote {\\n            if selector == $selector {\\n                $initial_read\\n                $read\\n                $return_code\\n            }\\n        };\\n        if_\\n    });\\n\\n    if ifs.len() == 0 {\\n        // No dispatch function if there are no public functions\\n        quote {}\\n    } else {\\n        let ifs = ifs.push_back(quote { panic(f\\"Unknown selector {selector}\\") });\\n        let dispatch = ifs.join(quote {  });\\n\\n        let body = quote {\\n            // We mark this as public because our whole system depends on public\\n            // functions having this attribute. However, the public MACRO will\\n            // handle the public_dispatch function specially and do nothing.\\n            #[public]\\n            pub unconstrained fn public_dispatch(selector: Field) {\\n                $dispatch\\n            }\\n        };\\n\\n        body\\n    }\\n}\\n\\ncomptime fn size_in_fields(typ: Type) -> u32 {\\n    let size = array_size_in_fields(typ);\\n    let size = size.or_else(|| bool_size_in_fields(typ));\\n    let size = size.or_else(|| constant_size_in_fields(typ));\\n    let size = size.or_else(|| field_size_in_fields(typ));\\n    let size = size.or_else(|| int_size_in_fields(typ));\\n    let size = size.or_else(|| str_size_in_fields(typ));\\n    let size = size.or_else(|| struct_size_in_fields(typ));\\n    let size = size.or_else(|| tuple_size_in_fields(typ));\\n    if size.is_some() {\\n        size.unwrap()\\n    } else {\\n        panic(f\\"Can\'t determine size in fields of {typ}\\")\\n    }\\n}\\n\\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_array().and_then(|typ: (Type, Type)| {\\n        let (typ, element_size) = typ;\\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\\n    })\\n}\\n\\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_bool() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.is_field() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\\n    if typ.as_integer().is_some() {\\n        Option::some(1)\\n    } else {\\n        Option::none()\\n    }\\n}\\n\\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_constant()\\n}\\n\\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_str().map(|typ| size_in_fields(typ))\\n}\\n\\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\\n        let struct_type = typ.0;\\n        let generics = typ.1;\\n        let mut size = 0;\\n        for field in struct_type.fields(generics) {\\n            size += size_in_fields(field.1);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\\n    typ.as_tuple().map(|types: [Type]| {\\n        let mut size = 0;\\n        for typ in types {\\n            size += size_in_fields(typ);\\n        }\\n        size\\n    })\\n}\\n\\ncomptime fn get_type<T>() -> Type {\\n    let t: T = std::mem::zeroed();\\n    std::meta::type_of(t)\\n}\\n"},"109":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr","source":"use crate::macros::utils::{\\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\\n};\\nuse std::meta::{type_of, unquote};\\n\\ncomptime global FROM_FIELD: TypedExpr = {\\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\\n    let function_selector_typ =\\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\\n        m.name() == quote { from_field }\\n    })[0]\\n        .as_typed_expr()\\n};\\n\\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\\n\\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\\n    let is_static_call = is_fn_view(f);\\n    let is_void = f.return_type() == type_of(());\\n\\n    if is_fn_private(f) {\\n        if is_static_call {\\n            if is_void {\\n                create_private_static_void_stub(f)\\n            } else {\\n                create_private_static_stub(f)\\n            }\\n        } else {\\n            if is_void {\\n                create_private_void_stub(f)\\n            } else {\\n                create_private_stub(f)\\n            }\\n        }\\n    } else {\\n        if is_static_call {\\n            if is_void {\\n                create_public_static_void_stub(f)\\n            } else {\\n                create_public_static_stub(f)\\n            }\\n        } else {\\n            if is_void {\\n                create_public_void_stub(f)\\n            } else {\\n                create_public_stub(f)\\n            }\\n        }\\n    }\\n}\\n\\n/// Utility function creating stubs used by all the stub functions in this file.\\ncomptime fn create_stub_base(\\n    f: FunctionDefinition,\\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\\n    let fn_name = f.name();\\n    let fn_parameters = f.parameters();\\n    let fn_parameters_list =\\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\\n\\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\\n    // parameters:\\n    // ```\\n    // let mut serialized_args =  &[];\\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\\n    // ```\\n    let serialized_args_slice_construction = fn_parameters.fold(\\n        quote {\\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\\n        },\\n        |args, param: (Quoted, Type)| {\\n            let (name, typ) = param;\\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\\n            quote {\\n                $args\\n                $arg_to_append\\n            }\\n        },\\n    );\\n\\n    let (fn_name_str, _) = fn_name.as_str_quote();\\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\\n    let fn_selector: Field = compute_fn_selector(f);\\n\\n    (\\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\\n        fn_selector,\\n    )\\n}\\n\\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n    let fn_return_type = f.return_type();\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                $SERIALIZED_ARGS_SLICE_NAME,\\n                false\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n    let fn_return_type = f.return_type();\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                $SERIALIZED_ARGS_SLICE_NAME,\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                $SERIALIZED_ARGS_SLICE_NAME,\\n                false\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                serialized_args\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n    let fn_return_type = f.return_type();\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                $SERIALIZED_ARGS_SLICE_NAME,\\n                false\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n    let fn_return_type = f.return_type();\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                $SERIALIZED_ARGS_SLICE_NAME,\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                $SERIALIZED_ARGS_SLICE_NAME,\\n                false\\n            )\\n        }\\n    }\\n}\\n\\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\\n        create_stub_base(f);\\n\\n    quote {\\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\\n            $serialized_args_slice_construction\\n            let selector = $FROM_FIELD($fn_selector);\\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\\n                self.target_contract,\\n                selector,\\n                $fn_name_str,\\n                serialized_args\\n            )\\n        }\\n    }\\n}\\n"},"113":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\\n    notes::NOTES,\\n    utils::{\\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\\n        module_has_storage,\\n    },\\n};\\nuse protocol_types::meta::generate_serialize_to_fields;\\nuse std::meta::type_of;\\n\\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\\n    // Private Kernel Circuit.\\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\\n    // about the execution context (e.g. the caller).\\n    let original_params = f.parameters();\\n    f.set_parameters(&[(\\n        quote { inputs },\\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\\n    )]\\n        .append(original_params));\\n\\n    let mut body = f.body().as_block().unwrap();\\n\\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we\'ve received\\n    // the correct values.\\n    // TODO: Optimize args_hasher for small number of arguments\\n    let args_hasher_name = quote { args_hasher };\\n    let args_hasher = original_params.fold(\\n        quote {\\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n        },\\n        |args_hasher, param: (Quoted, Type)| {\\n            let (name, typ) = param;\\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\\n            quote {\\n                $args_hasher\\n                $appended_arg\\n            }\\n        },\\n    );\\n\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\\n    // and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\\n    // circuit expects.\\n    let return_value_var_name = quote { macro__returned__values };\\n\\n    let return_value_type = f.return_type();\\n    let return_value = if body.len() == 0 {\\n        quote {}\\n    } else if return_value_type != type_of(()) {\\n        // The original return value is passed to a second args hasher which the context receives.\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        let return_value = last_body_expr.quoted();\\n        let return_value_assignment =\\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\\n        let return_hasher_name = quote { return_hasher };\\n        let return_value_into_hasher =\\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\\n\\n        body = body_without_return;\\n\\n        quote {\\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n            $return_value_assignment\\n            $return_value_into_hasher\\n            context.set_return_hash($return_hasher_name);\\n        }\\n    } else {\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        if !last_body_expr.has_semicolon()\\n            & last_body_expr.as_for().is_none()\\n            & last_body_expr.as_assert().is_none()\\n            & last_body_expr.as_for_range().is_none()\\n            & last_body_expr.as_assert_eq().is_none()\\n            & last_body_expr.as_let().is_none() {\\n            let unused_return_value_name = f\\"_{return_value_var_name}\\".quoted_contents();\\n            body = body_without_return.push_back(\\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\\n            );\\n        }\\n        quote {}\\n    };\\n\\n    let context_finish = quote { context.finish() };\\n\\n    let to_prepend = quote {\\n        $args_hasher\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n        $note_discovery_call\\n    };\\n\\n    let to_append = quote {\\n        $return_value\\n        $mark_as_initialized\\n        $context_finish\\n    };\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n    f.set_return_type(\\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\\n            .as_type(),\\n    );\\n    f.set_return_data();\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\\n    let original_params = f.parameters();\\n    let args_len = original_params\\n        .map(|(name, typ): (Quoted, Type)| {\\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\\n        })\\n        .fold(0, |acc: u32, val: u32| acc + val);\\n\\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\\n        // We start from 1 because we skip the selector for the dispatch function.\\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\\n        dep::aztec::hash::hash_args_array(serialized_args)\\n        });\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n        // referenced. We instead ignore \'unused variable\' warnings for it.\\n        quote {\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n    };\\n\\n    let to_append = quote {\\n        $mark_as_initialized\\n    };\\n\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n\\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\\n    // bytecode.\\n    f.set_unconstrained(true);\\n    f.set_return_public(true);\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\\n    // Top-level unconstrained fns are contract entrypoints, but they\'re not explicitly designated in any way. They\'re\\n    // the fallback case for a function that matches no other rules.\\n    // TODO(#12743): improve this\\n\\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\\n    // public, but which *are* contract entrypoints (i.e. they\'re not opting out via the #[test] or\\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\\n        !is_fn_private(f)\\n            & !is_fn_public(f)\\n            & !f.has_named_attribute(\\"contract_library_method\\")\\n            & !f.has_named_attribute(\\"test\\")\\n    });\\n\\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\\n    // https://github.com/noir-lang/noir/issues/7714). We can\'t simply print a message since that\'d otherwise break the\\n    // output of utils such as `nargo test --list-tests`.\\n    // // We don\'t expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr\'s\\n    // // #[private] macro, possibly resulting in a non-standard interface).\\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n    //     !f.is_unconstrained()\\n    // }) {\\n    //     let name = f.name();\\n    //     warn(\\n    //         f\\"found private contract function \'{name}\' which does not have the #[private] attribute - make sure you know what you\'re doing!\\",\\n    //     );\\n    // }\\n\\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n        f.is_unconstrained()\\n    }) {\\n        transform_top_level_unconstrained(f);\\n    }\\n}\\n\\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $storage_init\\n        $note_discovery_call\\n    };\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\\n    f.set_return_public(true);\\n    f.set_body(modified_body);\\n}\\n\\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called internally\\";\\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\\n}\\n\\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called statically\\";\\n    if is_fn_private(f) {\\n        // Here `context` is of type context::PrivateContext\\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\\n    } else {\\n        // Here `context` is of type context::PublicContext\\n        quote { assert(context.is_static_call(), $assertion_message); }\\n    }\\n}\\n\\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\\n/// available for the current execution.\\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\\n    quote {\\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\\n        /// safe to call.\\n        unsafe {\\n            dep::aztec::discovery::discover_new_notes(\\n                context.this_address(),\\n                _compute_note_hash_and_nullifier,\\n            );\\n        };\\n    }\\n}\\n"},"114":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/mod.nr","source":"pub mod dispatch;\\npub mod functions;\\npub mod utils;\\npub mod notes;\\npub mod storage;\\npub mod events;\\n\\nuse functions::{\\n    stub_registry,\\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\\n};\\nuse notes::{generate_note_export, NOTES};\\nuse storage::STORAGE_LAYOUT_NAME;\\n\\nuse dispatch::generate_public_dispatch;\\nuse utils::{get_trait_impl_method, module_has_storage};\\n\\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\\n\\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\\npub comptime fn aztec(m: Module) -> Quoted {\\n    let interface = generate_contract_interface(m);\\n\\n    find_and_transform_top_level_unconstrained_fns(m);\\n\\n    let contract_library_method_compute_note_hash_and_nullifier =\\n        generate_contract_library_method_compute_note_hash_and_nullifier();\\n    let process_log = generate_process_log();\\n    let note_exports = generate_note_exports();\\n    let public_dispatch = generate_public_dispatch(m);\\n    let sync_notes = generate_sync_notes();\\n\\n    quote {\\n        $note_exports\\n        $interface\\n        $contract_library_method_compute_note_hash_and_nullifier\\n        $process_log\\n        $public_dispatch\\n        $sync_notes\\n    }\\n}\\n\\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\\n    let module_name = m.name();\\n    let contract_stubs = stub_registry::get(m);\\n    let fn_stubs_quote = if contract_stubs.is_some() {\\n        contract_stubs.unwrap().join(quote {})\\n    } else {\\n        quote {}\\n    };\\n\\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\\n    let storage_layout_getter = if has_storage_layout {\\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\\n        quote {\\n            pub fn storage_layout() -> StorageLayoutFields {\\n                $storage_layout_name.fields\\n            }\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    let library_storage_layout_getter = if has_storage_layout {\\n        quote {\\n            #[contract_library_method]\\n            $storage_layout_getter\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    quote {\\n        pub struct $module_name {\\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\\n        }\\n\\n        impl $module_name {\\n            $fn_stubs_quote\\n\\n            pub fn at(\\n                addr: aztec::protocol_types::address::AztecAddress\\n            ) -> Self {\\n                Self { target_contract: addr }\\n            }\\n\\n            pub fn interface() -> Self {\\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n            }\\n\\n            $storage_layout_getter\\n        }\\n\\n        #[contract_library_method]\\n        pub fn at(\\n            addr: aztec::protocol_types::address::AztecAddress\\n        ) -> $module_name {\\n            $module_name { target_contract: addr }\\n        }\\n\\n        #[contract_library_method]\\n        pub fn interface() -> $module_name {\\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n        }\\n\\n        $library_storage_layout_getter\\n\\n    }\\n}\\n\\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        let max_note_packed_len = notes.fold(\\n            0,\\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\\n                if len > acc {\\n                    len\\n                } else {\\n                    acc\\n                }\\n            },\\n        );\\n\\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\\n            panic(\\n                f\\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\\",\\n            );\\n        }\\n\\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\\n\\n        let mut if_note_type_id_match_statements_list = &[];\\n        for i in 0..notes.len() {\\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\\n\\n            let get_note_type_id = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteType },\\n                quote { get_id },\\n            );\\n            let unpack = get_trait_impl_method(\\n                typ,\\n                quote { crate::protocol_types::traits::Packable<_> },\\n                quote { unpack },\\n            );\\n\\n            let compute_note_hash = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_note_hash },\\n            );\\n\\n            let compute_nullifier_unconstrained = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_nullifier_unconstrained },\\n            );\\n\\n            let if_or_else_if = if i == 0 {\\n                quote { if }\\n            } else {\\n                quote { else if }\\n            };\\n\\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\\n                quote {\\n                    $if_or_else_if note_type_id == $get_note_type_id() {\\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\\n                        // length, since we\'re about to interpret it\'s raw storage as a fixed-size array by calling the\\n                        // unpack function on it.\\n                        let expected_len = $packed_note_length;\\n                        let actual_len = packed_note.len();\\n                        assert(\\n                            actual_len == expected_len,\\n                            f\\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\\"\\n                        );\\n\\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n\\n                        let note_hash = $compute_note_hash(note, storage_slot);\\n    \\n                        // The note discovery process finds settled notes, that is, notes that were created in prior\\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n                            aztec::note::retrieved_note::RetrievedNote{ \\n                                note, \\n                                contract_address, \\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \\n                            }, \\n                            storage_slot,\\n                        );\\n\\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\\n\\n                        Option::some(\\n                            aztec::discovery::NoteHashAndNullifier {\\n                                note_hash, inner_nullifier\\n                            }\\n                        )\\n                    }\\n                },\\n            );\\n        }\\n\\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\\n\\n        quote {\\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\\n            /// tree with `nonce`.\\n            ///\\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\\n            /// and `attempt_note_discovery`.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                storage_slot: Field,\\n                note_type_id: Field,\\n                contract_address: aztec::protocol_types::address::AztecAddress,\\n                nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                $if_note_type_id_match_statements\\n                else {\\n                    Option::none()\\n                }\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            /// This contract does not use private notes, so this function should never be called as it will\\n            /// unconditionally fail.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                _storage_slot: Field,\\n                _note_type_id: Field,\\n                _contract_address: aztec::protocol_types::address::AztecAddress,\\n                _nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_process_log() -> Quoted {\\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\\n    // and perform note discovery of either private notes or partial notes.\\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\\n    // that function.\\n\\n    // We\'ll produce the entire body of the function in one go and then insert it into the function.\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        quote {\\n            unconstrained fn process_log(\\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                tx_hash: Field,\\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                first_nullifier_in_tx: Field,\\n                recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n                // unconstrained execution context since it will not be available otherwise.\\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n                // TODO(#10727): allow other contracts to process logs and deliver notes\\n                let contract_address = context.this_address();\\n\\n                aztec::discovery::private_logs::do_process_log(\\n                    contract_address,\\n                    log_ciphertext,\\n                    tx_hash,\\n                    unique_note_hashes_in_tx,\\n                    first_nullifier_in_tx,\\n                    recipient,\\n                    _compute_note_hash_and_nullifier,\\n                );\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            unconstrained fn process_log(\\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                _tx_hash: Field,\\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                _first_nullifier_in_tx: Field,\\n                _recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_note_exports() -> Quoted {\\n    let notes = NOTES.values();\\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it\'s only used when\\n    // generating partial note helper functions.\\n    notes\\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\\n            generate_note_export(s, note_type_id, fields)\\n        })\\n        .join(quote {})\\n}\\n\\ncomptime fn generate_sync_notes() -> Quoted {\\n    let note_discovery_call = create_note_discovery_call();\\n    quote {\\n        unconstrained fn sync_notes() {\\n            // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n            // unconstrained execution context since it will not be available otherwise.\\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n            $note_discovery_call\\n        }\\n    }\\n}\\n"},"116":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr","source":"use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\\n\\nuse super::utils::AsStrQuote;\\nuse super::utils::get_storage_size;\\nuse super::utils::is_note;\\n\\n/// Stores a map from a module to the name of the struct that describes its storage layout.\\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\\n    UHashMap::default();\\n\\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\\n/// should have this macro (or `storage_no_init`) applied to it.\\n/// The contract\'s storage is accessed via the `storage` variable, which will will automatically be made available in\\n/// all functions as an instance of the struct this macro was applied to.\\npub comptime fn storage(s: TypeDefinition) -> Quoted {\\n    // This macro performs three things:\\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\\n    //    functions will have the storage variable injected and initialized via the `init` function.\\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\\n    //    macro.\\n    let mut slot: u32 = 1;\\n    let mut storage_vars_constructors = &[];\\n    let mut storage_layout_fields = &[];\\n    let mut storage_layout_constructors = &[];\\n\\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\\n    //let mut new_storage_fields = &[];\\n    //let context_generic = s.add_generic(\\"Context\\");\\n    for field in s.fields_as_written() {\\n        // FIXME: This doesn\'t handle field types with generics\\n        let (name, typ) = field;\\n        let (storage_field_constructor, storage_size) =\\n            generate_storage_field_constructor(typ, quote { $slot }, false);\\n        storage_vars_constructors =\\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\\n        // a contract.\\n        storage_layout_fields =\\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\\n        storage_layout_constructors = storage_layout_constructors.push_back(\\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\\n        );\\n        //let with_context_generic = add_context_generic(typ, context_generic);\\n        //println(with_context_generic);\\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\\n        slot += storage_size;\\n    }\\n\\n    //s.set_fields(new_storage_fields);\\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\\n    let storage_impl = quote {\\n        impl<Context> Storage<Context> {\\n            fn init(context: Context) -> Self {\\n                Self {\\n                    $storage_vars_constructors\\n                }\\n            }\\n        }\\n    };\\n\\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\\n\\n    let module = s.module();\\n    let module_name = module.name();\\n    let storage_layout_name = f\\"STORAGE_LAYOUT_{module_name}\\".quoted_contents();\\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\\n\\n    quote {\\n        $storage_impl\\n\\n        pub struct StorageLayoutFields {\\n            $storage_layout_fields\\n        }\\n\\n        pub struct StorageLayout<let N: u32> {\\n            pub contract_name: str<N>,\\n            pub fields: StorageLayoutFields\\n        }\\n\\n        #[abi(storage)]\\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\\n            contract_name: $module_name_str,\\n            fields: StorageLayoutFields { $storage_layout_constructors }\\n        };\\n    }\\n}\\n\\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\\n/// allocation. Similarly, no `StorageLayout` struct will be created.\\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\\npub comptime fn storage_no_init(_s: TypeDefinition) {\\n    // All `storage` does is provide the `init` implementation, so we don\'t need to do anything here. Applying this\\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\\n    // the `storage` variable.\\n}\\n\\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\\n/// i.e. how many contiguous storage slots the variable requires.\\ncomptime fn generate_storage_field_constructor(\\n    typ: Type,\\n    slot: Quoted,\\n    parent_is_map: bool,\\n) -> (Quoted, u32) {\\n    assert(\\n        typ.as_data_type().is_some(),\\n        \\"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\\",\\n    );\\n    let (container_struct, generics) = typ.as_data_type().unwrap();\\n    let struct_name = container_struct.name();\\n\\n    if is_storage_map(typ) {\\n        // Map state variables recursively initialize their contents - this includes nested maps.\\n        let (value_constructor, _) =\\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\\n    } else {\\n        let storage_size = if parent_is_map {\\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\\n            // in slots very far away from one another.\\n            1\\n        } else {\\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\\n            let stored_struct = container_struct_generics[0];\\n\\n            if is_note(stored_struct) {\\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\\n                // identifier.\\n                1\\n            } else {\\n                get_storage_size(typ)\\n            }\\n        };\\n\\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\\n        (quote { $struct_name::new(context, $slot)}, storage_size)\\n    }\\n}\\n\\n/// Returns true if `typ` is `state_vars::map::Map`.\\ncomptime fn is_storage_map(typ: Type) -> bool {\\n    if typ.as_data_type().is_some() {\\n        let (def, generics) = typ.as_data_type().unwrap();\\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\\n            let maybe_key = generics[0];\\n            let maybe_value = generics[1];\\n            let maybe_context = generics[2];\\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\\n        } else {\\n            quote {()}.as_type()\\n        };\\n        typ == maybe_map\\n    } else {\\n        false\\n    }\\n}\\n\\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\\n    let (def, mut generics) = typ.as_data_type().expect(\\n        f\\"Storage containers must be generic structs of the form `Container<..., Context>`\\",\\n    );\\n    let name = def.name();\\n\\n    if is_storage_map(typ) {\\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\\n        generics[generics.len() - 1] = context_generic;\\n    } else {\\n        generics[generics.len() - 1] = context_generic;\\n    }\\n\\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\\n    quote { $name<$generics> }.as_type()\\n}\\n"},"134":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> [Field; 2] {}\\n\\npub unconstrained fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> (u32, Field) {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n    );\\n\\n    let mut reader = Reader::new(fields);\\n    let end_side_effect_counter = reader.read_u32();\\n    let returns_hash = reader.read();\\n\\n    (end_side_effect_counter, returns_hash)\\n}\\n"},"135":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\\n/// data was already stored at this slot, it is overwritten.\\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\\nwhere\\n    T: Serialize<N>,\\n{\\n    let serialized = value.serialize();\\n    store_oracle(contract_address, slot, serialized);\\n}\\n\\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\\n/// nothing was stored at the given slot.\\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\\nwhere\\n    T: Deserialize<N>,\\n{\\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\\n}\\n\\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\\n    delete_oracle(contract_address, slot);\\n}\\n\\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\\npub unconstrained fn copy(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {\\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\\n}\\n\\n#[oracle(storeCapsule)]\\nunconstrained fn store_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    values: [Field; N],\\n) {}\\n\\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\\n/// have.\\n///\\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\\n#[oracle(loadCapsule)]\\nunconstrained fn load_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    array_len: u32,\\n) -> Option<[Field; N]> {}\\n\\n#[oracle(deleteCapsule)]\\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\\n\\n#[oracle(copyCapsule)]\\nunconstrained fn copy_oracle(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {}\\n\\nmod test {\\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\\n    // oracles are hooked up correctly.\\n\\n    use crate::{\\n        oracle::capsules::{copy, delete, load, store},\\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\\n    };\\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        let env = TestEnvironment::new();\\n        env.contract_address()\\n    }\\n\\n    global SLOT: Field = 1;\\n\\n    #[test]\\n    unconstrained fn stores_and_loads() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\\n    }\\n\\n    #[test]\\n    unconstrained fn store_overwrites() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        let new_value = MockStruct::new(7, 8);\\n        store(contract_address, SLOT, new_value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\\n    }\\n\\n    #[test]\\n    unconstrained fn loads_empty_slot() {\\n        let contract_address = setup();\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_stored_value() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n        delete(contract_address, SLOT);\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_empty_slot() {\\n        let contract_address = setup();\\n\\n        delete(contract_address, SLOT);\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_non_overlapping_values() {\\n        let contract_address = setup();\\n\\n        let src = 5;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 10;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 1;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 2;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 2;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 1;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\\n    }\\n\\n    #[test(should_fail_with = \\"copy empty slot\\")]\\n    unconstrained fn cannot_copy_empty_values() {\\n        let contract_address = setup();\\n\\n        copy(contract_address, SLOT, SLOT, 1);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_store_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let value = MockStruct::new(5, 6);\\n        store(other_contract_address, SLOT, value);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_load_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_delete_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        delete(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_copy_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        copy(other_contract_address, SLOT, SLOT, 0);\\n    }\\n}\\n"},"137":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"138":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr","source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\\npub fn store(values: [Field]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\\n}\\n\\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\\n    let _ = store_in_execution_cache_oracle(values);\\n}\\n\\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\\n    load_from_execution_cache_oracle(hash)\\n}\\n\\n#[oracle(storeInExecutionCache)]\\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\\n\\n#[oracle(loadFromExecutionCache)]\\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\\n"},"148":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr","source":"use crate::discovery::MAX_NOTE_PACKED_LEN;\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\\n};\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\\n/// available for later querying via the `get_notes` oracle.\\npub unconstrained fn sync_notes() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n\\n/// Informs PXE of a note\'s existence so that it can later be retrieved by the `getNotes` oracle. The note will be\\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\\n///\\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\\n///\\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\\n/// other accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized.\\n///\\n/// Returns true if the note was successfully delivered and added to PXE\'s database.\\npub unconstrained fn deliver_note(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {\\n    deliver_note_oracle(\\n        contract_address,\\n        storage_slot,\\n        nonce,\\n        packed_note,\\n        note_hash,\\n        nullifier,\\n        tx_hash,\\n        recipient,\\n    )\\n}\\n\\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\\n/// is the data required in order to discover notes that are being delivered in a log.\\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\\n// log.\\npub struct LogWithTxData {\\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\\n    pub tx_hash: Field,\\n    /// The array of new note hashes created by `tx_hash`\\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    /// The first nullifier created by `tx_hash`\\n    pub first_nullifier_in_tx: Field,\\n}\\n\\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\\n/// the tag is the first field in the log\'s content. Returns `Option::none` if no such log exists. Throws if more than\\n/// one log with that tag exists.\\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\\n// TODO(#11627): handle multiple logs with the same tag.\\n// TODO(#10273): improve contract siloing of logs, don\'t introduce an extra field.\\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\\n    get_log_by_tag_oracle(tag)\\n}\\n\\n#[oracle(deliverNote)]\\nunconstrained fn deliver_note_oracle(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {}\\n\\n#[oracle(getLogByTag)]\\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\\n"},"149":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{\\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n    traits::{Deserialize, FromField, Packable},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            packed_note,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\\n    // call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\\npub fn notify_created_nullifier(nullifier: Field) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\\n    // call.\\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _packed_note: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\\n    let _ = notify_created_nullifier_oracle(nullifier);\\n}\\n\\n#[oracle(notifyCreatedNullifier)]\\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\\n) -> [Option<RetrievedNote<Note>>; S]\\nwhere\\n    Note: NoteType + Packable<N>,\\n{\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let maybe_nonce = fields[read_offset];\\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\\n            let packed_note = array::subarray(fields, read_offset + 2);\\n\\n            let note = Note::unpack(packed_note);\\n            let retrieved_note = RetrievedNote {\\n                note,\\n                contract_address,\\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\\n            };\\n\\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n"},"154":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\\n\\n// docs:start:map\\npub struct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V\\n    where\\n        K: ToField,\\n    {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"164":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr","source":"use dep::protocol_types::{\\n    shared_mutable::{ScheduledDelayChange, ScheduledValueChange, SharedMutableValues},\\n    traits::Packable,\\n};\\n\\nuse crate::{\\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\\n    state_vars::storage::Storage,\\n    utils::with_hash::WithHash,\\n};\\n\\nmod test;\\n\\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n\\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\\n// slots to this state variable.\\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\\nwhere\\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\\n{\\n    fn get_storage_slot(self) -> Field {\\n        self.storage_slot\\n    }\\n}\\n\\n// SharedMutable<T> stores a value of type T that is:\\n//  - publicly known (i.e. unencrypted)\\n//  - mutable in public\\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\\n//    another nor needing to coordinate)\\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\\n// `schedule_delay_change`.\\nimpl<T, let INITIAL_DELAY: u32, let N: u32, Context> SharedMutable<T, INITIAL_DELAY, Context>\\nwhere\\n    T: Packable<N> + Eq,\\n{\\n    pub fn new(context: Context, storage_slot: Field) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Self { context, storage_slot }\\n    }\\n}\\n\\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\\nwhere\\n    T: Packable<N> + Eq,\\n{\\n\\n    pub fn schedule_value_change(self, new_value: T) {\\n        let _value_change = self.schedule_and_return_value_change(new_value);\\n    }\\n\\n    pub fn schedule_and_return_value_change(self, new_value: T) -> ScheduledValueChange<T> {\\n        let mut value_change = self.read_value_change();\\n        let delay_change = self.read_delay_change();\\n\\n        let block_number = self.context.block_number() as u32;\\n        let current_delay = delay_change.get_current(block_number);\\n\\n        // TODO: make this configurable\\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\\n        let block_of_change = block_number + current_delay;\\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\\n\\n        self.write(value_change, delay_change);\\n\\n        value_change\\n    }\\n\\n    pub fn schedule_delay_change(self, new_delay: u32) {\\n        let mut delay_change = self.read_delay_change();\\n\\n        let block_number = self.context.block_number() as u32;\\n\\n        delay_change.schedule_change(new_delay, block_number);\\n\\n        self.write(self.read_value_change(), delay_change);\\n    }\\n\\n    pub fn get_current_value(self) -> T {\\n        let block_number = self.context.block_number() as u32;\\n        self.read_value_change().get_current_at(block_number)\\n    }\\n\\n    pub fn get_current_delay(self) -> u32 {\\n        let block_number = self.context.block_number() as u32;\\n        self.read_delay_change().get_current(block_number)\\n    }\\n\\n    pub fn get_scheduled_value(self) -> (T, u32) {\\n        self.read_value_change().get_scheduled()\\n    }\\n\\n    pub fn get_scheduled_delay(self) -> (u32, u32) {\\n        self.read_delay_change().get_scheduled()\\n    }\\n\\n    fn read_value_change(self) -> ScheduledValueChange<T> {\\n        // We don\'t read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\\n        let packed = self.context.storage_read(self.storage_slot);\\n        SharedMutableValues::unpack_value_change(packed)\\n    }\\n\\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we\'d\\n        // need to offset the storage slot to get the position where it\'d land.\\n        // We don\'t read ScheduledDelayChange directly by having it implement Packable because\\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\\n        // stored in the same slot).\\n        let packed = self.context.storage_read(self.storage_slot);\\n        SharedMutableValues::<T, INITIAL_DELAY>::unpack_delay_change(packed)\\n    }\\n\\n    fn write(\\n        self,\\n        value_change: ScheduledValueChange<T>,\\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\\n    ) {\\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\\n        // `WithHash`.\\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\\n\\n        self.context.storage_write(self.storage_slot, values);\\n    }\\n}\\n\\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\\nwhere\\n    T: Packable<N> + Eq,\\n{\\n    pub fn get_current_value(self) -> T {\\n        // When reading the current value in private we construct a historical state proof for the public value.\\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\\n        // current delay and any scheduled delay changes.\\n        let (value_change, delay_change, historical_block_number) =\\n            self.historical_read_from_public_storage();\\n\\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\\n        // takes into consideration any scheduled delay changes.\\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\\n        // earlier than what we\'d expect if we only considered the current delay.\\n        let effective_minimum_delay =\\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\\n        let block_horizon =\\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\\n\\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\\n        // historical public value matches the current one, since it can only change after the horizon.\\n        self.context.set_tx_max_block_number(block_horizon);\\n        value_change.get_current_at(historical_block_number)\\n    }\\n\\n    fn historical_read_from_public_storage(\\n        self,\\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\\n        let header = self.context.get_block_header();\\n        let address = self.context.this_address();\\n\\n        let historical_block_number = header.global_variables.block_number as u32;\\n\\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\\n\\n        (values.svc, values.sdc, historical_block_number)\\n    }\\n}\\n\\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext>\\nwhere\\n    T: Packable<N> + Eq,\\n{\\n    pub unconstrained fn get_current_value(self) -> T {\\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\\n            WithHash::unconstrained_public_storage_read(self.context, self.storage_slot);\\n\\n        let block_number = self.context.block_number() as u32;\\n        smv.svc.get_current_at(block_number)\\n    }\\n}\\n"},"176":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\\n/// large enough to fit all of the elements of both the first and second vectors.\\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\\n    a: BoundedVec<T, A_LEN>,\\n    b: BoundedVec<T, B_LEN>,\\n) -> BoundedVec<T, DST_LEN> {\\n    let mut dst = BoundedVec::new();\\n\\n    dst.extend_from_bounded_vec(a);\\n    dst.extend_from_bounded_vec(b);\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::append;\\n\\n    #[test]\\n    unconstrained fn append_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::new();\\n        let b: BoundedVec<_, 14> = BoundedVec::new();\\n\\n        let result: BoundedVec<Field, 5> = append(a, b);\\n\\n        assert_eq(result.len(), 0);\\n        assert_eq(result.storage(), std::mem::zeroed());\\n    }\\n\\n    #[test]\\n    unconstrained fn append_non_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let result: BoundedVec<Field, 8> = append(a, b);\\n\\n        assert_eq(result.len(), 6);\\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\\n    }\\n\\n    #[test(should_fail_with = \\"out of bounds\\")]\\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let _: BoundedVec<Field, 5> = append(a, b);\\n    }\\n}\\n"},"178":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr","source":"pub mod append;\\npub mod collapse;\\npub mod subarray;\\npub mod subbvec;\\n\\npub use append::append;\\npub use collapse::collapse;\\npub use subarray::subarray;\\npub use subbvec::subbvec;\\n\\n// This will eventually be replaced by `BoundedVec::for_each`, once that\'s implemented.\\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\\n    vec: BoundedVec<T, MaxLen>,\\n    f: fn[Env](T, u32) -> (),\\n) {\\n    for i in 0..vec.len() {\\n        f(vec.get_unchecked(i), i);\\n    }\\n}\\n"},"179":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"180":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\\n\\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\\n/// zeroed elements past `len()`).\\n///\\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n///\\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can\'t return just 1 element since 3 remain\\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can\'t return 10 elements since only 7 remain\\n/// ```\\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\\n    offset: u32,\\n) -> BoundedVec<T, DST_MAX_LEN> {\\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\\n    // because we\'re constructing the new storage array as a subarray of the original one (which should have zeroed\\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\\n    // their original length.\\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\\n}\\n\\nmod test {\\n    use super::subbvec;\\n\\n    #[test]\\n    unconstrained fn subbvec_empty() {\\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_complete() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n\\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_partial() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_into_empty() {\\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_offset_past_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_insufficient_dst_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // We\'re not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\\n        // for the capacity to reduce, but not the length (other than by len - offset).\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // subbvec does not supprt capacity increases\\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // This effectively requests a capacity increase, since there\'d be just one element plus the 5 empty slots,\\n        // which is less than 7.\\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\\n    }\\n}\\n"},"191":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr","source":"use crate::{\\n    context::{PublicContext, UnconstrainedContext},\\n    history::public_storage::PublicStorageHistoricalRead,\\n    oracle,\\n};\\nuse dep::protocol_types::{\\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\\n};\\n\\n/// A struct that allows for efficient reading of value `T` from public storage in private.\\n///\\n/// The efficient reads are achieved by verifying large values through a single hash check\\n/// and then proving inclusion only of the hash in public storage. This reduces the number\\n/// of required tree inclusion proofs from `N` to 1.\\n///\\n/// # Type Parameters\\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\\n/// - `N`: The number of field elements required to pack values of type `T`\\npub struct WithHash<T, let N: u32> {\\n    value: T,\\n    packed: [Field; N],\\n    hash: Field,\\n}\\n\\nimpl<T, let N: u32> WithHash<T, N>\\nwhere\\n    T: Packable<N> + Eq,\\n{\\n    pub fn new(value: T) -> Self {\\n        let packed = value.pack();\\n        Self { value, packed, hash: poseidon2_hash(packed) }\\n    }\\n\\n    pub fn get_value(self) -> T {\\n        self.value\\n    }\\n\\n    pub fn get_hash(self) -> Field {\\n        self.hash\\n    }\\n\\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\\n        context.storage_read(storage_slot)\\n    }\\n\\n    pub unconstrained fn unconstrained_public_storage_read(\\n        context: UnconstrainedContext,\\n        storage_slot: Field,\\n    ) -> T {\\n        context.storage_read(storage_slot)\\n    }\\n\\n    pub fn historical_public_storage_read(\\n        header: BlockHeader,\\n        address: AztecAddress,\\n        storage_slot: Field,\\n    ) -> T {\\n        let historical_block_number = header.global_variables.block_number as u32;\\n\\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\\n        let hint = WithHash::new(\\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\\n            unsafe {\\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\\n            },\\n        );\\n\\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\\n\\n        if hash != 0 {\\n            assert_eq(hash, hint.get_hash(), \\"Hint values do not match hash\\");\\n        } else {\\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\\n            // (i.e. the default value for public storage) as well.\\n            assert_eq(\\n                hint.get_value(),\\n                T::unpack(std::mem::zeroed()),\\n                \\"Non-zero hint for zero hash\\",\\n            );\\n        };\\n\\n        hint.get_value()\\n    }\\n}\\n\\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn pack(self) -> [Field; N + 1] {\\n        let mut result: [Field; N + 1] = std::mem::zeroed();\\n        for i in 0..N {\\n            result[i] = self.packed[i];\\n        }\\n        result[N] = self.hash;\\n\\n        result\\n    }\\n\\n    fn unpack(packed: [Field; N + 1]) -> Self {\\n        let mut value_packed: [Field; N] = std::mem::zeroed();\\n        for i in 0..N {\\n            value_packed[i] = packed[i];\\n        }\\n        let hash = packed[N];\\n\\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\\n    }\\n}\\n\\nmod test {\\n    use crate::{\\n        oracle::random::random,\\n        test::{\\n            helpers::{cheatcodes, test_environment::TestEnvironment},\\n            mocks::mock_struct::MockStruct,\\n        },\\n        utils::with_hash::WithHash,\\n    };\\n    use dep::protocol_types::hash::poseidon2_hash;\\n    use dep::protocol_types::traits::{Packable, ToField};\\n    use dep::std::{mem, test::OracleMock};\\n\\n    global storage_slot: Field = 47;\\n\\n    #[test]\\n    unconstrained fn create_and_recover() {\\n        let value = MockStruct { a: 5, b: 3 };\\n        let value_with_hash = WithHash::new(value);\\n        let recovered = WithHash::unpack(value_with_hash.pack());\\n\\n        assert_eq(recovered.value, value);\\n        assert_eq(recovered.packed, value.pack());\\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\\n    }\\n\\n    #[test]\\n    unconstrained fn read_uninitialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        let block_header = env.private().historical_header;\\n        let address = env.contract_address();\\n\\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            block_header,\\n            address,\\n            storage_slot,\\n        );\\n\\n        // We should get zeroed value\\n        let expected: MockStruct = mem::zeroed();\\n        assert_eq(result, expected);\\n    }\\n\\n    #[test]\\n    unconstrained fn read_initialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        let value = MockStruct { a: 5, b: 3 };\\n        let value_with_hash = WithHash::new(value);\\n\\n        // We write the value with hash to storage\\n        cheatcodes::direct_storage_write(\\n            env.contract_address(),\\n            storage_slot,\\n            value_with_hash.pack(),\\n        );\\n\\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\\n        env.advance_block_by(1);\\n\\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            env.private().historical_header,\\n            env.contract_address(),\\n            storage_slot,\\n        );\\n\\n        assert_eq(result, value);\\n    }\\n\\n    #[test(should_fail_with = \\"Non-zero hint for zero hash\\")]\\n    unconstrained fn test_bad_hint_uninitialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        env.advance_block_to(6);\\n\\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\\n\\n        let block_header = env.private().historical_header;\\n        let address = env.contract_address();\\n\\n        // Mock the oracle to return a non-zero hint/packed value\\n        let _ = OracleMock::mock(\\"storageRead\\")\\n            .with_params((\\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\\n                value_packed.len(),\\n            ))\\n            .returns(value_packed)\\n            .times(1);\\n\\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            block_header,\\n            address,\\n            storage_slot,\\n        );\\n    }\\n\\n    #[test(should_fail_with = \\"Hint values do not match hash\\")]\\n    unconstrained fn test_bad_hint_initialized_value() {\\n        let mut env = TestEnvironment::new();\\n\\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\\n\\n        // We write the value to storage\\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\\n\\n        // Now we write incorrect hash to the hash storage slot\\n        let incorrect_hash = random();\\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\\n        cheatcodes::direct_storage_write(\\n            env.contract_address(),\\n            hash_storage_slot,\\n            [incorrect_hash],\\n        );\\n\\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\\n        env.advance_block_by(1);\\n\\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\\n            env.private().historical_header,\\n            env.contract_address(),\\n            storage_slot,\\n        );\\n    }\\n}\\n"},"252":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\\n        MAX_PROTOCOL_CONTRACTS,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_class_id(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_protocol_contract(self) -> bool {\\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"255":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\\n\\n// Partial address\\npub struct PartialAddress {\\n    pub inner: Field,\\n}\\n\\nimpl ToField for PartialAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\\n        PartialAddress { inner: fields[0] }\\n    }\\n}\\n\\nimpl PartialAddress {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(\\n        contract_class_id: ContractClassId,\\n        salt: Field,\\n        initialization_hash: Field,\\n        deployer: AztecAddress,\\n    ) -> Self {\\n        PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\\n        )\\n    }\\n\\n    pub fn compute_from_salted_initialization_hash(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n    ) -> Self {\\n        PartialAddress::from_field(poseidon2_hash_with_separator(\\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\\n        ))\\n    }\\n\\n    pub fn to_field(self) -> Field {\\n        self.inner\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.to_field() == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"257":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\\n    hash::poseidon2_hash_with_separator, traits::ToField,\\n};\\n\\n// Salted initialization hash. Used in the computation of a partial address.\\npub struct SaltedInitializationHash {\\n    pub inner: Field,\\n}\\n\\nimpl ToField for SaltedInitializationHash {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl SaltedInitializationHash {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\\n            [salt, initialization_hash, deployer.to_field()],\\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\\n        ))\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"261":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\\n\\npub struct ContractClassId {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for ContractClassId {\\n    fn eq(self, other: ContractClassId) -> bool {\\n        other.inner == self.inner\\n    }\\n}\\n\\nimpl ToField for ContractClassId {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for ContractClassId {\\n    fn from_field(value: Field) -> Self {\\n        Self { inner: value }\\n    }\\n}\\n\\nimpl Serialize<1> for ContractClassId {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<1> for ContractClassId {\\n    fn deserialize(fields: [Field; 1]) -> Self {\\n        Self { inner: fields[0] }\\n    }\\n}\\n\\nimpl Empty for ContractClassId {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\n// Implement the Packable trait so ContractClassId can be stored in contract\'s storage.\\nimpl Packable<1> for ContractClassId {\\n    fn pack(self) -> [Field; 1] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; 1]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl ContractClassId {\\n    pub fn compute(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field,\\n    ) -> Self {\\n        let hash = crate::hash::poseidon2_hash_with_separator(\\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\\n            GENERATOR_INDEX__CONTRACT_LEAF,\\n        ); // TODO(@spalladino): Update generator index\\n        ContractClassId::from_field(hash)\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"269":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"270":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        contract_class_log::ContractClassLog,\\n        function_selector::FunctionSelector,\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, ToField},\\n    utils::{\\n        arrays::{array_concat, unsafe_padded_array_length},\\n        field::{field_from_bytes, field_from_bytes_32_trunc},\\n    },\\n};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_field(\\n    contract_address: AztecAddress,\\n    first_field: Field,\\n) -> Field {\\n    poseidon2_hash([contract_address.to_field(), first_field])\\n}\\n\\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\\n    if contract_class_log.contract_address.is_zero() {\\n        contract_class_log\\n    } else {\\n        let mut log = contract_class_log;\\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\\n            contract_class_log.contract_address,\\n            log.log.fields[0],\\n        );\\n        log\\n    }\\n}\\n\\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\\n    let array = contract_class_log.log.fields;\\n    // Safety: The below length is constrained in the base rollup.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    if length == 0 {\\n        0\\n    } else {\\n        poseidon2_hash(array)\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a u128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"284":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use super::traits::{Deserialize, Packable, Serialize};\\n\\n/// Returns the typed expression of a trait method implementation.\\n///\\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\\n/// warnings that the trait implementation is not in scope).\\n///\\n/// # Note\\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\\ncomptime fn get_trait_impl_method(\\n    typ: Type,\\n    target_trait: Quoted,\\n    target_method: Quoted,\\n) -> TypedExpr {\\n    let trait_constraint = target_trait.as_trait_constraint();\\n    typ\\n        .get_trait_impl(trait_constraint)\\n        .expect(f\\"Could not find impl for {target_trait} for type {typ}\\")\\n        .methods()\\n        .filter(|m| m.name() == target_method)[0]\\n        .as_typed_expr()\\n}\\n\\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\\n///\\n/// # Parameters\\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\\"values\\"`).\\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\\n/// and `Serialize` trait for more information about the difference between packing and serialization).\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\\n///\\n/// # Nested Struct Example\\n/// Given the following setup:\\n/// ```\\n/// struct UintNote {\\n///     value: u128,\\n///     owner: AztecAddress,\\n///     randomness: Field,\\n/// }\\n///\\n/// struct AztecAddress {\\n///     inner: Field,\\n/// }\\n/// ```\\n///\\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\\n/// ```\\n/// UintNote {\\n///     value: fields[0] as u128,\\n///     owner: AztecAddress {\\n///         inner: fields[1],\\n///     },\\n///     randomness: fields[2],\\n/// }\\n/// ```\\n/// # Nested Struct Example with Unpacking\\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\\n///   the result we get is:\\n/// ```\\n/// UintNote {\\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\\n/// }\\n/// ```\\n///\\n/// # Panics\\n/// - If the deserialization logic encounters a type it does not support.\\n/// - If an incorrect number of fields are consumed when deserializing a string.\\npub comptime fn generate_deserialize_from_fields(\\n    name: Quoted,\\n    typ: Type,\\n    field_array_name: Quoted,\\n    num_already_consumed: u32,\\n    should_unpack: bool,\\n) -> (Quoted, u32) {\\n    let mut result = quote {};\\n    // Counter for the number of fields consumed\\n    let mut consumed_counter: u32 = 0;\\n\\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n    if (should_unpack & typ.implements(packable_constraint)) {\\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\\n        let mut packed_fields_quotes = &[];\\n        for i in 0..packed_len {\\n            let index_in_field_array = i + num_already_consumed;\\n            packed_fields_quotes =\\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\\n        }\\n        let packed_fields = packed_fields_quotes.join(quote {,});\\n\\n        // Now we call unpack on the type\\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\\n        result = quote { $unpack_method([ $packed_fields ]) };\\n\\n        consumed_counter = packed_len;\\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\\n        // The field is a primitive so we just reference it in the field array\\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\\n        consumed_counter = 1;\\n    } else if typ.as_data_type().is_some() {\\n        // The field is a struct so we iterate over each struct field and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (nested_def, generics) = typ.as_data_type().unwrap();\\n        let nested_name = nested_def.name();\\n        let mut deserialized_fields_list = &[];\\n\\n        // Iterate over each field in the struct\\n        for field in nested_def.fields(generics) {\\n            let (field_name, field_type) = field;\\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                field_name,\\n                field_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\\n            deserialized_fields_list =\\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\\n        }\\n\\n        // We can construct the struct from the deserialized fields\\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\\n        result = quote {\\n                $nested_name {\\n                    $deserialized_fields\\n                }\\n            };\\n    } else if typ.as_array().is_some() {\\n        // The field is an array so we iterate over each element and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (element_type, array_len) = typ.as_array().unwrap();\\n        let array_len = array_len.as_constant().unwrap();\\n        let mut array_fields_list = &[];\\n\\n        // Iterate over each element in the array\\n        for _ in 0..array_len {\\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                element_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            array_fields_list = array_fields_list.push_back(deserialized_field);\\n        }\\n\\n        // We can construct the array from the deserialized fields\\n        let array_fields = array_fields_list.join(quote {,});\\n        result = quote { [ $array_fields ] };\\n    } else if typ.as_str().is_some() {\\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\\n        // to `generate_deserialize_from_fields`.\\n        let length_type = typ.as_str().unwrap();\\n        let str_len = length_type.as_constant().unwrap();\\n        let mut byte_list = &[];\\n\\n        // Iterate over each character in the string\\n        for _ in 0..str_len {\\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                quote {u8}.as_type(),\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n\\n            // We should consume just one field in the recursion so we sanity check that\\n            assert_eq(\\n                num_consumed_in_recursion,\\n                1,\\n                \\"Incorrect number of fields consumed in string deserialization\\",\\n            );\\n\\n            // We increment the consumed counter by 1 as we have consumed one field\\n            consumed_counter += 1;\\n\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `fields[6] as u8`\\n            byte_list = byte_list.push_back(deserialized_field);\\n        }\\n\\n        // We construct the string from the deserialized fields\\n        let bytes = byte_list.join(quote {,});\\n        result = quote { [ $bytes ].as_str_unchecked() };\\n    } else {\\n        panic(\\n            f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n        )\\n    }\\n\\n    (result, consumed_counter)\\n}\\n\\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\\n/// if it does.\\n///\\n/// # Parameters\\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\\n/// - `should_pack`: A boolean indicating whether the type should be packed.\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - A flattened array of `Quoted` field references representing the serialized fields.\\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\\n///\\n/// # Examples\\n///\\n/// ## Struct\\n/// Given the following struct:\\n/// ```rust\\n/// struct MockStruct {\\n///     a: Field,\\n///     b: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing the struct:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\\n/// // Returns:\\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\\n/// ```\\n///\\n/// ## Nested Struct\\n/// For a more complex struct:\\n/// ```rust\\n/// struct NestedStruct {\\n///     m1: MockStruct,\\n///     m2: MockStruct,\\n/// }\\n/// ```\\n///\\n/// Serialization output:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\\n/// // Returns:\\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\\n/// ```\\n///\\n/// ## Array\\n/// For an array type:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\\n/// // Returns:\\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\\n/// ```\\n///\\n/// ## String\\n/// For a string field, where each character is serialized as a `Field`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\\n/// // Returns:\\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\\n/// ```\\n///\\n/// ## Nested Struct with Omitted Field and packing enabled\\n/// - u128 has a `Packable` implementation hence it will be packed.\\n///\\n/// For a more complex struct:\\n/// ```rust\\n/// struct MyStruct {\\n///     value: u128,\\n///     value2: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing while omitting `value2`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\\n/// // Returns:\\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\\n/// ```\\n///\\n/// # Panics\\n/// - If the type is unsupported for serialization.\\n/// - If the provided `typ` contains invalid constants or incompatible structures.\\npub comptime fn generate_serialize_to_fields(\\n    name: Quoted,\\n    typ: Type,\\n    omit: [Quoted],\\n    should_pack: bool,\\n) -> ([Quoted], [Quoted]) {\\n    let mut fields = &[];\\n    let mut aux_vars = &[];\\n\\n    // Proceed if none of the omit rules omits this name\\n    if !omit.any(|to_omit| to_omit == name) {\\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n        let packable_constraint =\\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n        if (should_pack & typ.implements(packable_constraint)) {\\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \\"self.value\\" -> \\"self_value\\").\\n            let name_at_one_token = collapse_to_one_token(name);\\n            let packed_struct_name = f\\"{name_at_one_token}_aux_var\\".quoted_contents();\\n\\n            // We add the individual fields to the fields array\\n            let pack_method = get_trait_impl_method(\\n                typ,\\n                quote { crate::traits::Packable<$packed_len> },\\n                quote { pack },\\n            );\\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\\n            for i in 0..packed_len {\\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\\n            }\\n\\n            // We add the new auxiliary variable to the aux_vars array\\n            aux_vars = aux_vars.push_back(packed_struct);\\n        } else if typ.is_field() {\\n            // For field we just add the value to fields\\n            fields = fields.push_back(name);\\n        } else if typ.as_integer().is_some() | typ.is_bool() {\\n            // For integer and bool we just cast to Field and add the value to fields\\n            fields = fields.push_back(quote { $name as Field });\\n        } else if typ.as_data_type().is_some() {\\n            // For struct we pref\\n            let nested_struct = typ.as_data_type().unwrap();\\n            let params = nested_struct.0.fields(nested_struct.1);\\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\\n                let maybe_prefixed_name = if name == quote {} {\\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\\n                    // argument) --> then we don\'t prefix the name with anything.\\n                    param_name\\n                } else {\\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\\n                    // can typically be `self` when implementing a method on a struct.\\n                    quote { $name.$param_name }\\n                };\\n                generate_serialize_to_fields(\\n                    quote {$maybe_prefixed_name},\\n                    param_type,\\n                    omit,\\n                    should_pack,\\n                )\\n            });\\n            let struct_flattened_fields = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\\n            );\\n            let struct_flattened_aux_vars = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\\n            );\\n            fields = fields.append(struct_flattened_fields);\\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\\n        } else if typ.as_array().is_some() {\\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\\n            let (element_type, array_len) = typ.as_array().unwrap();\\n            let array_len = array_len.as_constant().unwrap();\\n            for i in 0..array_len {\\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\\n                    quote { $name[$i] },\\n                    element_type,\\n                    omit,\\n                    should_pack,\\n                );\\n                fields = fields.append(element_fields);\\n                aux_vars = aux_vars.append(element_aux_vars);\\n            }\\n        } else if typ.as_str().is_some() {\\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\\n            // then we add each byte to fields as a Field\\n            let length_type = typ.as_str().unwrap();\\n            let str_len = length_type.as_constant().unwrap();\\n            let as_member = name.as_expr().unwrap().as_member_access();\\n            let var_name = if as_member.is_some() {\\n                as_member.unwrap().1\\n            } else {\\n                name\\n            };\\n            let as_bytes_name = f\\"{var_name}_as_bytes\\".quoted_contents();\\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\\n            for i in 0..str_len {\\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\\n            }\\n            aux_vars = aux_vars.push_back(as_bytes);\\n        } else {\\n            panic(\\n                f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n            )\\n        }\\n    }\\n    (fields, aux_vars)\\n}\\n\\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\\n/// E.g. \\"self.values[0]\\" -> \\"self_values_0_\\"\\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\\n    let tokens = q.tokens();\\n\\n    let mut single_token = quote {};\\n    for token in tokens {\\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\\n            quote {_}\\n        } else {\\n            token\\n        };\\n        single_token = f\\"{single_token}{new_token}\\".quoted_contents();\\n    }\\n    single_token\\n}\\n\\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let field_serializations = fields.join(quote {,});\\n    let serialized_len = fields.len();\\n    quote {\\n        impl Serialize<$serialized_len> for $typ {\\n            fn serialize(self) -> [Field; $serialized_len] {\\n                $aux_vars_for_serialization\\n                [ $field_serializations ]\\n            }\\n        }\\n    }\\n}\\n\\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let serialized_len = fields.len();\\n    let (deserialized, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\\n    quote {\\n        impl Deserialize<$serialized_len> for $typ {\\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\\n                $deserialized\\n            }\\n        }\\n    }\\n}\\n\\n/// Generates `Packable` implementation for a given struct and returns the packed length.\\n///\\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\\n    let packing_enabled = true;\\n\\n    let typ = s.as_type();\\n    let (fields, aux_vars) =\\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let (unpacked, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\\n\\n    let field_packings = fields.join(quote {,});\\n    let packed_len = fields.len();\\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\\n    (\\n        quote {\\n        impl $packable_trait for $typ {\\n            fn pack(self) -> [Field; $packed_len] {\\n                $aux_vars_for_packing\\n                [ $field_packings ]\\n            }\\n\\n            fn unpack(packed: [Field; $packed_len]) -> Self {\\n                $unpacked\\n            }\\n        }\\n    },\\n        packed_len,\\n    )\\n}\\n\\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\\n    packable_impl\\n}\\n\\n#[derive(Packable, Serialize, Deserialize, Eq)]\\npub struct Smol {\\n    a: Field,\\n    b: Field,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct HasArray {\\n    a: [Field; 2],\\n    b: bool,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct Fancier {\\n    a: Smol,\\n    b: [Field; 2],\\n    c: [u8; 3],\\n    d: str<16>,\\n}\\n\\nfn main() {\\n    assert(false);\\n}\\n\\n#[test]\\nfn smol_test() {\\n    let smol = Smol { a: 1, b: 2 };\\n    let serialized = smol.serialize();\\n    assert(serialized == [1, 2], serialized);\\n    let deserialized = Smol::deserialize(serialized);\\n    assert(deserialized == smol);\\n\\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\\n    let packed = smol.pack();\\n    assert_eq(packed, serialized, \\"Packed does not match serialized\\");\\n}\\n\\n#[test]\\nfn has_array_test() {\\n    let has_array = HasArray { a: [1, 2], b: true };\\n    let serialized = has_array.serialize();\\n    assert(serialized == [1, 2, 1], serialized);\\n    let deserialized = HasArray::deserialize(serialized);\\n    assert(deserialized == has_array);\\n}\\n\\n#[test]\\nfn fancier_test() {\\n    let fancier =\\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \\"metaprogramming!\\" };\\n    let serialized = fancier.serialize();\\n    assert(\\n        serialized\\n            == [\\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\\n            ],\\n        serialized,\\n    );\\n    let deserialized = Fancier::deserialize(serialized);\\n    assert(deserialized == fancier);\\n}\\n"},"287":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"296":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\\n    address::public_keys_hash::PublicKeysHash,\\n    constants::{\\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n    point::POINT_LENGTH,\\n    traits::{Deserialize, Hash, Serialize, ToField},\\n};\\n\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse std::default::Default;\\n\\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\\n\\npub struct PublicKeys {\\n    pub npk_m: NpkM,\\n    pub ivpk_m: IvpkM,\\n    pub ovpk_m: OvpkM,\\n    pub tpk_m: TpkM,\\n}\\n\\npub trait ToPoint {\\n    fn to_point(self) -> Point;\\n}\\n\\npub struct NpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for NpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for NpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\\nimpl Hash for NpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\npub struct IvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for IvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for IvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct OvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl Hash for OvpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\nimpl ToPoint for OvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for OvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct TpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for TpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for TpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\nimpl Default for PublicKeys {\\n    fn default() -> Self {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\\n            },\\n        }\\n    }\\n}\\n\\nimpl Eq for PublicKeys {\\n    fn eq(self, other: PublicKeys) -> bool {\\n        (self.npk_m.inner == other.npk_m.inner)\\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\\n            & (self.tpk_m.inner == other.tpk_m.inner)\\n    }\\n}\\n\\nimpl PublicKeys {\\n    pub fn hash(self) -> PublicKeysHash {\\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\\n            self.serialize(),\\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\\n        ))\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\\n        [\\n            self.npk_m.inner.x,\\n            self.npk_m.inner.y,\\n            self.npk_m.inner.is_infinite as Field,\\n            self.ivpk_m.inner.x,\\n            self.ivpk_m.inner.y,\\n            self.ivpk_m.inner.is_infinite as Field,\\n            self.ovpk_m.inner.x,\\n            self.ovpk_m.inner.y,\\n            self.ovpk_m.inner.is_infinite as Field,\\n            self.tpk_m.inner.x,\\n            self.tpk_m.inner.y,\\n            self.tpk_m.inner.is_infinite as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point {\\n                    x: serialized[0],\\n                    y: serialized[1],\\n                    is_infinite: serialized[2] as bool,\\n                },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point {\\n                    x: serialized[3],\\n                    y: serialized[4],\\n                    is_infinite: serialized[5] as bool,\\n                },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point {\\n                    x: serialized[6],\\n                    y: serialized[7],\\n                    is_infinite: serialized[8] as bool,\\n                },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point {\\n                    x: serialized[9],\\n                    y: serialized[10],\\n                    is_infinite: serialized[11] as bool,\\n                },\\n            },\\n        }\\n    }\\n}\\n\\npub struct AddressPoint {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for AddressPoint {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_public_keys_hash() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let actual = keys.hash();\\n    let expected_public_keys_hash =\\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\\n\\n    assert(actual.to_field() == expected_public_keys_hash);\\n}\\n\\n#[test]\\nunconstrained fn compute_default_hash() {\\n    let keys = PublicKeys::default();\\n\\n    let actual = keys.hash();\\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\\n\\n    assert(actual.to_field() == test_data_default_hash);\\n}\\n\\n#[test]\\nunconstrained fn test_public_keys_serialization() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let serialized = keys.serialize();\\n    let deserialized = PublicKeys::deserialize(serialized);\\n\\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\\n}\\n"},"300":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr","source":"use crate::traits::Empty;\\nuse std::cmp::min;\\n\\nmod test;\\n\\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\\n// schedule a change.\\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\\n// delay to be decreased immediately then it\'d be possible for the state variable to schedule a value change with a\\n// reduced delay, invalidating prior private reads.\\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\\n    // effect. Once initialized, the Option will never be none again.\\n    pub(crate) pre: Option<u32>,\\n    pub(crate) post: Option<u32>,\\n    // Block at which `post` value is used instead of `pre`\\n    pub(crate) block_of_change: u32,\\n}\\n\\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\\n        Self { pre, post, block_of_change }\\n    }\\n\\n    /// Returns the current value of the delay stored in the data structure.\\n    /// This function only returns a meaningful value when called in public with the current block number - for\\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\\n    pub fn get_current(self, current_block_number: u32) -> u32 {\\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\\n        // block of change will use the post value.\\n        if current_block_number < self.block_of_change {\\n            self.pre.unwrap_or(INITIAL_DELAY)\\n        } else {\\n            self.post.unwrap_or(INITIAL_DELAY)\\n        }\\n    }\\n\\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\\n    /// delay. Note that this block may be in the past if the change has already taken place.\\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\\n    pub fn get_scheduled(self) -> (u32, u32) {\\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\\n    }\\n\\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\\n    /// when called in public with the current block number.\\n    /// The block at which the new delay will become effective is determined automatically:\\n    ///  - when increasing the delay, the change is effective immediately\\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\\n    ///    days.\\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\\n        let current = self.get_current(current_block_number);\\n\\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\\n        // shorter than the current one.\\n        let blocks_until_change = if new > current {\\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\\n            // about how quickly a value might be changed (indeed it strengthens them).\\n            0\\n        } else {\\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\\n            // that overall the current delay is respected.\\n            //\\n            //      current                    delay              earliest value block of change\\n            //       block                 block of change         if delay remained unchanged\\n            //  =======N=========================|================================X=================>\\n            //         ^                         ^                                ^\\n            //         |-------------------------|--------------------------------|\\n            //         |   blocks until change               new delay            |\\n            //         ------------------------------------------------------------\\n            //                            current delay\\n            current - new\\n        };\\n\\n        self.pre = Option::some(current);\\n        self.post = Option::some(new);\\n        self.block_of_change = current_block_number + blocks_until_change;\\n    }\\n\\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\\n    /// `max_block_number` transaction property when reading mutable shared state.\\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\\n    /// the current one.\\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\\n        if self.block_of_change <= historical_block_number {\\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\\n            self.post.unwrap_or(INITIAL_DELAY)\\n        } else {\\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\\n            // than the current delay, then that is the effective minimum delay.\\n            //\\n            //       historical\\n            //         block                  delay                  actual earliest value\\n            //           v                block of change              block of change\\n            //  =========NS=====================|=============================X===========Y=====>\\n            //            ^                     ^                             ^           ^\\n            //     earliest block in            |                             |           |\\n            //   which to schedule change       |                             |           |\\n            //           |                      |                             |           |\\n            //           |----------------------|------------------------------           |\\n            //           |         blocks                  new delay                      |\\n            //           |      until change                                              |\\n            //           |                                                                |\\n            //           |----------------------------------------------------------------|\\n            //                        current delay at the earliest block in\\n            //                             which to scheduled value change\\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\\n\\n            min(\\n                self.pre.unwrap_or(INITIAL_DELAY),\\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\\n            )\\n        }\\n    }\\n}\\n\\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\\n    fn eq(self, other: Self) -> bool {\\n        (self.pre == other.pre)\\n            & (self.post == other.post)\\n            & (self.block_of_change == other.block_of_change)\\n    }\\n}\\n\\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\\n    fn empty() -> Self {\\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\\n    }\\n}\\n"},"302":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr","source":"use crate::traits::Empty;\\nuse std::cmp::min;\\n\\nmod test;\\n\\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\\n// both the current value and the smallest block number at which the value might change - this is called the\\n// \'block horizon\'.\\npub struct ScheduledValueChange<T> {\\n    pub(crate) pre: T,\\n    pub(crate) post: T,\\n    // Block at which `post` value is used instead of `pre`\\n    pub(crate) block_of_change: u32,\\n}\\n\\nimpl<T> ScheduledValueChange<T> {\\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\\n        Self { pre, post, block_of_change }\\n    }\\n\\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\\n    /// to construct the proof).\\n    /// Reading in private is only safe if the transaction\'s `max_block_number` property is set to a value lower or\\n    /// equal to the block horizon (see `get_block_horizon()`).\\n    pub fn get_current_at(self, block_number: u32) -> T {\\n        // The post value becomes the current one at the block of change. This means different things in each realm:\\n        // - in public, any transaction that is included in the block of change will use the post value\\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\\n        //   post value (barring any follow-up changes)\\n        if block_number < self.block_of_change {\\n            self.pre\\n        } else {\\n            self.post\\n        }\\n    }\\n\\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\\n    /// value. Note that this block may be in the past if the change has already taken place.\\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\\n    pub fn get_scheduled(self) -> (T, u32) {\\n        (self.post, self.block_of_change)\\n    }\\n\\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\\n    // might not be the current anymore since block of change might have already passed.\\n    pub fn get_previous(self) -> (T, u32) {\\n        (self.pre, self.block_of_change)\\n    }\\n\\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\\n    /// however, then this value is the \'effective minimum delay\' (obtained by calling\\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\\n    /// elapse from the next block until the value changes, regardless of further delay changes.\\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\\n    /// if the transaction\'s `max_block_number` property is set to a value lower or equal to the block horizon computed\\n    /// using the same historical block number.\\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\\n        // block horizon.\\n        if historical_block_number >= self.block_of_change {\\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\\n            // greater or equal to the block of change), and therefore could only happen after the historical block\\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\\n            // that one.\\n            //\\n            //      block of      historical\\n            //       change         block            block horizon\\n            //   =======|=============N===================H===========>\\n            //                         ^                   ^\\n            //                         ---------------------\\n            //                             minimum delay\\n            historical_block_number + minimum_delay\\n        } else {\\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\\n            //      block prior to the earliest one in which a new block of change might land.\\n            //\\n            //         historical\\n            //           block                        block horizon      block of change\\n            //        =====N=================================H=================|=========>\\n            //              ^                                 ^\\n            //              |                                 |\\n            //              -----------------------------------\\n            //                        minimum delay\\n            //\\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\\n            //      block right before the block of change (since by definition the value changes at the block of\\n            //      change).\\n            //\\n            //           historical                         block horizon\\n            //             block     block of change       if not scheduled\\n            //        =======N=============|===================H=================>\\n            //                ^           ^                     ^\\n            //                |     actual horizon              |\\n            //                -----------------------------------\\n            //                          minimum delay\\n            //\\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\\n            // this to happen.\\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\\n            // subtract 1.\\n            min(\\n                self.block_of_change - 1,\\n                historical_block_number + minimum_delay,\\n            )\\n        }\\n    }\\n\\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\\n    /// called in public with the current block number.\\n    pub fn schedule_change(\\n        &mut self,\\n        new_value: T,\\n        current_block_number: u32,\\n        minimum_delay: u32,\\n        block_of_change: u32,\\n    ) {\\n        assert(block_of_change >= current_block_number + minimum_delay);\\n\\n        self.pre = self.get_current_at(current_block_number);\\n        self.post = new_value;\\n        self.block_of_change = block_of_change;\\n    }\\n}\\n\\nimpl<T> Eq for ScheduledValueChange<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        (self.pre == other.pre)\\n            & (self.post == other.post)\\n            & (self.block_of_change == other.block_of_change)\\n    }\\n}\\n\\nimpl<T> Empty for ScheduledValueChange<T>\\nwhere\\n    T: Empty,\\n{\\n    fn empty() -> Self {\\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\\n    }\\n}\\n"},"304":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr","source":"use crate::{\\n    hash::poseidon2_hash,\\n    shared_mutable::{\\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\\n    },\\n    traits::{Hash, Packable},\\n    utils::arrays,\\n};\\nuse std::meta::derive;\\n\\nmod test;\\n\\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\\n///\\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\\n/// is \\"hacky\\" but there is no way around it.\\n#[derive(Eq)]\\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\\n    pub svc: ScheduledValueChange<T>,\\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\\n}\\n\\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutableValues<T, INITIAL_DELAY>\\nwhere\\n    T: Packable<N>,\\n{\\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\\n        SharedMutableValues { svc, sdc }\\n    }\\n\\n    pub fn unpack_value_change(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T> {\\n        let svc_pre_packed = arrays::subarray(packed, 1);\\n        let svc_post_packed = arrays::subarray(packed, N + 1);\\n        ScheduledValueChange::new(\\n            T::unpack(svc_pre_packed),\\n            T::unpack(svc_post_packed),\\n            packed[0] as u32,\\n        )\\n    }\\n\\n    pub fn unpack_delay_change(packed: Field) -> ScheduledDelayChange<INITIAL_DELAY> {\\n        // This function expects to be called with just the first field of the packed representation, which contains sdc\\n        // and svc block_of_change. We\'ll discard the svc component.\\n        let svc_block_of_change = packed as u32;\\n\\n        let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\\n        let sdc_block_of_change = tmp as u32;\\n\\n        tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\\n        let sdc_post_is_some = tmp as bool;\\n\\n        tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\\n        let sdc_post_inner = tmp as u32;\\n\\n        tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\\n        let sdc_pre_is_some = tmp as bool;\\n\\n        tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\\n        let sdc_pre_inner = tmp as u32;\\n\\n        ScheduledDelayChange {\\n            pre: if sdc_pre_is_some {\\n                Option::some(sdc_pre_inner)\\n            } else {\\n                Option::none()\\n            },\\n            post: if sdc_post_is_some {\\n                Option::some(sdc_post_inner)\\n            } else {\\n                Option::none()\\n            },\\n            block_of_change: sdc_block_of_change,\\n        }\\n    }\\n}\\n\\nglobal TWO_POW_32: Field = 2.pow_32(32);\\nglobal TWO_POW_8: Field = 2.pow_32(8);\\n\\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn pack(self) -> [Field; 2 * N + 1] {\\n        let mut result = [0; 2 * N + 1];\\n\\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\\n        result[0] = self.svc.block_of_change as Field\\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\\n\\n        // Pack the pre and post values from ScheduledValueChange\\n        let svc_pre_packed = self.svc.pre.pack();\\n        let svc_post_packed = self.svc.post.pack();\\n        for i in 0..N {\\n            result[i + 1] = svc_pre_packed[i];\\n            result[i + 1 + N] = svc_post_packed[i];\\n        }\\n        result\\n    }\\n\\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\\n        let svc = Self::unpack_value_change(fields);\\n        let sdc = SharedMutableValues::<T, INITIAL_DELAY>::unpack_delay_change(fields[0]);\\n        Self::new(svc, sdc)\\n    }\\n}\\n\\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\\nwhere\\n    T: Packable<N>,\\n{\\n    fn hash(self) -> Field {\\n        poseidon2_hash(self.pack())\\n    }\\n}\\n"},"307":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\\nwhere\\n    K: ToField,\\n{\\n    poseidon2_hash([storage_slot, key.to_field()])\\n}\\n\\nmod test {\\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\\n\\n    #[test]\\n    fn test_derive_storage_slot_in_map_matches_typescript() {\\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\\n        let key = AztecAddress::from_field(\\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\\n        );\\n\\n        let slot = derive_storage_slot_in_map(map_slot, key);\\n\\n        // The following value was generated by `map_slot.test.ts`\\n        let slot_from_typescript =\\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\\n\\n        assert_eq(slot, slot_from_typescript);\\n    }\\n}\\n"},"325":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\\n\\nglobal BOOL_PACKED_LEN: u32 = 1;\\nglobal U8_PACKED_LEN: u32 = 1;\\nglobal U16_PACKED_LEN: u32 = 1;\\nglobal U32_PACKED_LEN: u32 = 1;\\nglobal U64_PACKED_LEN: u32 = 1;\\nglobal U128_PACKED_LEN: u32 = 1;\\nglobal FIELD_PACKED_LEN: u32 = 1;\\nglobal I8_PACKED_LEN: u32 = 1;\\nglobal I16_PACKED_LEN: u32 = 1;\\nglobal I32_PACKED_LEN: u32 = 1;\\nglobal I64_PACKED_LEN: u32 = 1;\\n\\nimpl Packable<BOOL_PACKED_LEN> for bool {\\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Packable<U8_PACKED_LEN> for u8 {\\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Packable<U16_PACKED_LEN> for u16 {\\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Packable<U32_PACKED_LEN> for u32 {\\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Packable<U64_PACKED_LEN> for u64 {\\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Packable<U128_PACKED_LEN> for u128 {\\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Packable<FIELD_PACKED_LEN> for Field {\\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\\n        [self]\\n    }\\n\\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Packable<I8_PACKED_LEN> for i8 {\\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Packable<I16_PACKED_LEN> for i16 {\\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Packable<I32_PACKED_LEN> for i32 {\\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Packable<I64_PACKED_LEN> for i64 {\\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\\n        [self as Field]\\n    }\\n\\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\\nwhere\\n    T: Packable<M>,\\n{\\n    fn pack(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].pack();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n\\n    fn unpack(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_packing() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i8_packing() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i16_packing() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i32_packing() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::unpack(a.pack()));\\n}\\n\\n#[test]\\nfn test_i64_packing() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::unpack(a.pack()));\\n}\\n"},"326":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 1;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"342":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\\n// is not found, the function returns N as the index.\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays where validate_array(array) returns true,\\n// which ensures that:\\n// 1. All elements before the first empty element are non-empty\\n// 2. All elements after and including the first empty element are empty\\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // We get the length by checking the index of the first empty element.\\n\\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\\n    // of the element and non-emptiness of the previous element is checked below.\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\\n/// if this is not the case then elements from the end of `array2` will be dropped.\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: we constrain this array below\\n    let result = unsafe { array_merge_helper(array1, array2) };\\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\\n    let array1_len = array_length(array1);\\n    let mut add_from_left = true;\\n    for i in 0..N {\\n        add_from_left &= i != array1_len;\\n        if add_from_left {\\n            assert_eq(result[i], array1[i]);\\n        } else {\\n            assert_eq(result[i], array2[i - array1_len]);\\n        }\\n    }\\n    result\\n}\\n\\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n// Helper function to find the index of the last element in an array, allowing empty elements.\\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut index = N;\\n    for i in 0..N {\\n        let j = N - i - 1;\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & !is_empty(array[j]) {\\n            index = j;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which returns the length of an array right padded by empty elements\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\n// See smoke_validate_array_trailing for examples.\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let index = find_last_value_index(array);\\n    if index == N {\\n        0\\n    } else {\\n        index + 1\\n    }\\n}\\n\\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: this value is constrained in the below loop.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    // Check the elt just before length is non-zero:\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]), \\"invalid right padded array\\");\\n    }\\n    // Check all beyond length are zero:\\n    let mut check_zero = false;\\n    for i in 0..N {\\n        check_zero |= i == length;\\n        if check_zero {\\n            assert(is_empty(array[i]), \\"invalid right padded array\\");\\n        }\\n    }\\n    length\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test]\\nfn smoke_validate_array_trailing() {\\n    let valid_array: [Field; 0] = [];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(padded_array_length(valid_array) == 1);\\n\\n    let valid_array = [1, 0, 3];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 0, 3, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [0, 0, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nunconstrained fn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nunconstrained fn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concatenated = array_concat(array0, array1);\\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"345":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"}}'),r={transpiled:!0,noir_version:e,name:n,functions:t,outputs:s,file_map:a};export{r as default,a as file_map,t as functions,n as name,e as noir_version,s as outputs,i as transpiled};
