const i=!0,e="1.0.0-beta.3+0000000000000000000000000000000000000000",n="MultiCallEntrypoint",t=JSON.parse('[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"_log_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"_unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"},"visibility":"private"},{"name":"_first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAA/+Wc6XLbNhDHKZu0TcmyZPmK3Svp3bRpKYnU0dNt0/u+lM+KYz8HHyPta7Rf2qer/jFXWsHojDteTPxPMMOhpYV2f1wuARBYuBadl8nsqFV/x9V5vTrj+060XKTucXXOrla6hrqyUIw1AsYVAsZVAsaYgDEhYFwjYFwnYNwgYEwJGOsEjA0Cxk0CxiYB4xYBY4uAsU3AuB2AMQRnh4Rzx5BTj+1D8e5G1z9G9wgY9wkYDwgYbxAwHhIwHhEwPkPA+CwB43MEjM8TML5AwHiTgPEWAeOLBIwvETC+TMD4CgHjqwSMrxEwvk7A+AYB420CxjcJGN8iYLxDwPg2AeM7BIwZAWOXgLFHwNgnYMwJGAsCxgEB45CAcUTAOCZgfJeA8T0CxvcJGD8gYPyQgPEjAsZjAsaPCRg/IWD8lIDxLgHjZwSMnxMwfkHA+CUB41cEjF8TMH5DwPgtAeN3BIzfEzD+QMD4IwHjTwSMPxMw/hKAMQTnryScv5FwTgJxRvcc6JXZgY1b2BiFjUfY2IONM9iYgo0f2FiBjQvYGIDEeyS2I3G8PTuQ+IykYiTsIgkWSaZI4kSSJJIQkeSHJDokqSEJDElWSGJCktDN2XFrdiCJBEkaSIJAkgEW8bFIjkVoLPJiERWLlFgExCIbFrGwSISrwiIHFhEwSY9JcEwyYxIXk6SYhMQkHybRMEmFSSBMsmASQyYJ8JKLl0i8pOElCC8ZGMRjkIxBKAZ5GERhkIJBADpZdGLoJNAIo5FDI4KHFA8AgmsS/XeRIPmnOqfVeUXJDTfRdVPHrqX+UTa+n3quz5C/n1Y6N4LoL4aiPw3Dn8lG27vlQr++FrG7Wp0n5cKXk3KZSeo8VHUeOnXkesLc7zwP669ur+n4KFLXIrbrYWz3a449fV+0TOzXo5Cxeb4pWdsTHtc/0nY0pU654Kk5sri8eB0iS5RM7i/s3Fb13NjacGTCgiLx21S+kXKvksk9jZVOu3gtRmHjNc8eX7zm3ScxXmNHFpcXr+P/xquOLTdek2hRpC0V2ZqS/e7I1pXsj3Jhu1Acg+rvsG3yeR+snz3rPmzHw69toayXC39IDK6q7xLlv0f+0fUdWapkcblsp159jpUdrUs4Eqd+Xn1uVec19Rv5fdtjf82xv8Tt+c71S+qpn3rqI9buVH83qgMx9Jf8Jrr47OI4rj5nVyrDwtdO2ukfdH1toaH+U9HfCKK/l4n+zTD8836qGeb+DkT/Vhj+efy0wvD3RH87DP+Z6N8Owz9/j+kE0V/Mx+U7Yfjn8b8bxv9z/r0w/HP9+2H45/f3IIz+sYw7bkSL4o4zD9X3dv1/b3zZcabYrzusocaZhw6P6x89zoTsyMPa9sjcZ/TIY+fIY8ena9NQ14Ghrm1DXQ1DXfuGutqGuuqGuvYMdbUMdaWGuizvo6W/LGN111CXZaxuGeq6ru2E5fNo6fvrGqsbhrosY8IyVi39tWOoy7KNthwDNA11WfYdls/QdY2vp6H9CtEPhV0PzDLfPFhkp987D2aoPxNfS6zquW9tU64vcer/6fh5M4ife1N5J5M2SPvCN1dlabvm2Isi//us2G96eIS77pFd5R/Mno5OTsf383wwzIuifzKsOfqF1f1OzzvrPkfX970b++bVDH098q3xtJRfUWIl23JkiZIJo17j8c07WvJfxv/aftsjc8del72XnWg51vTz2IgWz3Bc2l/7cHTeljxirPQn0fIabuTYT5z6f1ef3bbuqs/I2XDaPetPz6bF9MGD/GTacfRrH8JP/wJJ9PoyCV0AAA==","debug_symbols":"tZbRCoMgGIXfxWsv0sq/9ipjDCsbglhYDUb07tOILbbrcxMd+fXzwg/OyjrTLI+79f0wsct1ZW5o9WwHH9O6cdYE65x93M/LLEsfUap9wzRqn/I06zCzi8iFrDkzvtv/qY6H9NaZmGS+8b95kscw0WeyoO3GI4DQgAoNqMEAlaEBAg2QaECOBhRoQIkGoE1WaJMV2mSFNpnQJhPaZEKbTGiTCW0yoU0mtMmENpmgJm8xPXWwunHmaDj94ttT4Zlfo/npPmMYWtMtwaQW9C1A6TUWkpcyXTvZK6qMi6qMkAh6Aw==","brillig_names":["process_log"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["enqueue_public_function_call_internal","call_private_function_internal","directive_invert","directive_integer_quotient"],"verification_key":"AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAACTpbHwWcrVyRJVmlir27ODZ6pNv53+QRN/mIorbHsOwSusVRjd7/73Wnz3FuW2V2BEbth2IesfLaX16Yy+eo7wMZHwVCju5TGlvSKcPpWMeWpkSnvAga3zVJs+aXvFpTEB+xz5kCk3jsRqfIZZ+D0EEAmAeNRngMVs+MBh4nXwwAsL3mWAdewdH+KXfKJrFrnNM4EIKDz/tq9sPZxFCY6gYG6vIuwOTyc+ROACV4WUAg8la4g0c2sDI4FYVTvsDEHauFDGhdFsRzA71L64cSR4yl0KT9nLIPl2opVXYQCq4dmAVUQLw7k5ChRfKO51oe7ajOshDCQ7ud4vvx41bFyx/4b3LzMXDE36ZgUS018TkZBXayjPpd68tkmUNzY6nZBUUz3QC1naELuByhRVJ/vOHdkBZQu3AXSRKEP2FMBOwwVP+xN43q5L3NxJV3l0JD/lQeMQUZzPvDEGY4fMMcoyiEWFthNDDMHmrmhWGGAGuReIhfxCTccCHW02woKdUWBFa7cBtbC0Y7vPDE/nGQVSOT0JUz4bIAS9hOn4pTqI8DgPTmuzBHdr/U+yLiCYd0FWSB6aP48JHTDbEAOm2qtCmMMxH8kXD5LelAsEKquZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLshU1Y/bj1w+zyv6yKiawOGpRC0Zz5NmLg5dE5PzVGmIRF8Qsw7nG5jZLvvVFh0/NT5SB/ALBL6twWmUFnRB+VJJteXF/FnSqZBr9Fx32/z9I89+HHYci05EWlTTnEOTqEPqCNjFkXOjEVfORXXd43SqR8bZ/Kyv0rQtr4+VTzmpACmHerHazcMpPQvc6Zly3Wp69xYzUvfivfn/P+jbVtxLll4nw2duz8VreU4S3hJDbHYM3nHO+QRI96/yIyfyNYESXAgGyYgmeJjY3ydPiHYMu5XihVcOTWQ/NOHaX5/agWOCDq1ThrTX2Bl5apc69OyodrBap47ADbLp6ZenHQHIM8Y2TbnOFAVEIwko098rwQIrfthJ3P/9QDMCO7yyIUNwiZcN8Z9Q76/3NWQPG7oW4N7lB2/gfa2CUqpneXHyyHfLNLCQ1o4efcGmKv5vRZf/cQZi6VJBe/Tyn9HFtfeBJ0K5VAGDh6YCLzdK7rbLKbvO8DQmBelYtd7V70ZlZUW7fdhsUFlW3Z7Eo4EhUkp77yVnAEG087RFYyP/YGL/RgF2yE9/3A3yAhFCc2HQwWua8QUPNb83jbxhFCBRJdKEtTTYpajYp9t4WV6yrSY+lTpDTOqevN2BiRVl1JwjT0LUVGIOxQ430btH1NNptknmCmFUQeI2fd/X5eV7Sl1SwgDK4RIzXjMgMwsp9LWLnCMFBun7A15OdquWzYv9uvhJY5Fgd0PS379j7Ut+9B6gFFGbk2Hspb8P7fqHvjZ7DQlKR5gwNXLkohdpWEr4/6PHXeLJQEgeqbjSgOpWV+BHg8Yha9/6bhJ18x9smBYmOWMUok7KA79IvuWD0v+DmdfIeCuN69ImnoXxSq5XoPSpH8v7+8lPxStpqkuN1EwxUMkg1RsQK3EYL3ZILQ3ZIqZ3V4ndp7yQQb7kDdhy0QTiBX4WECdNwzAQ9Z5wv+w77Xww8VpzChAvDKtBJESIUPxI17tJ9h3KEtWpDX8bGXRzF7Hv8K74gB1ZQcflvUeTI8XEVRRV1KecqdYPvcCOpSxKxGtGivf0qYSVpVGf7CKxAA1LfimI6PhDf2oKUvNwwvRiPtXCYjoaf9OnwgGf451CbZGiGNwOPgwj4uZps8AWqoQEppYqIhP0OJZn1qXZ5AM5MjIHQ3X2GF9CdOyN1oy8gKACYecjNJeq/tjckl5uwrcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDL8bRU5JAgqN8ycCZEiCWjgVsXplTpMSHhmKliYBQlMlpHRNTQ34gjba5zfVoEhYb9zTr9MViPKiQhiEc0csHwDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16775516380094354375":{"error_kind":"fmtstring","item_types":[],"length":40},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","item_types":[{"kind":"field"}],"length":58},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/+1dW2xc13W9Q3JIzpAjjmVLsWRLFCVbL1ryPPlIg4aJX7HekvV05AJDzsgx6liBJRfIH1sUKFA0RX8C9LdFi370o0DQIh8p+hUgQPoRtB8tUqRJm7pogaABWhgIEBhodKS7Z9Ys7nt4h7PPcGTzAARn7tl37cfZe599zn1MJuq0TPx/LOqjCcit3KP/8b9oBPpHH/ytxN9L/bVyjvha4i+V6q2cop+h/NVcjJkJg18S/ED2L03EOL+x3sFHXYTv5IO/Kfh8LOr4Ryj9ZfxC6v+kR2fxnZfWo3az4VtrCvbL60H0qgj+K2Hwa4L/ahj8quC/Fga/JPhfCoPfzmuvx/h2vtOx/RmQPWOGX2nb5mwQ/IW2bc6FwW/7zvkw+G37XwiDXxf8i2HwFwT/Uhj8RcG/HAZ/WfCvhMFfE/w3wuC3c//VMPjtmudaGPw7gn89CP5iO//cCIPfnhtvhsFv559bYfDb+efNMPjt/PDlMPjt+L0dBn9V8N8Kg990dbCrgX8c400/+NsVf367df+L795d+80LH3x1tfW+VJUoRQT/5fNotLE51N0d1Jfuvnf//cba/S80m++37t1jhBEFOUpAzQPqVxrvvPd6M0meHtGut96/987d9xhtLCWa1PpZoLcbt3qpEOONk3zIe4KsYMO73NBGnq2M/PMkq3V9miF+Ig/bR/xKbDepyFpU+ngMJxU+kwqfotLHdVY/WDcMsS4aYl0zxLLU8Q1DrMuGWFcNsS4ZYp0xxLLU0dK/bhliWca2pe3PG2JZ+v1NQ6xzhliW/vWmIdawzh1SW4etOzr7x7kw+FWfLVAn4S91RBboMwn/BYv7hFc+2lhrhKiRNN1Q/qRxZhv04zOIlVP6QozphEdv5p9Er9WSQp/34CP9TLTRh/Nki6kwtqj4xi0PPIX/NNA2W6sfvH3u7tsRtVGyg9htH9HJ3vdItNHeuQSsiL7vo2OjgIdtGjDvff29tQt377fuRZs0XzDLwIRZwJSX0yYL4T+oZDFO8iQ5tdhuQpG1GG0MKN4s0YJtQuGjYb1liHXGEOu6IdYFQ6yrhljnDbEuG2JZ6njJEGtY/eusIdYNQ6xbhliW/mVpryuGWJb+ZRlD1wyxLH3CMq/KYjbwImiJNy+xSR8WlzxHY6H6EujPjbfxUSfH+0PAZTqWB+smLPaSaoYoCr4wKOfIHsb47YVHjmzKOuUTbCX92n/B4j7hNagNd003bZFUjDb6JS+4NKxcj1jbuUGg+XjBI6umBy+wfYtWtInQ5z1yIf2nZRH6NNHJDVL9LEKfpmNJi9B+N4dETteKCpYsqHlt6tpK/L/UX2vyXGaI3Qqc35c59rDxXIi2lT70f55DpwFL5lDpK8B543TeLg/mjAez6JHzCQ/mbsB8nTCfhPMw73DT6gAZM/f/I+DJdNKcLWUcxtY7/VbjvbhUKgm/0Rg/G22UHflnif4/4u/oE/J/rA857yw2yneqjTuNeqPZrK01dhO+ayNgJ7wZowD8IzpPu8HAOk+znFrNkQW7oayhao4sycP2EVtOR50Yfvduo/lS42v3Pni3NUKm5HSP5kQ4VptDpe1+dIynkBE6T6YkzVVZzoyCoZlAMGeibhnw3FH6jraIlGMjCn0mBZZ8HvXIkoSRIYyCB4NDR3SfUvAkdAqEvxJ/L/XXWpzusXG619J2keSKovSpWXTqdYk2DX0oG2JKSmW7TkN/l11jRm4a3DPezW+3Ik+alOMal0WYUnl6fNKQD06ZPLU/ZcjnKaCZID57DPnsAZpJ4rPXkM9eoJEyYEbp42uCT0Of5eUW0ZGvUaH++4E3+9Qz0IfLPm5afIpOvcbnZ6APZUNMjE+0q5ybU7BcW4n/l/pr5SzJcyDT0fWfJrtlwGWUFX/Ria8T4hgJ31HFlujz2jHExnNzSp/hfHKH/U54IO9ng/Aul9LEPPLPRxtjJEQZ+CzJw/bpsQzkkBL4GYITGqTFNgMiIT3vAiS5VZoyMKdgrMT/S322sO5UWhX8A4BvKb+kIBnPy1CCnIo/a+mfw2l/IP3ThpPwz0dBU0s7nPaTPGwfLlGfUWQtKn04DXGI+sJ2B2sHa7uwpDTFHLCP+Gjxst/DRysbtJ3GA9Q3rcin7TRy3y5P34yiFy89XZMdZm2nUTBdXv3TTOe4+zsIGNoY8PYE2vlg1I01uwnWy4SF588S1qFNsF4lLDz/EGHNbYL1CmHh+XJujr4b5/a6yHrEIyvyF1kPQ9+Rwci6ILI+16OsR6DvucHIuiiyPt+jrM9B3/ODkXVJZD3ao6zPQ9/Rwci6LLIe61HWo9B3bDCyNkTW4z3Kegz6jsPnNFjPEtacgpVTsA31XhNZT24i63GS9QT0nRyMrE2Rdb5HWU9Cn5xbiDaOUYb0mA+jR+o1g/DPh7Vr2WdXtA+vGV5QZC0qfYfgM/YhnxcUPhrWYUOsI4ZYzxliPW+IddQQ65gh1pwh1glDLM5lh6DP8pKSyHpYkRVzmfDX5ojDdB7GBs+To4o+Gu85hbdgaLUvz3mHFEw8xrY/nsAvjW1krTPj0W2GaDWZ9yl89qWUmddbuPb7DPXh2o/XjLj2O0h9uPabpb4ZRS/tsuMc9eHa71D8Gdd+WdLnz+PjgbfGS3w3hWbjbdjna2WIXxRt7z6f2OKgxxazQXjXymltMUu2OBjIFhLHcyRPUhz78stBhR4vObzdun/u7ttf/PrVxtt4Ex2HPocc0u2n788kiLVCdLP0/VD8meVALGwsB1/SYPqVTejx87Ry3DVxxcOEsxJ/L/XX2jd9PxcGv32DsLblgjoJfwnLOcVWacNGeOUJK1TYaLqh/Dz9YdnM5biGdaRHrJzSF2JMNyt/hH/BI6umxzTpwTZaMdFjcVGzkx3+wpIWW3b4tQXBfz6MfepcwqzEzufKnO9musdWaEQOHD/MbXZ+WF1Imw+Efz7aOM+EyAfTJA/bh7cBCoqsRaWP/aig8CkofIpKHz+AtlUszf/6keuqkVyunTfEOmOIZamj1ThGxjqeM8Sy1PENQ6zrhlhXDLEuGGLdMsS6bIhl6ROW8WgZQ5Y+YWmvS4ZYNw2xLG1/0RDL0vY3DLEs7WWZC88aYlnaa1hzoaW9LHPOp6FmsvQJy3nbyvbu8+HIBss1S7+3sr37fCSywXLN0u8t/csyT1jWAJb2um2IxS/SSruuF/oZhX5OoZdLbHiZSs6VPRR+Am4l/l7qr1V8dsJLY8J/Ky8fELvViY5fPoDxuCsBK6LvdTo2GukvH9CefpxIkFP48vjir8mgvOMKPeLxU4C/Hg+8s+MPY2MWFZmmAT8bP7Ij/sC3EqzE30t9tVq1EOP5buvB2wUM9/NSP2At/Ad1W88Jkoftw/t5JxVZi0ofj6F2C9lJhU9R6eOaph+sNwyxrhtiXTHEumCIdcsQ67IhlqVPXDXEOmOIZekTlva6ZIhlaa+LhlhW9nKf+RrCsPjqeUOsT/o4unbDEMvSXpbz0FlDLEt7Des8ZGkvy3xv6V+WOccyHi19wrJmsrK9+3w4ssFyzdLvrWzvPh+JbLBcs/R7S/+yzBPDWn/dNsSS/SntUaq5qJuP9gjZMQ8fPP9YCixtPSz02mMxcwq973Ej2XvARw1C7INpa318jEn4b2UfTOxWJjreB9MeDWOsiL6X6VjSPhjf0/XXsfEDPx6o3pbOPjoFMoq+r613aPYn6PBt2E/70WQ3JvqZjCfe0syPXk8p8vH3rEI7SX1C+7cg209iogKdLxiuBR6HtQzxE7vgMeSfV3QNscemjZO2t67tfxrKs5omX6K8vF+q+bXEM76NCumPgY4c/5iPsnTs+7FRtMdq+DUQ2qO0Ws5+eG/nSLduHAfaf8HlY755RcZX+OAj2RL3Tp4fjHTrwnkCz3Wfn4V+pP+7yQ7mP8aY2uNNPH4ci5iLXHt5vZteZJHrAkzDeUzo/xlyxU8pj+1XdH7WI7Ng4stH8dGeAwky/Ijmg0Bxps4HwmvQrxvh50lQ/6Nh9E+dh4V/XrFJiDx8NKVdhyUPi7xaHuZHd0Pl4f8JlIf/i3IU6sOvZ9PG7aiCW1TOZxvief3me01mX9xtlQ9iYc2I45qUO/HaOo4H5k70Oc6dQv9LyN//6an1cG77eGRzWacUWbNE/ycwt/0/+Q1ex5fx0MZnhvr2K3wzRBuBnEgzF+l6jSfQzyToNR4PPl4rzyi20MaV39orfWMJevG4tt/gCDKkHdfp0c1l1dYaWaL/XRjXmRhzRpHdN65F6sNxFRtpdRCPea+PeeP5+zx85K27aebjMK9hXEv9SC6/1TP0fKy91dM3H8+FsU8pQ/goz5xin8D1U1Wb79E30sz3c2BDpMfPcj4eOxk7hsigvcKoqPRxLdDrntygsHw1Co6py0mzZAv010zCf8HlYywjjifXDnOGfBBLcvigai4tTtzfSvy91FerlsLeL1Yta6+sMsSvaPec2eHXynzPlvDAsQnzGqt66udX+TVWJ4PI43+NlXZNQmyX9jVWVq8Zco2vOw0L1gVDrDcMsa4bYlna67Ih1lVDrEuGWGcMsSx1vGaINawxZGn784ZYln5/0xDrnCGWpX+9aYhl6V83DLG+bIhl6feW42iZvyx1vG2E5T5bvTLStbeM5HLN0l6W9cSnYR6y9Pthrb/OGmJdMcTaqb+2z+8ta5OdOa03rGGt5YY1F1rWcpa50HIcLe01rPWX1Wu2XRvW+uuiIZZlbFvGkKW9LOchyxgaVttb5i/LvbRh3Ruy9C/L2ndYa8xhnTv4OpbF3KFdQ8V3UQf+uZSq4J8KhO+zFeok/OW6EV5jzyT8FyzuE155wjLWrezTDeX3+RTaoF//HNDzMO0xnffojfx7vRZoFWfu8z5DrAJhafdCaNdChf6UQq/5yYzCW86VsT0NfYZjW/GNLeYI4T8d9f6sk9jtGtG9ut6xA8fGCwlYEX2/RsdGI/1Zp5loo68VE+QUvnzMd0/bcQ+f/X3y2Z+Sz+OsTy4BeyX+Xuqr1Wvb9y6jynLaeeyT8i4jHsNhedbZ8nnum4ZYls8UnzPEGtZ3Blk+Z275zg3LZ9Ytx9HSXpa+avk+HUtftXy3xbDmCct4HNZ3lFi+V8TynVSWPmHpq8P6jiXLHG1ZA7xpiGU5d3zS3/Pj2qchf4WYhwKvs+749vNy0ca8areuqab+KWjhnydZbeXprLO0cdP2gcR284qsRaWPfwNK28OZV/gUlT7OP/1gXTbEumKIdcEQ67wh1hlDrFuGWNcMsSx1PGeIZanjG4ZY142w3GeuXYfFvyzj0dK/LHOhpVxXDbEs/f6T7hPu85HIBss1S/+6aYRlraOl3180xLL0+xuGWDt54pMxd1jq+GVDLKt6wrVhtf1tQ6ydGOpt7uD9hJ0Yejxtb7l2t1wjy/1zvH/l2kr8v9Rbq/IB/o32PrA38OLfZzfEroTdV6uVNnu/1b+PdfjiuCW932oW+pH+18Y7mB+OdY83/h5axk639n0he0G3TNTNe18Qu1ZKGeIXRfp+pfDPk6y28nT2K7V3e6F9eL9Sezendq8Pj2Gv7+3EPs5T/WDdNMQ6Z4h1zRDrTUOsC4ZYN4ZUrvOGWGcMsc4OqVy3DLEs/d5SLkvbXzHEshxHS9tfNMSy1PG2EZb7zO936Eeut4zkcs3SXlcNsYY1ti3nDqkntPebynsMtfeazxE/7Z2HrkldehD6LetAwT8UBr/9PMmsYmPUSfhLnXkA6DMJ/wWL+4RXnrCsbefTDeVn/5kFedAGSVizPWLllL4QY3rQozfyL3hk1fTg97lqfLQ1itDPeeRCeonLQ3C+nMv7A8Y2rPjGew54Cv+tPIsjdpslui+td+zAtj+UgBXR91k6Ngp42MTGuI7l57b2kg5J41tUzhe6NGv7MHmgWk2bl4T/oNb2B1LaVWx3UJG1qPTx2l6Lz4MKn6LSx2v7frBuGmKdM8S6Zoj1piHWBUOsG0Mq13lDrDOGWLeNsNxnXpf0I9dbRnK5Zmmvq4ZYlvF4yxDL0u8tc6HlOF40xLIcR8v8ZWmv64ZYZw2xLO1lGUOW9YSlva4YYu3k1e3Lq1a2d58PRzZYrln6vZXt3ecjkQ2Wa5Z+b+lflnnikiHWsNar/J4+i3o17Bq/c9/FsO2p7QL6TMJ/weI+4ZUnLGPdyj7dUH6fz6AN+vU/wQq8t94e0wMevZF/r/swafZJ09pkmrCmFSzfnmvasZ2JNo6nnBs4xtp7rs967IT8t7LnKnarEN3L6x078NgdSMCK6HuFjm2254pjuof60P+KxGcX6bdZnOL5QrfZfWTfy+o8k+4jw99BRvq9cB/Z97PdOuL5u0l/tM2T1IfvAnuK+tBuQid+i787aee35WWxJd6rJU27L2uK+p6BPtSb2yh9R51cHHwIuEzH8qAN+Z5V/M1PLR8WoB/pf5jtyPLfkzpmBjBRTrnmIfTis/hb3UjDMgj9v4IMP034XdKxBL1mEjA/ynZk+besjumaFous1xPx8fFIl0HwskT/Ieglv7caEY18Rx96mmTbrfCKEo4hNp7Lfb3yRfvIsSdT8M0ofexLbE88P8nm7EtC/3OPLxUUGdAePO67SAameYJkEPr/U2RwdpYcsnb3a19/qfG1ex+824qojcFnTvXaUPMQFBScpCZmcOpJuDCOfPe5iRaOUcKxpGGfhuPN1rut+60EA40Q2FQCs5FIb5xL5TzXws45j2ol5BdF+hpC+Ocj3W9XbOQpc54Xedg+fE2zqMjqq1t88zzHGsrgq498uWNXSn2mo45j37t/9/0kn8M5XPO56QT+GeX8iM7NKMdcc0GZjeuwHPE19oO1AumBTas9MtSH+rKvcCxhH/rKGPXhfJGlPpxbxqnvSeiboL6noG+S+vZAX4768J6CPHzmptV6MmaO30eAy3TSnD57YqXcuYNaWzDWSLRxzeDaq+uP/otPhrnfovMb2bKmS6pr90I/0h+Mbejs/jOqA7R7Y7TfXmcZkB715jyHvsT7CRpvrfYMu/fWse9BsJ+m2wHoR/qjHvtqezM++262PyfyiH3RpgcJazP7vrz+6P+w2/f0NtpX20fT7jnjPNTrPWdFRQYfVlHBwrr6QeH4zm+13r9w934LUyqrG9HnHB2bpu9cKu5JEDWpFJXv/HPuvM38DH1/QpFPayIHNpZlNNq8iQuKrZbABX9OLqhNOchT0hhvWeG5uGWlvcKd3avXV9Hj+UKn8eFbyk8p52WoD2U45ZFh8K+kr7VTz4sxXtL232noR/pXPalHzkH9te1wlgHpUW+RR7P9i9SH57FvnPbwQbk03zjt4fNCn3xeUPiMKn0YOwUFF3MV2sbWd0q1DPETefEY8s9HIX25s0T1+ZFrvOwoKbIWlT5+tVdJ4VNS+GhYhwyxfPnqNPHpNS9q/l1Qzht2nwv0cy1en9Ps2qvPcanTj5+EwJqJNo4350HNNi96+OD5QldQzmOfQ/kMx7ie1ueEfz4KGgNl3/hpdhXblRVZi0of+0lZ4VNW+DxOWHJJTPxXy6dbjRM8X+gKynmZhP/Ch49tdQ54kfTpdQ7QYts3B2xVn17jfqt8EEsuiXOMWPBBfztA+swrMrhS+hvjnXPcn9xygHU5nitbbFmi//xkB/OPYkytZkUZ8fwxOH5a0YP5fZO2n6twjmHuK+F2bkS8wq6VqpUC6YytoOjNsV+DPo6jOvSx7y9AH44XN21LWWzh3OF/Jzu4TCdN85ES9VUUPaSvquih5avT1IexX6E+zD9V6kN7fAY+Iw/XRqONYyf7DmnqZvmOcXFA4Z0l+u9QXISpCSoN3/ySU2xlyTtNfkT+vnokr/SN9SFra2mttbxaqy0s1ur16tpir7UD50Wk136+K2z+qyxJ7I6ud/ArYFfXxqCvTH1Z6BMZXVqo57rlrwSSP439tRyA9K+BDr2M5e5oYx7i2mircf4PA4nzanP74rzaHOY4r7RW1xYajTvVtTultcadlmWcaz8fETbOq43HO86rDYs451us+lnv8aVri5yxs/fabkH3Xl17fb1Dx3297l3x6y9C7YNxDdnrPhiePwT7YKl9bmcfbDBY2t4V1zO9+jaen2bvKmzNkX7vVfjno6AxUPaNn2ZX3jPAc4tKH/uJVo9UFD6PExbvvaLvsP/2Gid4flIdKv3af+HDx3zxyNeetRja6hzgqztC7Immjfut8kEs3nvlx6u0/2n5oL+l3XvdNdE5x/1J3Zx271XofznRwXwi/qztq6GMeH7avVeh3xvzkFyM+4yh916FV+C91yrvr2LT9lc59tPur7LvL0Ifjhe3UHuvZerT9lelr6booeUr3nv17a9i/qlRH9qD9161PIdjx3uvO7WutwWvdfnnLfupT18wxPLdb5W0d4d8fPdbaWu1NGv6YfO50Gv6Ukq7fhrWV7ym73V9pV1X21lfbfS5nfXV1rF86yv2317jRKtNQq+vfHMAr696nQO02PbNAVvVp9e43yqfYV5ftYzWV38D66uv0PoKf6qL11cy3+P6al7Rg+9x/yqtr7bz3pb5ILxt11ccR6HWV2KLXtdX84oevv17be3lq2vmqU+rWbX8w2sv3/pKy3O4DuD11byiF3/PKrSnqE9ofwdi8FueGPQ9LzOXoBPmA6Q/mSDL78X8nQus5HTMEQXTNX5ENUxd03nEr6zoqM0NWaL/A9DxZ+TreI1YbC/PgY2tB9Gn7ER4KdeRg/0vC3x5XvKtW9lOSO+7f8y3/tR+ChFjgB+jDbOe6vgAjjHPe1o8Cv0fp/QBset2+ADeD8w+oOUs7b5jn8/g2HCe1a7L+nijX7APhNnH8fuANk+wD/xZSh8Qu26HD6Bd2Qe0fUHtZ0nT5A0tD/h8QLvvHecCvt9EsMcjfT4SPJ6P/grGSF7lJPLh4+jsv3MKNs6vvnyW9nnaecCVnxLl+vrbMLf/YjDXFtqvapQ6Mik31qJumYX+O0pcZOgctJdv7qkr9DXFhlpdWKc+bU9+hmjdZ16rSM08pmC7z7xWEfrv0nhhfR16rbJIOtRBB7aja7y+E/qfgP99j2pLbQ2i2ZNrd20NMqPILeMg9luOgtiv7e+fjTo2GFVkXY66bST0P0g5D+D1OdfG1oPoU9PmgaWo03geWIa+UYWeY/KzCj2OjdisSPQcn/gdsRbgGM8DYsPxSB8j3MdA+n/xzANYry6R7FgH1Kkv7XpxEWQeTA6v1nkvAJvvWRZtL4D3EJagj/cQ0A963UMQW/S6h2CRh/h+3mGJWxkH1zhuMUZHFXqO283iXPYHi9HGsfQ967NIfWlixrUvET/0FxkbjBlfztDWD1wD47m4B8o118cw530u9sNhr7nkvWhpay5tH55lQPrHpebK0Xg9jjXXc/C86PRkt83S5jq+H+WTVnM9pfj7Ts01XDXXLIxRLzUX7ilY1FyDyeG2NRffd/W41ly+PLRTc9nVXGlixrW0NdfnqIawqrl2Uc0l/L8Ac95vU7wGusZb5fyWVHMl5bdXPDWXZi9fzaXVaKg311w4bjXqS3tfKr9vAuuVSKHnmkvoL9B4YYyHrrkWSIca6MB2dI1rLqF/B/zvMtVc2rVmzZ78/oW0eVDGQey3FMZ+Vc5J6O8o61LUbSOhv5Wy5sL7JFwbWw+iz7bmbi3PJs3D+B2xsE7gmgtzpjZG+C4apG96ai6snXj+wOu0fG/5iwpfbU7C+WMwObxa4/thsGn3w3DthHHI74FJW4/1+h4YfAa8l5rLIg/xs+nDEre4/uC4xRjV1isct5vFOddcOJbs3xgzvMZKEzOucc2F/iJjgzHjyxlpa64K4H6D3jlVBLqjUXcfXhPlnyo6psiD9FNEfxxk0OgFL0v0v6/kMMkjJ+B8Q59cFZnxvqZRRa8TJLPQ/6GnFjyh2M332u+TCj3qze/ePQ59cm6Ovoey17xir2OKPHw/2zdT1hJF0Me1sfUg+qxpOQnHjXOSb4xc4zHV7hPAsRGbFaONsXyc+vAn7k9QH8Ys/4RBUZEh7b0Kcu7DPcl4UpuJNo435xP0Tc4nWlwgPeeTkyCDRp8Um3/hySdh7uEttd+5gvelaPlknmQW+r/05BPNl2bgGPuedq8N6s35BP0S713C76HyySnFXicUebJE/62U+eQY6OPa2HoQfdZ6vRfLN0au8ZieUuhxbDgvaPfuavmE74PCmD1OMmj1QNp8Iue6WP44Vm5GoZtLwfMoHHt5/dH/wPVC01cvYD5MyknfHWC9IPKkqRe2o746msJef58yvqdAH9fG1oPoo8Y3+ibHtzamSN/rmIrNitHGnM31AsYQ/9z4lMIH44ljGMdKznUx/INYAf6ZLfe/n3fJra0urNbc++TKtYVqrdTkPUDXxHZTAfjX6o3FtcZiubxcK7dq5fqg+bdWa8uLq8tr9VKztFxerg6a/2Jj6QH35VqjtlBaKy0uDJp/ZWlpYbmyWqotNtfuNGsD13+1ubBWWq6Wm43G4gP1lwauf7PZKtfKi8tLrVqtuTx4/1tafuB4d1qNcrlcaZZag+Zfb64ulRYrjeXm2kKzWl/bjL/Lyz+Ov0vOgp9I7XoG8iOad+Ntkq65Cc/lawdCP5XrYP6Crh1ko24e2DcOfSPUNwF9o9Q3CX3884v8m1hR1Jnb84S5En8v9ddSP7cu/PMkq7E87efW8yQP2jyKNr4/NNDPdNZEnmlFnpwizxPRo3dk8pihfIKFvxf8yvqj/5p/oa3ZDj7bFJXzx6kPxzhLfSOKDNKHPjJBfXgNUvx9KkG3UdJNsLQ45nOTbIFxLzVQlmWFuK/Gn7X45bjH+OW455jAPvQFsY/47jSdtxJ/L/XX2r7bfpdtpNt0Ouq2kdA/HSukrXO0eJiEY1wTFxR61DtL9sJ4KZC9CmHs1b7GumsTexXIXkI/67GXpv+Ex17ab/0VPPZCW+K5zDspFw3KFzezLfui0B9TbKutISdBH9fG1oPoU9fWkLgeywLfpHhB+jTjr8VLkehxvLUcz7ka+U5RH+Zmzv+Y4yW3YS7l+g1zNddvrk2sR136PvwPx8Seotsk0lNfDvrG1rv55OPvco8JY4kcWaL/PMwRD3WAc+T8osJ/nPh3ya0cw/FgrFHlmNA7my7FMgZZS99ZbCzcWSzVK81aq9JsbFbLa3bCOHVNbI1jMa7oliX612Dufh387SGtws/R3fTQZRL+P8RQjo2tdx/Txgh9V+iFd359o4zSNwV9mENcm46/o70QS+TIEv018l30Nzm/qPCfJP5dcivH2HenFPophd6Nz4VYRvFb1N16ffGQJ+HjMZbtJsTVrwBQ/4bX0oYBAA==","debug_symbols":"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","brillig_names":["sync_notes"]}]'),a={globals:{},structs:{functions:[{fields:[{name:"parameters",type:{fields:[{name:"app_payload",type:{fields:[{name:"function_calls",type:{kind:"array",length:4,type:{fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}],kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{name:"target_address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}],kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall"}}},{name:"nonce",type:{kind:"field"}}],kind:"struct",path:"authwit::entrypoint::app::AppPayload"}}],kind:"struct",path:"MultiCallEntrypoint::entrypoint_parameters"}}],kind:"struct",path:"MultiCallEntrypoint::entrypoint_abi"}]}},s=JSON.parse('{"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\\n\\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\\n/// slices - and thus nested vectors as well - are disallowed).\\n///\\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\\n/// pushing an additional element is also more efficient - the length only needs to be increased\\n/// by one.\\n///\\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\\n/// is a reasonable maximum bound that can be placed on the vector.\\n///\\n/// Example:\\n///\\n/// ```noir\\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\\n/// for i in 0..5 {\\n///     vector.push(i);\\n/// }\\n/// assert(vector.len() == 5);\\n/// assert(vector.max_len() == 10);\\n/// ```\\npub struct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    /// Creates a new, empty vector of length zero.\\n    ///\\n    /// Since this container is backed by an array internally, it still needs an initial value\\n    /// to give each element. To resolve this, each element is zeroed internally. This value\\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\\n    /// assert(empty_vector.len() == 0);\\n    /// ```\\n    ///\\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\\n    /// via a type signature:\\n    ///\\n    /// ```noir\\n    /// fn good() -> BoundedVec<Field, 10> {\\n    ///     // Ok! MaxLen is specified with a type annotation\\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\\n    ///     let v2 = BoundedVec::new();\\n    ///\\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\\n    ///     v2\\n    /// }\\n    ///\\n    /// fn bad() {\\n    ///     // Error: Type annotation needed\\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\\n    ///     let mut v3 = BoundedVec::new();\\n    ///     v3.push(5);\\n    /// }\\n    /// ```\\n    ///\\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\\n    /// constraint failure at runtime when the vec is pushed to.\\n    pub fn new() -> Self {\\n        let zeroed = crate::mem::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this\\n    /// will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     let last = v.get(v.len() - 1);\\n    ///     assert(first != last);\\n    /// }\\n    /// ```\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len, \\"Attempted to read past end of BoundedVec\\");\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Retrieves an element from the vector at the given index, starting from zero, without\\n    /// performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element,\\n    /// it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\\n    ///     // Always ensure the length is larger than the largest\\n    ///     // index passed to get_unchecked\\n    ///     assert(v.len() > 2);\\n    ///     let first = v.get_unchecked(0);\\n    ///     let second = v.get_unchecked(1);\\n    ///     let third = v.get_unchecked(2);\\n    ///     first + second + third\\n    /// }\\n    /// ```\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero.\\n    ///\\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\\n    ///     let first = v.get(0);\\n    ///     assert(first != 42);\\n    ///     v.set(0, 42);\\n    ///     let new_first = v.get(0);\\n    ///     assert(new_first == 42);\\n    /// }\\n    /// ```\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\\n    ///\\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// fn set_unchecked_example() {\\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\\n    ///     vec.extend_from_array([1, 2]);\\n    ///\\n    ///     // Here we\'re safely writing within the valid range of `vec`\\n    ///     // `vec` now has the value [42, 2]\\n    ///     vec.set_unchecked(0, 42);\\n    ///\\n    ///     // We can then safely read this value back out of `vec`.\\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\\n    ///     assert_eq(vec.get(0), 42);\\n    ///\\n    ///     // We\'ve now written past the end of `vec`.\\n    ///     // As this index is still within the maximum potential length of `v`,\\n    ///     // it won\'t cause a constraint failure.\\n    ///     vec.set_unchecked(2, 42);\\n    ///     println(vec);\\n    ///\\n    ///     // This will write past the end of the maximum potential length of `vec`,\\n    ///     // it will then trigger a constraint failure.\\n    ///     vec.set_unchecked(5, 42);\\n    ///     println(vec);\\n    /// }\\n    /// ```\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    /// Pushes an element to the end of the vector. This increases the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the new length of the vector will be greater than the max length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    ///\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// // Panics with failed assertion \\"push out of bounds\\"\\n    /// v.push(3);\\n    /// ```\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    /// Returns the current length of this vector\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\\n    /// assert(v.len() == 0);\\n    ///\\n    /// v.push(100);\\n    /// assert(v.len() == 1);\\n    ///\\n    /// v.push(200);\\n    /// v.push(300);\\n    /// v.push(400);\\n    /// assert(v.len() == 4);\\n    ///\\n    /// let _ = v.pop();\\n    /// let _ = v.pop();\\n    /// assert(v.len() == 2);\\n    /// ```\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    /// Returns the maximum length of this vector. This is always\\n    /// equal to the `MaxLen` parameter this vector was initialized with.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.max_len() == 5);\\n    /// v.push(10);\\n    /// assert(v.max_len() == 5);\\n    /// ```\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    /// Returns the internal array within this vector.\\n    ///\\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\\n    /// the storage held internally by this vector.\\n    ///\\n    /// Note that uninitialized elements may be zeroed out!\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\\n    ///\\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\\n    ///\\n    /// v.push(57);\\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    /// Pushes each element from the given array to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_array([2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the given slice to this vector.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\\n    /// vec.extend_from_slice(&[2, 4]);\\n    ///\\n    /// assert(vec.len == 2);\\n    /// assert(vec.get(0) == 2);\\n    /// assert(vec.get(1) == 4);\\n    /// ```\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Pushes each element from the other vector to this vector. The length of\\n    /// the other vector is left unchanged.\\n    ///\\n    /// Panics if pushing each element would cause the length of this vector\\n    /// to exceed the maximum length.\\n    ///\\n    /// ```noir\\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\\n    ///\\n    /// v2.extend_from_array([1, 2, 3]);\\n    /// v1.extend_from_bounded_vec(v2);\\n    ///\\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\\n    /// ```\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        if is_unconstrained() {\\n            for i in 0..append_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        } else {\\n            let mut exceeded_len = false;\\n            for i in 0..Len {\\n                exceeded_len |= i == append_len;\\n                if !exceeded_len {\\n                    self.storage[self.len + i] = vec.get_unchecked(i);\\n                }\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    /// Creates a new vector, populating it with values derived from an array input.\\n    /// The maximum length of the vector is determined based on the type signature.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\\n    /// ```\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        static_assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    /// Pops the element at the end of the vector. This will decrease the length\\n    /// of the vector by one.\\n    ///\\n    /// Panics if the vector is empty.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\\n    /// v.push(1);\\n    /// v.push(2);\\n    ///\\n    /// let two = v.pop();\\n    /// let one = v.pop();\\n    ///\\n    /// assert(two == 2);\\n    /// assert(one == 1);\\n    ///\\n    /// // error: cannot pop from an empty vector\\n    /// let _ = v.pop();\\n    /// ```\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::mem::zeroed();\\n        elem\\n    }\\n\\n    /// Returns true if the given predicate returns true for any element\\n    /// in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\\n    /// v.extend_from_array([2, 4, 6]);\\n    ///\\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\\n    /// assert(all_even);\\n    /// ```\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        if is_unconstrained() {\\n            for i in 0..self.len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        } else {\\n            let mut ret = false;\\n            let mut exceeded_len = false;\\n            for i in 0..MaxLen {\\n                exceeded_len |= i == self.len;\\n                if !exceeded_len {\\n                    ret |= predicate(self.storage[i]);\\n                }\\n            }\\n        }\\n        ret\\n    }\\n\\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n    /// let result = vec.map(|value| value * 2);\\n    ///\\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n    /// assert_eq(result, expected);\\n    /// ```\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n\\n        if is_unconstrained() {\\n            for i in 0..self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i < self.len() {\\n                    ret.storage[i] = f(self.get_unchecked(i));\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function will zero out any elements at or past index `len` of `array`.\\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    /// ```\\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        let zeroed = crate::mem::zeroed();\\n\\n        if is_unconstrained() {\\n            for i in len..MaxLen {\\n                array[i] = zeroed;\\n            }\\n        } else {\\n            for i in 0..MaxLen {\\n                if i >= len {\\n                    array[i] = zeroed;\\n                }\\n            }\\n        }\\n\\n        BoundedVec { storage: array, len }\\n    }\\n\\n    /// Creates a new BoundedVec from the given array and length.\\n    /// The given length must be less than or equal to the length of the array.\\n    ///\\n    /// This function is unsafe because it expects all elements past the `len` index\\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\\n    /// for a safe version of this function which does zero out any indices past the\\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\\n    /// to give incorrect results since it will check even elements past `len`.\\n    ///\\n    /// Example:\\n    ///\\n    /// ```noir\\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n    /// assert_eq(vec.len(), 3);\\n    ///\\n    /// // invalid use!\\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n    ///\\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\\n    /// // fails because elements past the length are still checked in eq\\n    /// assert_eq(vec1, vec2); // fails\\n    /// ```\\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\\n        assert(len <= MaxLen);\\n        BoundedVec { storage: array, len }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        if self.len == other.len {\\n            self.storage == other.storage\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n\\n    mod get {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test(should_fail_with = \\"Attempted to read past end of BoundedVec\\")]\\n        fn panics_when_reading_elements_past_end_of_vec() {\\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\\n\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2) as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.get_unchecked(2), 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n            assert_eq(bounded_vec.get(2), 3);\\n        }\\n\\n        #[test(should_fail_with = \\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n        use crate::convert::From;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.get(0), 1);\\n            assert_eq(bounded_vec.get(1), 2);\\n        }\\n    }\\n\\n    mod trait_eq {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty_equality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n            assert_eq(bounded_vec1, bounded_vec2);\\n        }\\n\\n        #[test]\\n        fn inequality() {\\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n            bounded_vec1.push(1);\\n            bounded_vec2.push(2);\\n\\n            assert(bounded_vec1 != bounded_vec2);\\n        }\\n    }\\n\\n    mod from_parts {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn from_parts() {\\n            // docs:start:from-parts\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // Any elements past the given length are zeroed out, so these\\n            // two BoundedVecs will be completely equal\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\\n            assert_eq(vec1, vec2);\\n            // docs:end:from-parts\\n        }\\n\\n        #[test]\\n        fn from_parts_unchecked() {\\n            // docs:start:from-parts-unchecked\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\\n            assert_eq(vec.len(), 3);\\n\\n            // invalid use!\\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\\n\\n            // both vecs have length 3 so we\'d expect them to be equal, but this\\n            // fails because elements past the length are still checked in eq\\n            assert(vec1 != vec2);\\n            // docs:end:from-parts-unchecked\\n        }\\n    }\\n}\\n"},"24":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"46":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"47":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"54":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/multi_call_entrypoint_contract/src/main.nr","source":"// An entrypoint contract that allows everything to go through. Only used for testing\\n// Pair this with SignerlessWallet to perform multiple actions before any account contracts are deployed (and without authentication)\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\npub contract MultiCallEntrypoint {\\n    use dep::authwit::entrypoint::app::AppPayload;\\n    use dep::aztec::macros::functions::private;\\n\\n    #[private]\\n    fn entrypoint(app_payload: AppPayload) {\\n        app_payload.execute_calls(&mut context);\\n    }\\n}\\n"},"59":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::{\\n    prelude::PrivateContext,\\n    protocol_types::{\\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\\n        hash::poseidon2_hash_with_separator,\\n        traits::{Hash, Serialize},\\n    },\\n};\\nuse std::meta::derive;\\n\\nuse crate::entrypoint::function_call::FunctionCall;\\n\\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\\n\\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\\n\\n// Note: If you change the following struct you have to update default_entrypoint.ts\\n// docs:start:app-payload-struct\\n#[derive(Serialize)]\\npub struct AppPayload {\\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\\n    pub nonce: Field,\\n}\\n// docs:end:app-payload-struct\\n\\nimpl Hash for AppPayload {\\n    fn hash(self) -> Field {\\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\\n    }\\n}\\n\\nimpl AppPayload {\\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\\n\\n        for i in 0..ACCOUNT_MAX_CALLS {\\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\\n        }\\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\\n\\n        bytes.storage()\\n    }\\n\\n    // Executes all private and public calls\\n    // docs:start:entrypoint-execute-calls\\n    pub fn execute_calls(self, context: &mut PrivateContext) {\\n        for call in self.function_calls {\\n            if !call.target_address.is_zero() {\\n                if call.is_public {\\n                    context.call_public_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                } else {\\n                    let _result = context.call_private_function_with_args_hash(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                    );\\n                }\\n            }\\n        }\\n    }\\n    // docs:end:entrypoint-execute-calls\\n}\\n"},"64":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// A dynamically sized array backed by PXE\'s non-volatile database (called capsules). Values are persisted until\\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\\npub struct CapsuleArray<T> {\\n    contract_address: AztecAddress,\\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\\n    base_slot: Field,\\n}\\n\\nimpl<T, let N: u32> CapsuleArray<T>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{\\n    /// Returns a CapsuleArray connected to a contract\'s capsules at a base slot. Array elements are stored in\\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\\n        Self { contract_address, base_slot }\\n    }\\n\\n    /// Returns the number of elements stored in the array.\\n    pub unconstrained fn len(self) -> u32 {\\n        // An uninitialized array defaults to a length of 0.\\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\\n    }\\n\\n    /// Stores a value at the end of the array.\\n    pub unconstrained fn push(self, value: T) {\\n        let current_length = self.len();\\n\\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\\n        // array, which is where we want to place the new value.\\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\\n\\n        // Then we simply update the length.\\n        let new_length = current_length + 1;\\n        capsules::store(self.contract_address, self.base_slot, new_length);\\n    }\\n\\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn get(self, index: u32) -> T {\\n        assert(index < self.len(), \\"Attempted to read past the length of a CapsuleArray\\");\\n\\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\\n    }\\n\\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\\n    pub unconstrained fn remove(self, index: u32) {\\n        let current_length = self.len();\\n        assert(index < current_length, \\"Attempted to delete past the length of a CapsuleArray\\");\\n\\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\\n        // array past the removed element one slot backward so that we don\'t end up with a gap and preserve the\\n        // contiguous slots. We can skip this when deleting the last element however.\\n        if index != current_length - 1 {\\n            // The source and destination regions overlap, but `copy` supports this.\\n            capsules::copy(\\n                self.contract_address,\\n                self.slot_at(index + 1),\\n                self.slot_at(index),\\n                current_length - index - 1,\\n            );\\n        }\\n\\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\\n        // the element we meant to delete in the first place) and update the length.\\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\\n    }\\n\\n    unconstrained fn slot_at(self, index: u32) -> Field {\\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\\n        // element.\\n        self.base_slot + 1 + index as Field\\n    }\\n}\\n\\nmod test {\\n    use crate::test::helpers::test_environment::TestEnvironment;\\n    use super::CapsuleArray;\\n    use protocol_types::address::AztecAddress;\\n\\n    global SLOT: Field = 1230;\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        TestEnvironment::new().unkonstrained().this_address()\\n    }\\n\\n    #[test]\\n    unconstrained fn empty_array() {\\n        let contract_address = setup();\\n\\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn empty_array_read() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        let _: Field = array.get(0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_push() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        assert_eq(array.len(), 1);\\n        assert_eq(array.get(0), 5);\\n    }\\n\\n    #[test(should_fail_with = \\"Attempted to read past the length of a CapsuleArray\\")]\\n    unconstrained fn read_past_len() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n        array.push(5);\\n\\n        let _ = array.get(1);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_last() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(5);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_some() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        assert_eq(array.len(), 3);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 8);\\n        assert_eq(array.get(2), 9);\\n\\n        array.remove(1);\\n\\n        assert_eq(array.len(), 2);\\n        assert_eq(array.get(0), 7);\\n        assert_eq(array.get(1), 9);\\n    }\\n\\n    #[test]\\n    unconstrained fn array_remove_all() {\\n        let contract_address = setup();\\n\\n        let array = CapsuleArray::at(contract_address, SLOT);\\n\\n        array.push(7);\\n        array.push(8);\\n        array.push(9);\\n\\n        array.remove(1);\\n        array.remove(1);\\n        array.remove(0);\\n\\n        assert_eq(array.len(), 0);\\n    }\\n}\\n"},"72":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        execution_cache,\\n        key_validation_request::get_key_validation_request,\\n        notes::{notify_created_nullifier, notify_nullified_note},\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        gas_settings::GasSettings,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Empty, FromField, Hash, ToField},\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn gas_settings(self) -> GasSettings {\\n        self.inputs.tx_context.gas_settings\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        notify_created_nullifier(nullifier);\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        let nullifier_counter = self.next_counter();\\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: nullifier_counter,\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        execution_cache::store(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n\\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\\n            // for the correct public key has been received.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert_eq(request.pk_m.hash(), pk_m_hash, \\"Obtained invalid key validation request\\");\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> ReturnsHash {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_private_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> ReturnsHash {\\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> ReturnsHash {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\\n        // the number of side effects that took place), along with the hash of the return values. We validate these\\n        // by requesting a private kernel iteration in which the return values are constrained to hash\\n        // to `returns_hash` and the side effects counter to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        ReturnsHash::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.call_public_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            enqueue_public_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        execution_cache::store(args);\\n        self.set_public_teardown_function_with_args_hash(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_args_hash(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle hashes the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = unsafe {\\n            set_public_teardown_function_call_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"75":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Packable<N>,\\n    {\\n        T::unpack(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"77":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr","source":"// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\\n\\npub mod private_logs;\\npub mod partial_notes;\\npub mod nonce_discovery;\\n\\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\\n/// one for the combined log and note type ID.\\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\\n\\n/// The maximum length of the packed representation of a note\'s contents. This is limited by private log size, encryption\\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\\npub global MAX_NOTE_PACKED_LEN: u32 =\\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\\n\\npub struct NoteHashAndNullifier {\\n    /// The result of NoteHash::compute_note_hash\\n    pub note_hash: Field,\\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\\n    pub inner_nullifier: Field,\\n}\\n\\n/// A function which takes a note\'s packed content, address of the emitting contract, nonce, storage slot and note type\\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\\n/// address).\\n///\\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\\n///\\n/// ```\\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\\n///     if note_type_id == MyNoteType::get_id() {\\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\\n///\\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n///\\n///         let note_hash = note.compute_note_hash(storage_slot);\\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\\n///             storage_slot\\n///         );\\n///\\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\\n///\\n///         Option::some(\\n///             aztec::discovery::NoteHashAndNullifier {\\n///                 note_hash, inner_nullifier\\n///             }\\n///         )\\n///     } else if note_type_id == MyOtherNoteType::get_id() {\\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\\n///     } else {\\n///         Option::none() // Unknown note type ID\\n///     };\\n/// }\\n/// ```\\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\\n\\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\\n///\\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\\n/// along with its `compute_note_hash_and_nullifier` function.\\npub unconstrained fn discover_new_notes<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    debug_log(\\"Performing note discovery\\");\\n\\n    private_logs::fetch_and_process_private_tagged_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n\\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\\n        contract_address,\\n        compute_note_hash_and_nullifier,\\n    );\\n}\\n"},"78":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr","source":"use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::MAX_NOTE_HASHES_PER_TX,\\n    debug_log::debug_log_format,\\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\\n    traits::ToField,\\n};\\n\\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\\n/// the complete note information, since it does not include content, storage slot, etc.\\npub struct DiscoveredNoteInfo {\\n    pub nonce: Field,\\n    pub note_hash: Field,\\n    pub inner_nullifier: Field,\\n}\\n\\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\\n/// cases it will contain a single element.\\n///\\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\\npub unconstrained fn attempt_note_nonce_discovery<Env>(\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\\n    let discovered_notes = &mut BoundedVec::new();\\n\\n    debug_log_format(\\n        \\"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\\",\\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\\n    );\\n\\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\\n    // is one of the note hashes created by the transaction.\\n    array::for_each_in_bounded_vec(\\n        unique_note_hashes_in_tx,\\n        |expected_unique_note_hash, i| {\\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\\n\\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\\n            // the note hash at the array index we\'re currently processing.\\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\\n            let hashes = compute_note_hash_and_nullifier(\\n                packed_note_content,\\n                storage_slot,\\n                note_type_id,\\n                contract_address,\\n                candidate_nonce,\\n            )\\n                .expect(f\\"Failed to compute a note hash for note type {note_type_id}\\");\\n\\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\\n\\n            if unique_note_hash == expected_unique_note_hash {\\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn\'t, then\\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\\n                // application already has more direct means of making a call to it fail the transaction.\\n                discovered_notes.push(\\n                    DiscoveredNoteInfo {\\n                        nonce: candidate_nonce,\\n                        note_hash: hashes.note_hash,\\n                        inner_nullifier: hashes.inner_nullifier,\\n                    },\\n                );\\n\\n                // We don\'t exit the loop - it is possible (though rare) for the exact same note content to be present\\n                // multiple times in the same transaction with different nonces. This typically doesn\'t happen due to\\n                // notes containing random values in order to hide their contents.\\n            }\\n        },\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered a total of {0} notes\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    *discovered_notes\\n}\\n"},"79":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr","source":"use crate::{\\n    capsules::CapsuleArray,\\n    discovery::{\\n        ComputeNoteHashAndNullifier,\\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\\n    },\\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\\n    debug_log::debug_log_format,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\\n// TODO(#11630): come up with some sort of slot allocation scheme.\\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\\n\\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\\n/// the packed public content.\\n// TODO(#10273): improve how contract log siloing is handled\\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\\n\\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\\n/// size and extra fields in the log (e.g. the tag).\\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\\n\\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\\n/// log that will complete it and lead to a note being discovered and delivered.\\n#[derive(Serialize, Deserialize)]\\npub(crate) struct DeliveredPendingPartialNote {\\n    pub(crate) note_completion_log_tag: Field,\\n    pub(crate) storage_slot: Field,\\n    pub(crate) note_type_id: Field,\\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\\n    pub(crate) recipient: AztecAddress,\\n}\\n\\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\\n/// notes being delivered to PXE if completed.\\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\\n    contract_address: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let pending_partial_notes = CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    );\\n\\n    debug_log_format(\\n        \\"{} pending partial notes\\",\\n        [pending_partial_notes.len() as Field],\\n    );\\n\\n    let mut i = &mut 0;\\n    whyle(\\n        || *i < pending_partial_notes.len(),\\n        || {\\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\\n\\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\\n            if maybe_log.is_none() {\\n                debug_log_format(\\n                    \\"Found no completion logs for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                *i += 1 as u32;\\n                // Note that we\'re not removing the pending partial note from the PXE DB, so we will continue searching\\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\\n                // is somehow removed from the PXE DB.\\n            } else {\\n                debug_log_format(\\n                    \\"Completion log found for partial note with tag {}\\",\\n                    [pending_partial_note.note_completion_log_tag],\\n                );\\n                let log = maybe_log.unwrap();\\n\\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\\n                // that we\'re getting the logs from the expected contract.\\n                // TODO(#10273): improve how contract log siloing is handled\\n                assert_eq(\\n                    log.log_content.get(0),\\n                    contract_address.to_field(),\\n                    \\"Got a public log emitted by a different contract\\",\\n                );\\n\\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\\n                // complete packed content.\\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\\n                let complete_packed_note_content = array::append(\\n                    pending_partial_note.packed_private_note_content,\\n                    packed_public_note_content,\\n                );\\n\\n                let discovered_notes = attempt_note_nonce_discovery(\\n                    log.unique_note_hashes_in_tx,\\n                    log.first_nullifier_in_tx,\\n                    compute_note_hash_and_nullifier,\\n                    contract_address,\\n                    pending_partial_note.storage_slot,\\n                    pending_partial_note.note_type_id,\\n                    complete_packed_note_content,\\n                );\\n\\n                debug_log_format(\\n                    \\"Discovered {0} notes for partial note with tag {1}\\",\\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\\n                );\\n\\n                array::for_each_in_bounded_vec(\\n                    discovered_notes,\\n                    |discovered_note: DiscoveredNoteInfo, _| {\\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\\n                        // temporary node connectivity issue - is simply throwing good enough here?\\n                        assert(\\n                            deliver_note(\\n                                contract_address,\\n                                pending_partial_note.storage_slot,\\n                                discovered_note.nonce,\\n                                complete_packed_note_content,\\n                                discovered_note.note_hash,\\n                                discovered_note.inner_nullifier,\\n                                log.tx_hash,\\n                                pending_partial_note.recipient,\\n                            ),\\n                            \\"Failed to deliver note\\",\\n                        );\\n                    },\\n                );\\n\\n                // Because there is only a single log for a given tag, once we\'ve processed the tagged log then we\\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\\n                // being completed.\\n                pending_partial_notes.remove(*i);\\n\\n                // We don\'t increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\\n                // shifts the elements to the left if the removed element is not the last element.\\n            }\\n        },\\n    );\\n}\\n\\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\\n/// supports looping in unconstrained code.\\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\\n    if condition() {\\n        body();\\n        whyle(condition, body);\\n    }\\n}\\n"},"80":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr","source":"use std::static_assert;\\n\\nuse crate::{\\n    capsules::CapsuleArray,\\n    oracle::note_discovery::{deliver_note, sync_notes},\\n    utils::array,\\n};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\\n    debug_log::{debug_log, debug_log_format},\\n};\\n\\nuse crate::discovery::{\\n    ComputeNoteHashAndNullifier,\\n    MAX_NOTE_PACKED_LEN,\\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\\n    partial_notes::{\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\\n    },\\n};\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\\n// TODO(#12750): don\'t make this value assume we\'re using AES.\\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\\n\\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\\n/// the note completion log tag).\\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\\n\\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\\n/// public logs that will complete them.\\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\\n    _contract_address: AztecAddress,\\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\\n    // decrypted log, letting us continue the work outside of PXE.\\n    sync_notes();\\n}\\n\\n/// Processes a log\'s ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\\n/// which the notes would\'ve been created (typically the same transaction in which the log was emitted), along with the\\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\\npub unconstrained fn do_process_log<Env>(\\n    contract_address: AztecAddress,\\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n) {\\n    let log_plaintext = decrypt_log(log, recipient);\\n\\n    // The first thing to do after decrypting the log is to determine what type of private log we\'re processing. We\\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\\n    // improved upon in the future to also handle events, etc.\\n\\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\\n        destructure_log_plaintext(log_plaintext);\\n\\n    if log_type_id == 0 {\\n        debug_log(\\"Processing private note log\\");\\n\\n        attempt_note_discovery(\\n            contract_address,\\n            tx_hash,\\n            unique_note_hashes_in_tx,\\n            first_nullifier_in_tx,\\n            recipient,\\n            compute_note_hash_and_nullifier,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n        );\\n    } else if log_type_id == 1 {\\n        debug_log(\\"Processing partial note private log\\");\\n\\n        process_partial_note_private_log(\\n            contract_address,\\n            storage_slot,\\n            note_type_id,\\n            log_payload,\\n            recipient,\\n        );\\n    } else {\\n        // TODO(#11569): handle events\\n        debug_log_format(\\n            \\"Unknown log type id {0} (probably belonging to an event log)\\",\\n            [log_type_id],\\n        );\\n    }\\n}\\n\\nunconstrained fn destructure_log_plaintext(\\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\\n    // `storage_slot` and `note_type_id` must be updated as well.\\n    static_assert(\\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\\n        \\"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\\",\\n    );\\n    let storage_slot = log_plaintext.get(0);\\n\\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\\n    // distinguish private note logs and partial note logs.\\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we\'d be able to\\n    // leverage enums and tagged unions to achieve this goal.\\n    let combined_type_id = log_plaintext.get(1);\\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\\n\\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\\n\\n    (storage_slot, note_type_id, log_type_id, log_payload)\\n}\\n\\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\\n/// suspected the note was created.\\npub unconstrained fn attempt_note_discovery<Env>(\\n    contract_address: AztecAddress,\\n    tx_hash: Field,\\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    first_nullifier_in_tx: Field,\\n    recipient: AztecAddress,\\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n) {\\n    let discovered_notes = attempt_note_nonce_discovery(\\n        unique_note_hashes_in_tx,\\n        first_nullifier_in_tx,\\n        compute_note_hash_and_nullifier,\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        packed_note_content,\\n    );\\n\\n    debug_log_format(\\n        \\"Discovered {0} notes from a private log\\",\\n        [discovered_notes.len() as Field],\\n    );\\n\\n    array::for_each_in_bounded_vec(\\n        discovered_notes,\\n        |discovered_note: DiscoveredNoteInfo, _| {\\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\\n            // issue, and we should perhaps not have marked the tag index as taken.\\n            assert(\\n                deliver_note(\\n                    contract_address,\\n                    storage_slot,\\n                    discovered_note.nonce,\\n                    packed_note_content,\\n                    discovered_note.note_hash,\\n                    discovered_note.inner_nullifier,\\n                    tx_hash,\\n                    recipient,\\n                ),\\n                \\"Failed to deliver note\\",\\n            );\\n        },\\n    );\\n}\\n\\nunconstrained fn process_partial_note_private_log(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    recipient: AztecAddress,\\n) {\\n    // We store the information of the partial note we found so that we can later search for the public log that will\\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\\n    static_assert(\\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\\n        \\"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\\",\\n    );\\n\\n    let pending = DeliveredPendingPartialNote {\\n        note_completion_log_tag: log_payload.get(0),\\n        storage_slot,\\n        note_type_id,\\n        packed_private_note_content: array::subbvec(log_payload, 1),\\n        recipient,\\n    };\\n\\n    CapsuleArray::at(\\n        contract_address,\\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\\n    )\\n        .push(pending);\\n}\\n"},"94":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::{Hash, ToField},\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n"},"122":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\\n    notes::NOTES,\\n    utils::{\\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\\n        module_has_storage,\\n    },\\n};\\nuse protocol_types::meta::generate_serialize_to_fields;\\nuse std::meta::type_of;\\n\\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\\n    // Private Kernel Circuit.\\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\\n    // about the execution context (e.g. the caller).\\n    let original_params = f.parameters();\\n    f.set_parameters(&[(\\n        quote { inputs },\\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\\n    )]\\n        .append(original_params));\\n\\n    let mut body = f.body().as_block().unwrap();\\n\\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we\'ve received\\n    // the correct values.\\n    // TODO: Optimize args_hasher for small number of arguments\\n    let args_hasher_name = quote { args_hasher };\\n    let args_hasher = original_params.fold(\\n        quote {\\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n        },\\n        |args_hasher, param: (Quoted, Type)| {\\n            let (name, typ) = param;\\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\\n            quote {\\n                $args_hasher\\n                $appended_arg\\n            }\\n        },\\n    );\\n\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\\n    // and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\\n    // circuit expects.\\n    let return_value_var_name = quote { macro__returned__values };\\n\\n    let return_value_type = f.return_type();\\n    let return_value = if body.len() == 0 {\\n        quote {}\\n    } else if return_value_type != type_of(()) {\\n        // The original return value is passed to a second args hasher which the context receives.\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        let return_value = last_body_expr.quoted();\\n        let return_value_assignment =\\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\\n        let return_hasher_name = quote { return_hasher };\\n        let return_value_into_hasher =\\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\\n\\n        body = body_without_return;\\n\\n        quote {\\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\\n            $return_value_assignment\\n            $return_value_into_hasher\\n            context.set_return_hash($return_hasher_name);\\n        }\\n    } else {\\n        let (body_without_return, last_body_expr) = body.pop_back();\\n        if !last_body_expr.has_semicolon()\\n            & last_body_expr.as_for().is_none()\\n            & last_body_expr.as_assert().is_none()\\n            & last_body_expr.as_for_range().is_none()\\n            & last_body_expr.as_assert_eq().is_none()\\n            & last_body_expr.as_let().is_none() {\\n            let unused_return_value_name = f\\"_{return_value_var_name}\\".quoted_contents();\\n            body = body_without_return.push_back(\\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\\n            );\\n        }\\n        quote {}\\n    };\\n\\n    let context_finish = quote { context.finish() };\\n\\n    let to_prepend = quote {\\n        $args_hasher\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n        $note_discovery_call\\n    };\\n\\n    let to_append = quote {\\n        $return_value\\n        $mark_as_initialized\\n        $context_finish\\n    };\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n    f.set_return_type(\\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\\n            .as_type(),\\n    );\\n    f.set_return_data();\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\\n    let fn_abi = create_fn_abi_export(f);\\n    let fn_stub = stub_fn(f);\\n    stub_registry::register(f.module(), fn_stub);\\n\\n    // If a function is further modified as unconstrained, we throw an error\\n    if f.is_unconstrained() {\\n        let name = f.name();\\n        panic(\\n            f\\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\\",\\n        );\\n    }\\n\\n    let module_has_initializer = module_has_initializer(f.module());\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\\n    let original_params = f.parameters();\\n    let args_len = original_params\\n        .map(|(name, typ): (Quoted, Type)| {\\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\\n        })\\n        .fold(0, |acc: u32, val: u32| acc + val);\\n\\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\\n    let context_creation = quote {\\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\\n        // We start from 1 because we skip the selector for the dispatch function.\\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\\n        dep::aztec::hash::hash_args_array(serialized_args)\\n        });\\n    };\\n\\n    // Modifications introduced by the different marker attributes.\\n    let internal_check = if is_fn_internal(f) {\\n        create_internal_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let view_check = if is_fn_view(f) {\\n        create_view_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\\n    } else {\\n        (quote {}, quote {})\\n    };\\n\\n    let storage_init = if module_has_storage {\\n        // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n        // referenced. We instead ignore \'unused variable\' warnings for it.\\n        quote {\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(&mut context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // Initialization checks are not included in contracts that don\'t have initializers.\\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\\n        create_init_check(f)\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $assert_initializer\\n        $init_check\\n        $internal_check\\n        $view_check\\n        $storage_init\\n    };\\n\\n    let to_append = quote {\\n        $mark_as_initialized\\n    };\\n\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\\n    f.set_body(modified_body);\\n\\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\\n    // bytecode.\\n    f.set_unconstrained(true);\\n    f.set_return_public(true);\\n\\n    fn_abi\\n}\\n\\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\\n    // Top-level unconstrained fns are contract entrypoints, but they\'re not explicitly designated in any way. They\'re\\n    // the fallback case for a function that matches no other rules.\\n    // TODO(#12743): improve this\\n\\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\\n    // public, but which *are* contract entrypoints (i.e. they\'re not opting out via the #[test] or\\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\\n        !is_fn_private(f)\\n            & !is_fn_public(f)\\n            & !f.has_named_attribute(\\"contract_library_method\\")\\n            & !f.has_named_attribute(\\"test\\")\\n    });\\n\\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\\n    // https://github.com/noir-lang/noir/issues/7714). We can\'t simply print a message since that\'d otherwise break the\\n    // output of utils such as `nargo test --list-tests`.\\n    // // We don\'t expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr\'s\\n    // // #[private] macro, possibly resulting in a non-standard interface).\\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n    //     !f.is_unconstrained()\\n    // }) {\\n    //     let name = f.name();\\n    //     warn(\\n    //         f\\"found private contract function \'{name}\' which does not have the #[private] attribute - make sure you know what you\'re doing!\\",\\n    //     );\\n    // }\\n\\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\\n        f.is_unconstrained()\\n    }) {\\n        transform_top_level_unconstrained(f);\\n    }\\n}\\n\\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\\n    let module_has_storage = module_has_storage(f.module());\\n\\n    let storage_init = if module_has_storage {\\n        quote {\\n            // Some functions don\'t access storage, but it\'d be quite difficult to only inject this variable if it is\\n            // referenced. We instead ignore \'unused variable\' warnings for it.\\n            #[allow(unused_variables)]\\n            let storage = Storage::init(context);\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\\n    let note_discovery_call = if NOTES.len() > 0 {\\n        create_note_discovery_call()\\n    } else {\\n        quote {}\\n    };\\n\\n    let to_prepend = quote {\\n        $context_creation\\n        $storage_init\\n        $note_discovery_call\\n    };\\n    let body = f.body().as_block().unwrap();\\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\\n    f.set_return_public(true);\\n    f.set_body(modified_body);\\n}\\n\\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called internally\\";\\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\\n}\\n\\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\\n    let name = f.name();\\n    let assertion_message = f\\"Function {name} can only be called statically\\";\\n    if is_fn_private(f) {\\n        // Here `context` is of type context::PrivateContext\\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\\n    } else {\\n        // Here `context` is of type context::PublicContext\\n        quote { assert(context.is_static_call(), $assertion_message); }\\n    }\\n}\\n\\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\\n    let fn_visibility = get_fn_visibility(f);\\n    f\\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\\"\\n        .quoted_contents()\\n}\\n\\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\\n/// available for the current execution.\\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\\n    quote {\\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\\n        /// safe to call.\\n        unsafe {\\n            dep::aztec::discovery::discover_new_notes(\\n                context.this_address(),\\n                _compute_note_hash_and_nullifier,\\n            );\\n        };\\n    }\\n}\\n"},"123":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/mod.nr","source":"pub mod dispatch;\\npub mod functions;\\npub mod utils;\\npub mod notes;\\npub mod storage;\\npub mod events;\\n\\nuse functions::{\\n    stub_registry,\\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\\n};\\nuse notes::{generate_note_export, NOTES};\\nuse storage::STORAGE_LAYOUT_NAME;\\n\\nuse dispatch::generate_public_dispatch;\\nuse utils::{get_trait_impl_method, module_has_storage};\\n\\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\\n\\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\\npub comptime fn aztec(m: Module) -> Quoted {\\n    let interface = generate_contract_interface(m);\\n\\n    find_and_transform_top_level_unconstrained_fns(m);\\n\\n    let contract_library_method_compute_note_hash_and_nullifier =\\n        generate_contract_library_method_compute_note_hash_and_nullifier();\\n    let process_log = generate_process_log();\\n    let note_exports = generate_note_exports();\\n    let public_dispatch = generate_public_dispatch(m);\\n    let sync_notes = generate_sync_notes();\\n\\n    quote {\\n        $note_exports\\n        $interface\\n        $contract_library_method_compute_note_hash_and_nullifier\\n        $process_log\\n        $public_dispatch\\n        $sync_notes\\n    }\\n}\\n\\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\\n    let module_name = m.name();\\n    let contract_stubs = stub_registry::get(m);\\n    let fn_stubs_quote = if contract_stubs.is_some() {\\n        contract_stubs.unwrap().join(quote {})\\n    } else {\\n        quote {}\\n    };\\n\\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\\n    let storage_layout_getter = if has_storage_layout {\\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\\n        quote {\\n            pub fn storage_layout() -> StorageLayoutFields {\\n                $storage_layout_name.fields\\n            }\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    let library_storage_layout_getter = if has_storage_layout {\\n        quote {\\n            #[contract_library_method]\\n            $storage_layout_getter\\n        }\\n    } else {\\n        quote {}\\n    };\\n\\n    quote {\\n        pub struct $module_name {\\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\\n        }\\n\\n        impl $module_name {\\n            $fn_stubs_quote\\n\\n            pub fn at(\\n                addr: aztec::protocol_types::address::AztecAddress\\n            ) -> Self {\\n                Self { target_contract: addr }\\n            }\\n\\n            pub fn interface() -> Self {\\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n            }\\n\\n            $storage_layout_getter\\n        }\\n\\n        #[contract_library_method]\\n        pub fn at(\\n            addr: aztec::protocol_types::address::AztecAddress\\n        ) -> $module_name {\\n            $module_name { target_contract: addr }\\n        }\\n\\n        #[contract_library_method]\\n        pub fn interface() -> $module_name {\\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\\n        }\\n\\n        $library_storage_layout_getter\\n\\n    }\\n}\\n\\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        let max_note_packed_len = notes.fold(\\n            0,\\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\\n                if len > acc {\\n                    len\\n                } else {\\n                    acc\\n                }\\n            },\\n        );\\n\\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\\n            panic(\\n                f\\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\\",\\n            );\\n        }\\n\\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\\n\\n        let mut if_note_type_id_match_statements_list = &[];\\n        for i in 0..notes.len() {\\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\\n\\n            let get_note_type_id = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteType },\\n                quote { get_id },\\n            );\\n            let unpack = get_trait_impl_method(\\n                typ,\\n                quote { crate::protocol_types::traits::Packable<_> },\\n                quote { unpack },\\n            );\\n\\n            let compute_note_hash = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_note_hash },\\n            );\\n\\n            let compute_nullifier_unconstrained = get_trait_impl_method(\\n                typ,\\n                quote { crate::note::note_interface::NoteHash },\\n                quote { compute_nullifier_unconstrained },\\n            );\\n\\n            let if_or_else_if = if i == 0 {\\n                quote { if }\\n            } else {\\n                quote { else if }\\n            };\\n\\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\\n                quote {\\n                    $if_or_else_if note_type_id == $get_note_type_id() {\\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\\n                        // length, since we\'re about to interpret it\'s raw storage as a fixed-size array by calling the\\n                        // unpack function on it.\\n                        let expected_len = $packed_note_length;\\n                        let actual_len = packed_note.len();\\n                        assert(\\n                            actual_len == expected_len,\\n                            f\\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\\"\\n                        );\\n\\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\\n\\n                        let note_hash = $compute_note_hash(note, storage_slot);\\n    \\n                        // The note discovery process finds settled notes, that is, notes that were created in prior\\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\\n                            aztec::note::retrieved_note::RetrievedNote{ \\n                                note, \\n                                contract_address, \\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \\n                            }, \\n                            storage_slot,\\n                        );\\n\\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\\n\\n                        Option::some(\\n                            aztec::discovery::NoteHashAndNullifier {\\n                                note_hash, inner_nullifier\\n                            }\\n                        )\\n                    }\\n                },\\n            );\\n        }\\n\\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\\n\\n        quote {\\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\\n            /// tree with `nonce`.\\n            ///\\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\\n            /// and `attempt_note_discovery`.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                storage_slot: Field,\\n                note_type_id: Field,\\n                contract_address: aztec::protocol_types::address::AztecAddress,\\n                nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                $if_note_type_id_match_statements\\n                else {\\n                    Option::none()\\n                }\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            /// This contract does not use private notes, so this function should never be called as it will\\n            /// unconditionally fail.\\n            ///\\n            /// This function is automatically injected by the `#[aztec]` macro.\\n            #[contract_library_method]\\n            unconstrained fn _compute_note_hash_and_nullifier(\\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\\n                _storage_slot: Field,\\n                _note_type_id: Field,\\n                _contract_address: aztec::protocol_types::address::AztecAddress,\\n                _nonce: Field,\\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_process_log() -> Quoted {\\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\\n    // and perform note discovery of either private notes or partial notes.\\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\\n    // that function.\\n\\n    // We\'ll produce the entire body of the function in one go and then insert it into the function.\\n    let notes = NOTES.entries();\\n\\n    if notes.len() > 0 {\\n        quote {\\n            unconstrained fn process_log(\\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                tx_hash: Field,\\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                first_nullifier_in_tx: Field,\\n                recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n                // unconstrained execution context since it will not be available otherwise.\\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n                // TODO(#10727): allow other contracts to process logs and deliver notes\\n                let contract_address = context.this_address();\\n\\n                aztec::discovery::private_logs::do_process_log(\\n                    contract_address,\\n                    log_ciphertext,\\n                    tx_hash,\\n                    unique_note_hashes_in_tx,\\n                    first_nullifier_in_tx,\\n                    recipient,\\n                    _compute_note_hash_and_nullifier,\\n                );\\n            }\\n        }\\n    } else {\\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\\n        // simply throws immediately.\\n        quote {\\n            unconstrained fn process_log(\\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\\n                _tx_hash: Field,\\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\\n                _first_nullifier_in_tx: Field,\\n                _recipient: aztec::protocol_types::address::AztecAddress,\\n            ) {\\n                panic(f\\"This contract does not use private notes\\")\\n            }\\n        }\\n    }\\n}\\n\\ncomptime fn generate_note_exports() -> Quoted {\\n    let notes = NOTES.values();\\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it\'s only used when\\n    // generating partial note helper functions.\\n    notes\\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\\n            generate_note_export(s, note_type_id, fields)\\n        })\\n        .join(quote {})\\n}\\n\\ncomptime fn generate_sync_notes() -> Quoted {\\n    let note_discovery_call = create_note_discovery_call();\\n    quote {\\n        unconstrained fn sync_notes() {\\n            // Because this unconstrained function is injected after the contract is processed by the macros, it\'ll not\\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\\n            // unconstrained execution context since it will not be available otherwise.\\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\\n\\n            $note_discovery_call\\n        }\\n    }\\n}\\n"},"143":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> [Field; 2] {}\\n\\npub unconstrained fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> (u32, Field) {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n    );\\n\\n    let mut reader = Reader::new(fields);\\n    let end_side_effect_counter = reader.read_u32();\\n    let returns_hash = reader.read();\\n\\n    (end_side_effect_counter, returns_hash)\\n}\\n"},"144":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\\n\\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\\n/// data was already stored at this slot, it is overwritten.\\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\\nwhere\\n    T: Serialize<N>,\\n{\\n    let serialized = value.serialize();\\n    store_oracle(contract_address, slot, serialized);\\n}\\n\\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\\n/// nothing was stored at the given slot.\\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\\nwhere\\n    T: Deserialize<N>,\\n{\\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\\n}\\n\\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\\n    delete_oracle(contract_address, slot);\\n}\\n\\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\\npub unconstrained fn copy(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {\\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\\n}\\n\\n#[oracle(storeCapsule)]\\nunconstrained fn store_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    values: [Field; N],\\n) {}\\n\\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\\n/// have.\\n///\\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\\n#[oracle(loadCapsule)]\\nunconstrained fn load_oracle<let N: u32>(\\n    contract_address: AztecAddress,\\n    slot: Field,\\n    array_len: u32,\\n) -> Option<[Field; N]> {}\\n\\n#[oracle(deleteCapsule)]\\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\\n\\n#[oracle(copyCapsule)]\\nunconstrained fn copy_oracle(\\n    contract_address: AztecAddress,\\n    src_slot: Field,\\n    dst_slot: Field,\\n    num_entries: u32,\\n) {}\\n\\nmod test {\\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\\n    // oracles are hooked up correctly.\\n\\n    use crate::{\\n        oracle::capsules::{copy, delete, load, store},\\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\\n    };\\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\\n\\n    unconstrained fn setup() -> AztecAddress {\\n        let env = TestEnvironment::new();\\n        env.contract_address()\\n    }\\n\\n    global SLOT: Field = 1;\\n\\n    #[test]\\n    unconstrained fn stores_and_loads() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\\n    }\\n\\n    #[test]\\n    unconstrained fn store_overwrites() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n\\n        let new_value = MockStruct::new(7, 8);\\n        store(contract_address, SLOT, new_value);\\n\\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\\n    }\\n\\n    #[test]\\n    unconstrained fn loads_empty_slot() {\\n        let contract_address = setup();\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_stored_value() {\\n        let contract_address = setup();\\n\\n        let value = MockStruct::new(5, 6);\\n        store(contract_address, SLOT, value);\\n        delete(contract_address, SLOT);\\n\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn deletes_empty_slot() {\\n        let contract_address = setup();\\n\\n        delete(contract_address, SLOT);\\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\\n        assert_eq(loaded_value, Option::none());\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_non_overlapping_values() {\\n        let contract_address = setup();\\n\\n        let src = 5;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 10;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 1;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 2;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\\n    }\\n\\n    #[test]\\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\\n        let contract_address = setup();\\n\\n        let src = 2;\\n\\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\\n        store(contract_address, src, values[0]);\\n        store(contract_address, src + 1, values[1]);\\n        store(contract_address, src + 2, values[2]);\\n\\n        let dst = 1;\\n        copy(contract_address, src, dst, 3);\\n\\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\\n\\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\\n    }\\n\\n    #[test(should_fail_with = \\"copy empty slot\\")]\\n    unconstrained fn cannot_copy_empty_values() {\\n        let contract_address = setup();\\n\\n        copy(contract_address, SLOT, SLOT, 1);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_store_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let value = MockStruct::new(5, 6);\\n        store(other_contract_address, SLOT, value);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_load_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_delete_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        delete(other_contract_address, SLOT);\\n    }\\n\\n    #[test(should_fail_with = \\"not allowed to access\\")]\\n    unconstrained fn cannot_copy_other_contract() {\\n        let contract_address = setup();\\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\\n\\n        copy(other_contract_address, SLOT, SLOT, 0);\\n    }\\n}\\n"},"145":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"146":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"157":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr","source":"use crate::discovery::MAX_NOTE_PACKED_LEN;\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\\n};\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\\n/// available for later querying via the `get_notes` oracle.\\npub unconstrained fn sync_notes() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n\\n/// Informs PXE of a note\'s existence so that it can later be retrieved by the `getNotes` oracle. The note will be\\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\\n///\\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\\n///\\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\\n/// other accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized.\\n///\\n/// Returns true if the note was successfully delivered and added to PXE\'s database.\\npub unconstrained fn deliver_note(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {\\n    deliver_note_oracle(\\n        contract_address,\\n        storage_slot,\\n        nonce,\\n        packed_note,\\n        note_hash,\\n        nullifier,\\n        tx_hash,\\n        recipient,\\n    )\\n}\\n\\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\\n/// is the data required in order to discover notes that are being delivered in a log.\\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\\n// log.\\npub struct LogWithTxData {\\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\\n    pub tx_hash: Field,\\n    /// The array of new note hashes created by `tx_hash`\\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\\n    /// The first nullifier created by `tx_hash`\\n    pub first_nullifier_in_tx: Field,\\n}\\n\\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\\n/// the tag is the first field in the log\'s content. Returns `Option::none` if no such log exists. Throws if more than\\n/// one log with that tag exists.\\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\\n// TODO(#11627): handle multiple logs with the same tag.\\n// TODO(#10273): improve contract siloing of logs, don\'t introduce an extra field.\\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\\n    get_log_by_tag_oracle(tag)\\n}\\n\\n#[oracle(deliverNote)]\\nunconstrained fn deliver_note_oracle(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    nonce: Field,\\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\\n    note_hash: Field,\\n    nullifier: Field,\\n    tx_hash: Field,\\n    recipient: AztecAddress,\\n) -> bool {}\\n\\n#[oracle(getLogByTag)]\\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\\n"},"185":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\\n/// large enough to fit all of the elements of both the first and second vectors.\\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\\n    a: BoundedVec<T, A_LEN>,\\n    b: BoundedVec<T, B_LEN>,\\n) -> BoundedVec<T, DST_LEN> {\\n    let mut dst = BoundedVec::new();\\n\\n    dst.extend_from_bounded_vec(a);\\n    dst.extend_from_bounded_vec(b);\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::append;\\n\\n    #[test]\\n    unconstrained fn append_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::new();\\n        let b: BoundedVec<_, 14> = BoundedVec::new();\\n\\n        let result: BoundedVec<Field, 5> = append(a, b);\\n\\n        assert_eq(result.len(), 0);\\n        assert_eq(result.storage(), std::mem::zeroed());\\n    }\\n\\n    #[test]\\n    unconstrained fn append_non_empty_vecs() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let result: BoundedVec<Field, 8> = append(a, b);\\n\\n        assert_eq(result.len(), 6);\\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\\n    }\\n\\n    #[test(should_fail_with = \\"out of bounds\\")]\\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\\n\\n        let _: BoundedVec<Field, 5> = append(a, b);\\n    }\\n}\\n"},"187":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr","source":"pub mod append;\\npub mod collapse;\\npub mod subarray;\\npub mod subbvec;\\n\\npub use append::append;\\npub use collapse::collapse;\\npub use subarray::subarray;\\npub use subbvec::subbvec;\\n\\n// This will eventually be replaced by `BoundedVec::for_each`, once that\'s implemented.\\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\\n    vec: BoundedVec<T, MaxLen>,\\n    f: fn[Env](T, u32) -> (),\\n) {\\n    for i in 0..vec.len() {\\n        f(vec.get_unchecked(i), i);\\n    }\\n}\\n"},"188":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\\n/// of elements past `offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\\n/// assert_eq(foo, [3, 4]);\\n///\\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\\n/// ```\\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [T; SRC_LEN],\\n    offset: u32,\\n) -> [T; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"DST_LEN too large for offset\\");\\n\\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\nmod test {\\n    use super::subarray;\\n\\n    #[test]\\n    unconstrained fn subarray_into_empty() {\\n        // In all of these cases we\'re setting DST_LEN to be 0, so we always get back an emtpy array.\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_complete() {\\n        assert_eq(subarray::<Field, _, _>([], 0), []);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\\n    }\\n\\n    #[test]\\n    unconstrained fn subarray_different_end_sizes() {\\n        // We implicitly select how many values to read in the size of the return array\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subarray_offset_too_large() {\\n        // With an offset of 1 we can only request up to 4 elements\\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subarray_bad_return_value() {\\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\\n    }\\n}\\n"},"189":{"path":"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\\n\\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\\n/// zeroed elements past `len()`).\\n///\\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\\n///\\n/// Examples:\\n/// ```\\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n///\\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can\'t return just 1 element since 3 remain\\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can\'t return 10 elements since only 7 remain\\n/// ```\\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\\n    offset: u32,\\n) -> BoundedVec<T, DST_MAX_LEN> {\\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\\n    // because we\'re constructing the new storage array as a subarray of the original one (which should have zeroed\\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\\n    // their original length.\\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\\n}\\n\\nmod test {\\n    use super::subbvec;\\n\\n    #[test]\\n    unconstrained fn subbvec_empty() {\\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_complete() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), bvec);\\n\\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_partial() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\\n    }\\n\\n    #[test]\\n    unconstrained fn subbvec_into_empty() {\\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_offset_past_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\\n    }\\n\\n    #[test(should_fail)]\\n    unconstrained fn subbvec_insufficient_dst_len() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // We\'re not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\\n        // for the capacity to reduce, but not the length (other than by len - offset).\\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // subbvec does not supprt capacity increases\\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\\n    }\\n\\n    #[test(should_fail_with = \\"DST_LEN too large for offset\\")]\\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\\n\\n        // This effectively requests a capacity increase, since there\'d be just one element plus the 5 empty slots,\\n        // which is less than 7.\\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\\n    }\\n}\\n"},"261":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\\n        MAX_PROTOCOL_CONTRACTS,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::poseidon2_hash_with_separator,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::{\\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\\n    ops::Add,\\n};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\n/// We implement the Packable trait for AztecAddress because it can be stored in contract\'s storage (and there\\n/// the implementation of Packable is required).\\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        self.serialize()\\n    }\\n\\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        Self::deserialize(fields)\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_class_id(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_protocol_contract(self) -> bool {\\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"278":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\\n/// Example:\\n///   debug_log(\\"blah blah this is a debug string\\");\\npub fn debug_log<let N: u32>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n\\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\\n/// Examples:\\n///   debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n///   debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\\n    // to call.\\n    unsafe { debug_log_oracle_wrapper(msg, args) };\\n}\\n\\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\\n    msg: str<M>,\\n    args: [Field; N],\\n) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\\n"},"279":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        contract_class_log::ContractClassLog,\\n        function_selector::FunctionSelector,\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::{OrderedValue, scoped::Scoped},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    poseidon2::Poseidon2Sponge,\\n    traits::{FromField, Hash, ToField},\\n    utils::{\\n        arrays::{array_concat, unsafe_padded_array_length},\\n        field::{field_from_bytes, field_from_bytes_32_trunc},\\n    },\\n};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256::digest(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\\n    // unique).\\n    poseidon2_hash_with_separator(\\n        [first_nullifier_in_tx, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    first_nullifier: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_contract_class_log_field(\\n    contract_address: AztecAddress,\\n    first_field: Field,\\n) -> Field {\\n    poseidon2_hash([contract_address.to_field(), first_field])\\n}\\n\\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\\n    if contract_class_log.contract_address.is_zero() {\\n        contract_class_log\\n    } else {\\n        let mut log = contract_class_log;\\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\\n            contract_class_log.contract_address,\\n            log.log.fields[0],\\n        );\\n        log\\n    }\\n}\\n\\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\\n    let array = contract_class_log.log.fields;\\n    // Safety: The below length is constrained in the base rollup.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    if length == 0 {\\n        0\\n    } else {\\n        poseidon2_hash(array)\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: [u8; 160] = std::mem::zeroed();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..5 {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes[32 * i + j] = item_bytes[j];\\n        }\\n    }\\n\\n    sha256_to_field(bytes)\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a u128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> Poseidon2Sponge {\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> Poseidon2Sponge {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: Poseidon2Sponge,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> Poseidon2Sponge {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let iv: Field = (in_len as Field) * TWO_POW_64;\\n    let mut sponge = Poseidon2Sponge::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256::digest(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"293":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use super::traits::{Deserialize, Packable, Serialize};\\n\\n/// Returns the typed expression of a trait method implementation.\\n///\\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\\n/// warnings that the trait implementation is not in scope).\\n///\\n/// # Note\\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\\ncomptime fn get_trait_impl_method(\\n    typ: Type,\\n    target_trait: Quoted,\\n    target_method: Quoted,\\n) -> TypedExpr {\\n    let trait_constraint = target_trait.as_trait_constraint();\\n    typ\\n        .get_trait_impl(trait_constraint)\\n        .expect(f\\"Could not find impl for {target_trait} for type {typ}\\")\\n        .methods()\\n        .filter(|m| m.name() == target_method)[0]\\n        .as_typed_expr()\\n}\\n\\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\\n///\\n/// # Parameters\\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\\"values\\"`).\\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\\n/// and `Serialize` trait for more information about the difference between packing and serialization).\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\\n///\\n/// # Nested Struct Example\\n/// Given the following setup:\\n/// ```\\n/// struct UintNote {\\n///     value: u128,\\n///     owner: AztecAddress,\\n///     randomness: Field,\\n/// }\\n///\\n/// struct AztecAddress {\\n///     inner: Field,\\n/// }\\n/// ```\\n///\\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\\n/// ```\\n/// UintNote {\\n///     value: fields[0] as u128,\\n///     owner: AztecAddress {\\n///         inner: fields[1],\\n///     },\\n///     randomness: fields[2],\\n/// }\\n/// ```\\n/// # Nested Struct Example with Unpacking\\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\\n///   the result we get is:\\n/// ```\\n/// UintNote {\\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\\n/// }\\n/// ```\\n///\\n/// # Panics\\n/// - If the deserialization logic encounters a type it does not support.\\n/// - If an incorrect number of fields are consumed when deserializing a string.\\npub comptime fn generate_deserialize_from_fields(\\n    name: Quoted,\\n    typ: Type,\\n    field_array_name: Quoted,\\n    num_already_consumed: u32,\\n    should_unpack: bool,\\n) -> (Quoted, u32) {\\n    let mut result = quote {};\\n    // Counter for the number of fields consumed\\n    let mut consumed_counter: u32 = 0;\\n\\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n    if (should_unpack & typ.implements(packable_constraint)) {\\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\\n        let mut packed_fields_quotes = &[];\\n        for i in 0..packed_len {\\n            let index_in_field_array = i + num_already_consumed;\\n            packed_fields_quotes =\\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\\n        }\\n        let packed_fields = packed_fields_quotes.join(quote {,});\\n\\n        // Now we call unpack on the type\\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\\n        result = quote { $unpack_method([ $packed_fields ]) };\\n\\n        consumed_counter = packed_len;\\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\\n        // The field is a primitive so we just reference it in the field array\\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\\n        consumed_counter = 1;\\n    } else if typ.as_data_type().is_some() {\\n        // The field is a struct so we iterate over each struct field and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (nested_def, generics) = typ.as_data_type().unwrap();\\n        let nested_name = nested_def.name();\\n        let mut deserialized_fields_list = &[];\\n\\n        // Iterate over each field in the struct\\n        for field in nested_def.fields(generics) {\\n            let (field_name, field_type) = field;\\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                field_name,\\n                field_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\\n            deserialized_fields_list =\\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\\n        }\\n\\n        // We can construct the struct from the deserialized fields\\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\\n        result = quote {\\n                $nested_name {\\n                    $deserialized_fields\\n                }\\n            };\\n    } else if typ.as_array().is_some() {\\n        // The field is an array so we iterate over each element and recursively call\\n        // `generate_deserialize_from_fields`\\n        let (element_type, array_len) = typ.as_array().unwrap();\\n        let array_len = array_len.as_constant().unwrap();\\n        let mut array_fields_list = &[];\\n\\n        // Iterate over each element in the array\\n        for _ in 0..array_len {\\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                element_type,\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n            // We increment the consumed counter by the number of fields consumed in the recursion\\n            consumed_counter += num_consumed_in_recursion;\\n            // We add the deserialized field to the list of deserialized fields.\\n            array_fields_list = array_fields_list.push_back(deserialized_field);\\n        }\\n\\n        // We can construct the array from the deserialized fields\\n        let array_fields = array_fields_list.join(quote {,});\\n        result = quote { [ $array_fields ] };\\n    } else if typ.as_str().is_some() {\\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\\n        // to `generate_deserialize_from_fields`.\\n        let length_type = typ.as_str().unwrap();\\n        let str_len = length_type.as_constant().unwrap();\\n        let mut byte_list = &[];\\n\\n        // Iterate over each character in the string\\n        for _ in 0..str_len {\\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\\n                name,\\n                quote {u8}.as_type(),\\n                field_array_name,\\n                consumed_counter + num_already_consumed,\\n                should_unpack,\\n            );\\n\\n            // We should consume just one field in the recursion so we sanity check that\\n            assert_eq(\\n                num_consumed_in_recursion,\\n                1,\\n                \\"Incorrect number of fields consumed in string deserialization\\",\\n            );\\n\\n            // We increment the consumed counter by 1 as we have consumed one field\\n            consumed_counter += 1;\\n\\n            // We add the deserialized field to the list of deserialized fields.\\n            // E.g. `fields[6] as u8`\\n            byte_list = byte_list.push_back(deserialized_field);\\n        }\\n\\n        // We construct the string from the deserialized fields\\n        let bytes = byte_list.join(quote {,});\\n        result = quote { [ $bytes ].as_str_unchecked() };\\n    } else {\\n        panic(\\n            f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n        )\\n    }\\n\\n    (result, consumed_counter)\\n}\\n\\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\\n/// if it does.\\n///\\n/// # Parameters\\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\\n/// - `should_pack`: A boolean indicating whether the type should be packed.\\n///\\n/// # Returns\\n/// A tuple containing:\\n/// - A flattened array of `Quoted` field references representing the serialized fields.\\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\\n///\\n/// # Examples\\n///\\n/// ## Struct\\n/// Given the following struct:\\n/// ```rust\\n/// struct MockStruct {\\n///     a: Field,\\n///     b: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing the struct:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\\n/// // Returns:\\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\\n/// ```\\n///\\n/// ## Nested Struct\\n/// For a more complex struct:\\n/// ```rust\\n/// struct NestedStruct {\\n///     m1: MockStruct,\\n///     m2: MockStruct,\\n/// }\\n/// ```\\n///\\n/// Serialization output:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\\n/// // Returns:\\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\\n/// ```\\n///\\n/// ## Array\\n/// For an array type:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\\n/// // Returns:\\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\\n/// ```\\n///\\n/// ## String\\n/// For a string field, where each character is serialized as a `Field`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\\n/// // Returns:\\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\\n/// ```\\n///\\n/// ## Nested Struct with Omitted Field and packing enabled\\n/// - u128 has a `Packable` implementation hence it will be packed.\\n///\\n/// For a more complex struct:\\n/// ```rust\\n/// struct MyStruct {\\n///     value: u128,\\n///     value2: Field,\\n/// }\\n/// ```\\n///\\n/// Serializing while omitting `value2`:\\n/// ```rust\\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\\n/// // Returns:\\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\\n/// ```\\n///\\n/// # Panics\\n/// - If the type is unsupported for serialization.\\n/// - If the provided `typ` contains invalid constants or incompatible structures.\\npub comptime fn generate_serialize_to_fields(\\n    name: Quoted,\\n    typ: Type,\\n    omit: [Quoted],\\n    should_pack: bool,\\n) -> ([Quoted], [Quoted]) {\\n    let mut fields = &[];\\n    let mut aux_vars = &[];\\n\\n    // Proceed if none of the omit rules omits this name\\n    if !omit.any(|to_omit| to_omit == name) {\\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\\n        let packable_constraint =\\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\\n\\n        if (should_pack & typ.implements(packable_constraint)) {\\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\\n\\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \\"self.value\\" -> \\"self_value\\").\\n            let name_at_one_token = collapse_to_one_token(name);\\n            let packed_struct_name = f\\"{name_at_one_token}_aux_var\\".quoted_contents();\\n\\n            // We add the individual fields to the fields array\\n            let pack_method = get_trait_impl_method(\\n                typ,\\n                quote { crate::traits::Packable<$packed_len> },\\n                quote { pack },\\n            );\\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\\n            for i in 0..packed_len {\\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\\n            }\\n\\n            // We add the new auxiliary variable to the aux_vars array\\n            aux_vars = aux_vars.push_back(packed_struct);\\n        } else if typ.is_field() {\\n            // For field we just add the value to fields\\n            fields = fields.push_back(name);\\n        } else if typ.as_integer().is_some() | typ.is_bool() {\\n            // For integer and bool we just cast to Field and add the value to fields\\n            fields = fields.push_back(quote { $name as Field });\\n        } else if typ.as_data_type().is_some() {\\n            // For struct we pref\\n            let nested_struct = typ.as_data_type().unwrap();\\n            let params = nested_struct.0.fields(nested_struct.1);\\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\\n                let maybe_prefixed_name = if name == quote {} {\\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\\n                    // argument) --> then we don\'t prefix the name with anything.\\n                    param_name\\n                } else {\\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\\n                    // can typically be `self` when implementing a method on a struct.\\n                    quote { $name.$param_name }\\n                };\\n                generate_serialize_to_fields(\\n                    quote {$maybe_prefixed_name},\\n                    param_type,\\n                    omit,\\n                    should_pack,\\n                )\\n            });\\n            let struct_flattened_fields = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\\n            );\\n            let struct_flattened_aux_vars = struct_flattened.fold(\\n                &[],\\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\\n            );\\n            fields = fields.append(struct_flattened_fields);\\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\\n        } else if typ.as_array().is_some() {\\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\\n            let (element_type, array_len) = typ.as_array().unwrap();\\n            let array_len = array_len.as_constant().unwrap();\\n            for i in 0..array_len {\\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\\n                    quote { $name[$i] },\\n                    element_type,\\n                    omit,\\n                    should_pack,\\n                );\\n                fields = fields.append(element_fields);\\n                aux_vars = aux_vars.append(element_aux_vars);\\n            }\\n        } else if typ.as_str().is_some() {\\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\\n            // then we add each byte to fields as a Field\\n            let length_type = typ.as_str().unwrap();\\n            let str_len = length_type.as_constant().unwrap();\\n            let as_member = name.as_expr().unwrap().as_member_access();\\n            let var_name = if as_member.is_some() {\\n                as_member.unwrap().1\\n            } else {\\n                name\\n            };\\n            let as_bytes_name = f\\"{var_name}_as_bytes\\".quoted_contents();\\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\\n            for i in 0..str_len {\\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\\n            }\\n            aux_vars = aux_vars.push_back(as_bytes);\\n        } else {\\n            panic(\\n                f\\"Unsupported type for serialization of argument {name} and type {typ}\\",\\n            )\\n        }\\n    }\\n    (fields, aux_vars)\\n}\\n\\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\\n/// E.g. \\"self.values[0]\\" -> \\"self_values_0_\\"\\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\\n    let tokens = q.tokens();\\n\\n    let mut single_token = quote {};\\n    for token in tokens {\\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\\n            quote {_}\\n        } else {\\n            token\\n        };\\n        single_token = f\\"{single_token}{new_token}\\".quoted_contents();\\n    }\\n    single_token\\n}\\n\\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let field_serializations = fields.join(quote {,});\\n    let serialized_len = fields.len();\\n    quote {\\n        impl Serialize<$serialized_len> for $typ {\\n            fn serialize(self) -> [Field; $serialized_len] {\\n                $aux_vars_for_serialization\\n                [ $field_serializations ]\\n            }\\n        }\\n    }\\n}\\n\\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\\n    let typ = s.as_type();\\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\\n    let serialized_len = fields.len();\\n    let (deserialized, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\\n    quote {\\n        impl Deserialize<$serialized_len> for $typ {\\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\\n                $deserialized\\n            }\\n        }\\n    }\\n}\\n\\n/// Generates `Packable` implementation for a given struct and returns the packed length.\\n///\\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\\n    let packing_enabled = true;\\n\\n    let typ = s.as_type();\\n    let (fields, aux_vars) =\\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\\n        let joint = aux_vars.join(quote {;});\\n        quote { $joint; }\\n    } else {\\n        quote {}\\n    };\\n\\n    let (unpacked, _) =\\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\\n\\n    let field_packings = fields.join(quote {,});\\n    let packed_len = fields.len();\\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\\n    (\\n        quote {\\n        impl $packable_trait for $typ {\\n            fn pack(self) -> [Field; $packed_len] {\\n                $aux_vars_for_packing\\n                [ $field_packings ]\\n            }\\n\\n            fn unpack(packed: [Field; $packed_len]) -> Self {\\n                $unpacked\\n            }\\n        }\\n    },\\n        packed_len,\\n    )\\n}\\n\\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\\n    packable_impl\\n}\\n\\n#[derive(Packable, Serialize, Deserialize, Eq)]\\npub struct Smol {\\n    a: Field,\\n    b: Field,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct HasArray {\\n    a: [Field; 2],\\n    b: bool,\\n}\\n\\n#[derive(Serialize, Deserialize, Eq)]\\npub struct Fancier {\\n    a: Smol,\\n    b: [Field; 2],\\n    c: [u8; 3],\\n    d: str<16>,\\n}\\n\\nfn main() {\\n    assert(false);\\n}\\n\\n#[test]\\nfn smol_test() {\\n    let smol = Smol { a: 1, b: 2 };\\n    let serialized = smol.serialize();\\n    assert(serialized == [1, 2], serialized);\\n    let deserialized = Smol::deserialize(serialized);\\n    assert(deserialized == smol);\\n\\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\\n    let packed = smol.pack();\\n    assert_eq(packed, serialized, \\"Packed does not match serialized\\");\\n}\\n\\n#[test]\\nfn has_array_test() {\\n    let has_array = HasArray { a: [1, 2], b: true };\\n    let serialized = has_array.serialize();\\n    assert(serialized == [1, 2, 1], serialized);\\n    let deserialized = HasArray::deserialize(serialized);\\n    assert(deserialized == has_array);\\n}\\n\\n#[test]\\nfn fancier_test() {\\n    let fancier =\\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \\"metaprogramming!\\" };\\n    let serialized = fancier.serialize();\\n    assert(\\n        serialized\\n            == [\\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\\n            ],\\n        serialized,\\n    );\\n    let deserialized = Fancier::deserialize(serialized);\\n    assert(deserialized == fancier);\\n}\\n"},"296":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\\n\\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\\n// has a private absorb() method (it\'s also designed to just be a hasher)\\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2Sponge {\\n    pub cache: [Field; 3],\\n    pub state: [Field; 4],\\n    pub cache_size: u32,\\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2Sponge {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\\n        let mut result =\\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    pub fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    pub fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let iv: Field = (in_len as Field) * TWO_POW_64;\\n        let mut sponge = Poseidon2Sponge::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n"},"335":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 1;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u128\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"351":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\\n// is not found, the function returns N as the index.\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays where validate_array(array) returns true,\\n// which ensures that:\\n// 1. All elements before the first empty element are non-empty\\n// 2. All elements after and including the first empty element are empty\\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // We get the length by checking the index of the first empty element.\\n\\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\\n    // of the element and non-emptiness of the previous element is checked below.\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\\n/// if this is not the case then elements from the end of `array2` will be dropped.\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: we constrain this array below\\n    let result = unsafe { array_merge_helper(array1, array2) };\\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\\n    let array1_len = array_length(array1);\\n    let mut add_from_left = true;\\n    for i in 0..N {\\n        add_from_left &= i != array1_len;\\n        if add_from_left {\\n            assert_eq(result[i], array1[i]);\\n        } else {\\n            assert_eq(result[i], array2[i - array1_len]);\\n        }\\n    }\\n    result\\n}\\n\\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n// Helper function to find the index of the last element in an array, allowing empty elements.\\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut index = N;\\n    for i in 0..N {\\n        let j = N - i - 1;\\n        // We check `index == N` to ensure that we only update the index if we haven\'t found a match yet.\\n        if (index == N) & !is_empty(array[j]) {\\n            index = j;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which returns the length of an array right padded by empty elements\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\n// See smoke_validate_array_trailing for examples.\\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let index = find_last_value_index(array);\\n    if index == N {\\n        0\\n    } else {\\n        index + 1\\n    }\\n}\\n\\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    // Safety: this value is constrained in the below loop.\\n    let length = unsafe { unsafe_padded_array_length(array) };\\n    // Check the elt just before length is non-zero:\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]), \\"invalid right padded array\\");\\n    }\\n    // Check all beyond length are zero:\\n    let mut check_zero = false;\\n    for i in 0..N {\\n        check_zero |= i == length;\\n        if check_zero {\\n            assert(is_empty(array[i]), \\"invalid right padded array\\");\\n        }\\n    }\\n    length\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test]\\nfn smoke_validate_array_trailing() {\\n    let valid_array: [Field; 0] = [];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(padded_array_length(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(padded_array_length(valid_array) == 1);\\n\\n    let valid_array = [1, 0, 3];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 0, 3, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n\\n    let valid_array = [0, 0, 3, 0, 0];\\n    assert(padded_array_length(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nunconstrained fn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nunconstrained fn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = find_index_hint(values, |v: Field| min.lt(v));\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concatenated = array_concat(array0, array1);\\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"354":{"path":"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"}}'),r={transpiled:!0,noir_version:e,name:n,functions:t,outputs:a,file_map:s};export{r as default,s as file_map,t as functions,n as name,e as noir_version,a as outputs,i as transpiled};
